{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#welcome","title":"Welcome","text":"<p>Go check out the rest of our website to see how you can get started with your favorite app. Most images come with docker cli or compose examples. If you've got any questions, feel free to join the discord server.</p>"},{"location":"#donations","title":"Donations","text":"<p>If you like what I do, you know the drill... </p> <p> GitHub Sponsors  Open Collective  Bitcoin</p>"},{"location":"#affiliate-links","title":"Affiliate Links","text":""},{"location":"#support","title":"Support","text":"<p>Join us on Discord!</p> <p> </p>"},{"location":"faq/","title":"FAQ","text":"I'm here if you need me..."},{"location":"faq/#troubleshooting","title":"Troubleshooting","text":"Someone asked you for a 'docker-compose' snippet...How do you give them that? <p>If you are not using <code>docker-compose</code>, that can sound like a daunting task. Have no fear though, the following cli command spits it out.</p> <pre><code>docker run --rm -v /var/run/docker.sock:/var/run/docker.sock:ro ghcr.io/red5d/docker-autocompose &lt;container-name-or-id&gt; [&lt;additional-names-or-ids&gt;]\n</code></pre> <p>Now you should upload this to logs.notifiarr.com after removing personal details and passwords.</p>"},{"location":"faq/#installation","title":"Installation","text":"Installing Docker, how and where? <p>I'd have a look at the official Docker Engine installation instructions.</p>"},{"location":"faq/#guides","title":"Guides","text":"I would like to execute my own scripts on startup, how would I do this? <p>This will only work for containers using <code>s6 overlay</code>, recognisable by <code>ENVIRONMENT</code> printed at the top of the log when the container starts.</p> <p>If you have a need to do additional stuff when the container starts or stops, you can mount your script with the volume <code>/docker/host/my-script.sh:/etc/cont-init.d/99-my-script</code> to execute your script on container start or <code>/docker/host/my-script.sh:/etc/cont-finish.d/99-my-script</code> to execute it when the container stops. An example script can be seen below.</p> <pre><code>#!/command/with-contenv bash\necho \"Hello, this is me, your script.\"\n</code></pre> How can I get a static IP for one of my containers using 'docker-compose'? <p>Here's a basic docker-compose example that sets up a custom network and gives the plex container a static IP.</p> <pre><code>version: \"3.7\"\n\nnetworks:\n  my-custom-network:\n    name: my-custom-network\n    driver: bridge\n    ipam:\n      driver: default\n      config:\n        - subnet: 10.1.0.0/24\n\nservices:\n  plex:\n    container_name: plex\n    image: hotio/plex\n    ports:\n      - \"32400:32400\"\n    networks:\n      my-custom-network:\n        ipv4_address: 10.1.0.100\n    ...\n\n  radarr:\n    container_name: radarr\n    image: hotio/radarr\n    ports:\n      - \"7878:7878\"\n    networks:\n      - my-custom-network\n    ...\n</code></pre> How do I route a container's traffic through a VPN container? <p>Small docker-compose example below. Notice the <code>...</code>, this isn't a copy/paste ready to go example.</p> <pre><code>version: \"3.7\"\n\nservices:\n  qbittorrent:\n    container_name: qbittorrent\n    image: hotio/qbittorrent\n    ports:\n      - \"8080:8080\"\n      - \"9117:9117\"\n    environment:\n      ...\n      - VPN_EXPOSE_PORTS_ON_LAN=9117/tcp,9117/udp\n    ...\n\n  jackett:\n    container_name: jackett\n    image: hotio/jackett\n    network_mode: \"service:qbittorrent\"\n    ...\n</code></pre> Got any Docker guides? <p>Take a look here for an extensive guide on best practises from the *arr team.</p> But, but, how do I configure all this stuff? <p>Maybe TRaSH from TRaSH Guides can help...</p>"},{"location":"containers/autoscan/","title":"hotio/autoscan","text":"<p> GitHub ghcr.io</p>"},{"location":"containers/autoscan/#starting-the-container","title":"Starting the container","text":"clicompose <pre><code>docker run --rm \\\n    --name autoscan \\\n    -p 3030:3030 \\\n    -e PUID=1000 \\\n    -e PGID=1000 \\\n    -e UMASK=002 \\\n    -e TZ=\"Etc/UTC\" \\\n    -v /&lt;host_folder_config&gt;:/config \\\n    -v /&lt;host_folder_data&gt;:/data \\\n    ghcr.io/hotio/autoscan\n</code></pre> <pre><code>services:\n  autoscan:\n    container_name: autoscan\n    image: ghcr.io/hotio/autoscan\n    ports:\n      - \"3030:3030\"\n    environment:\n      - PUID=1000\n      - PGID=1000\n      - UMASK=002\n      - TZ=Etc/UTC\n    volumes:\n      - /&lt;host_folder_config&gt;:/config\n      - /&lt;host_folder_data&gt;:/data\n</code></pre>"},{"location":"containers/autoscan/#tags","title":"Tags","text":"Tags Description Last Updated Age"},{"location":"containers/autoscan/#wireguard","title":"WireGuard","text":"<p>Info</p> <p>This image includes VPN support. The cli/compose examples below are environment variables and settings complementary to the app image examples, this means you'll have to add/merge the stuff below with the stuff above. In case you are still in need of a VPN, consider using my affiliate links for Proton VPN, Proton Unlimited or Private Internet Access.</p> <p> </p> genericprotonpia clicompose <pre><code>docker run --rm \\\n    --hostname container-name.internal \\ #(18)\n    -e VPN_ENABLED=\"true\" \\ #(5)\n    -e VPN_CONF=\"wg0\" \\ #(8)\n    -e VPN_PROVIDER=\"generic\" \\ #(4)\n    -e VPN_LAN_NETWORK=\"192.168.1.0/24\" \\ #(1)\n    -e VPN_LAN_LEAK_ENABLED=\"false\" \\ #(10)\n    -e VPN_EXPOSE_PORTS_ON_LAN=\"\" \\ #(2)\n    -e VPN_AUTO_PORT_FORWARD=\"false\" \\ #(6)\n    -e VPN_AUTO_PORT_FORWARD_TO_PORTS=\"\" \\ #(15)\n    -e VPN_FIREWALL_TYPE=\"auto\" \\ #(17)\n    -e VPN_HEALTHCHECK_ENABLED=\"false\" \\ #(20)\n    -e VPN_NAMESERVERS=\"\" \\ #(16)\n    -e PRIVOXY_ENABLED=\"false\" \\ #(19)\n    -e UNBOUND_ENABLED=\"false\" \\ #(21)\n    -e UNBOUND_NAMESERVERS=\"\" \\ #(22)\n    --cap-add=NET_ADMIN \\\n    --sysctl=\"net.ipv4.conf.all.src_valid_mark=1\" \\ #(12)\n    --sysctl=\"net.ipv6.conf.all.disable_ipv6=1\" \\ #(3)\n    --device /dev/net/tun:/dev/net/tun \\ # OPTIONAL(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui. On MacOS set it to <code>192.168.65.0/24</code> (Verify with your settings [Resources &gt; Network &gt; Docker subnet]).</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>. Affiliate links: Proton VPN Proton Unlimited Private Internet Access</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> (for PIA this is done automatically, see <code>VPN_PROVIDER</code> variable) located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32 in most cases\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>DANGEROUS! Don't enable unless you know what you are doing!</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>Some of the possible values are for example <code>wg</code>, <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>wg</code> will use the nameservers from the <code>wg0.conf</code> file. A value in the format <code>8.8.8.8</code> is to use a plain old nameserver. A value in the format <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>If you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice.</p> </li> <li> <p>This will start Privoxy on the default port 8118 when set to <code>true</code>. By default Privoxy is not exposed on the LAN, so if you need that, you'll have to add <code>VPN_EXPOSE_PORTS_ON_LAN=8118/tcp,8118/udp</code>.</p> </li> <li> <p>Enabling this will bring down the container if the connectivity tests fail at the end of the Wireguard init process or for an extended period during the container runtime.</p> </li> <li> <p>Enable Unbound by setting to <code>true</code> when VPN is not active.</p> </li> <li> <p>Possible values are <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>8.8.8.8</code> is to use a plain old nameserver. The value <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> </ol> <pre><code>services:\n  app:\n    hostname: container-name.internal #(18)\n    environment:\n      - VPN_ENABLED=true #(5)\n      - VPN_CONF=wg0 #(8)\n      - VPN_PROVIDER=generic #(4)\n      - VPN_LAN_NETWORK=192.168.1.0/24 #(1)\n      - VPN_LAN_LEAK_ENABLED=false #(10)\n      - VPN_EXPOSE_PORTS_ON_LAN #(2)\n      - VPN_AUTO_PORT_FORWARD=false #(6)\n      - VPN_AUTO_PORT_FORWARD_TO_PORTS= #(15)\n      - VPN_FIREWALL_TYPE=auto #(17)\n      - VPN_HEALTHCHECK_ENABLED=false #(20)\n      - VPN_NAMESERVERS= #(16)\n      - PRIVOXY_ENABLED=false #(19)\n      - UNBOUND_ENABLED=false #(21)\n      - UNBOUND_NAMESERVERS #(22)\n    cap_add:\n      - NET_ADMIN\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1 #(12)\n      - net.ipv6.conf.all.disable_ipv6=1 #(3)\n    devices:\n      - /dev/net/tun:/dev/net/tun # OPTIONAL(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui. On MacOS set it to <code>192.168.65.0/24</code> (Verify with your settings [Resources &gt; Network &gt; Docker subnet]).</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>. Affiliate links: Proton VPN Proton Unlimited Private Internet Access</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> (for PIA this is done automatically, see <code>VPN_PROVIDER</code> variable) located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32 in most cases\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>DANGEROUS! Don't enable unless you know what you are doing!</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>Some of the possible values are for example <code>wg</code>, <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>wg</code> will use the nameservers from the <code>wg0.conf</code> file. A value in the format <code>8.8.8.8</code> is to use a plain old nameserver. A value in the format <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>If you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice.</p> </li> <li> <p>This will start Privoxy on the default port 8118 when set to <code>true</code>. By default Privoxy is not exposed on the LAN, so if you need that, you'll have to add <code>VPN_EXPOSE_PORTS_ON_LAN=8118/tcp,8118/udp</code>.</p> </li> <li> <p>Enabling this will bring down the container if the connectivity tests fail at the end of the Wireguard init process or for an extended period during the container runtime.</p> </li> <li> <p>Enable Unbound by setting to <code>true</code> when VPN is not active.</p> </li> <li> <p>Possible values are <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>8.8.8.8</code> is to use a plain old nameserver. The value <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> </ol> clicompose <pre><code>docker run --rm \\\n    --hostname container-name.internal \\ #(18)\n    -e VPN_ENABLED=\"true\" \\ #(5)\n    -e VPN_CONF=\"wg0\" \\ #(8)\n    -e VPN_PROVIDER=\"proton\" \\ #(4)\n    -e VPN_LAN_NETWORK=\"192.168.1.0/24\" \\ #(1)\n    -e VPN_LAN_LEAK_ENABLED=\"false\" \\ #(10)\n    -e VPN_EXPOSE_PORTS_ON_LAN=\"\" \\ #(2)\n    -e VPN_AUTO_PORT_FORWARD=\"true\" \\ #(6)\n    -e VPN_AUTO_PORT_FORWARD_TO_PORTS=\"\" \\ #(15)\n    -e VPN_FIREWALL_TYPE=\"auto\" \\ #(17)\n    -e VPN_HEALTHCHECK_ENABLED=\"false\" \\ #(20)\n    -e VPN_NAMESERVERS=\"\" \\ #(16)\n    -e PRIVOXY_ENABLED=\"false\" \\ #(19)\n    -e UNBOUND_ENABLED=\"false\" \\ #(21)\n    -e UNBOUND_NAMESERVERS=\"\" \\ #(22)\n    --cap-add=NET_ADMIN \\\n    --sysctl=\"net.ipv4.conf.all.src_valid_mark=1\" \\ #(12)\n    --sysctl=\"net.ipv6.conf.all.disable_ipv6=1\" \\ #(3)\n    --device /dev/net/tun:/dev/net/tun \\ # OPTIONAL(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui. On MacOS set it to <code>192.168.65.0/24</code> (Verify with your settings [Resources &gt; Network &gt; Docker subnet]).</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>. Affiliate links: Proton VPN Proton Unlimited Private Internet Access</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> (for PIA this is done automatically, see <code>VPN_PROVIDER</code> variable) located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32 in most cases\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>DANGEROUS! Don't enable unless you know what you are doing!</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>Some of the possible values are for example <code>wg</code>, <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>wg</code> will use the nameservers from the <code>wg0.conf</code> file. A value in the format <code>8.8.8.8</code> is to use a plain old nameserver. A value in the format <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>If you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice.</p> </li> <li> <p>This will start Privoxy on the default port 8118 when set to <code>true</code>. By default Privoxy is not exposed on the LAN, so if you need that, you'll have to add <code>VPN_EXPOSE_PORTS_ON_LAN=8118/tcp,8118/udp</code>.</p> </li> <li> <p>Enabling this will bring down the container if the connectivity tests fail at the end of the Wireguard init process or for an extended period during the container runtime.</p> </li> <li> <p>Enable Unbound by setting to <code>true</code> when VPN is not active.</p> </li> <li> <p>Possible values are <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>8.8.8.8</code> is to use a plain old nameserver. The value <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> </ol> <pre><code>services:\n  app:\n    hostname: container-name.internal #(18)\n    environment:\n      - VPN_ENABLED=true #(5)\n      - VPN_CONF=wg0 #(8)\n      - VPN_PROVIDER=proton #(4)\n      - VPN_LAN_NETWORK=192.168.1.0/24 #(1)\n      - VPN_LAN_LEAK_ENABLED=false #(10)\n      - VPN_EXPOSE_PORTS_ON_LAN #(2)\n      - VPN_AUTO_PORT_FORWARD=true #(6)\n      - VPN_AUTO_PORT_FORWARD_TO_PORTS= #(15)\n      - VPN_FIREWALL_TYPE=auto #(17)\n      - VPN_HEALTHCHECK_ENABLED=false #(20)\n      - VPN_NAMESERVERS= #(16)\n      - PRIVOXY_ENABLED=false #(19)\n      - UNBOUND_ENABLED=false #(21)\n      - UNBOUND_NAMESERVERS #(22)\n    cap_add:\n      - NET_ADMIN\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1 #(12)\n      - net.ipv6.conf.all.disable_ipv6=1 #(3)\n    devices:\n      - /dev/net/tun:/dev/net/tun # OPTIONAL(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui. On MacOS set it to <code>192.168.65.0/24</code> (Verify with your settings [Resources &gt; Network &gt; Docker subnet]).</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>. Affiliate links: Proton VPN Proton Unlimited Private Internet Access</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> (for PIA this is done automatically, see <code>VPN_PROVIDER</code> variable) located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32 in most cases\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>DANGEROUS! Don't enable unless you know what you are doing!</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>Some of the possible values are for example <code>wg</code>, <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>wg</code> will use the nameservers from the <code>wg0.conf</code> file. A value in the format <code>8.8.8.8</code> is to use a plain old nameserver. A value in the format <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>If you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice.</p> </li> <li> <p>This will start Privoxy on the default port 8118 when set to <code>true</code>. By default Privoxy is not exposed on the LAN, so if you need that, you'll have to add <code>VPN_EXPOSE_PORTS_ON_LAN=8118/tcp,8118/udp</code>.</p> </li> <li> <p>Enabling this will bring down the container if the connectivity tests fail at the end of the Wireguard init process or for an extended period during the container runtime.</p> </li> <li> <p>Enable Unbound by setting to <code>true</code> when VPN is not active.</p> </li> <li> <p>Possible values are <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>8.8.8.8</code> is to use a plain old nameserver. The value <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> </ol> clicompose <pre><code>docker run --rm \\\n    --hostname container-name.internal \\ #(18)\n    -e VPN_ENABLED=\"true\" \\ #(5)\n    -e VPN_CONF=\"wg0\" \\ #(8)\n    -e VPN_PROVIDER=\"pia\" \\ #(4)\n    -e VPN_LAN_NETWORK=\"192.168.1.0/24\" \\ #(1)\n    -e VPN_LAN_LEAK_ENABLED=\"false\" \\ #(10)\n    -e VPN_EXPOSE_PORTS_ON_LAN=\"\" \\ #(2)\n    -e VPN_AUTO_PORT_FORWARD=\"true\" \\ #(6)\n    -e VPN_AUTO_PORT_FORWARD_TO_PORTS=\"\" \\ #(15)\n    -e VPN_FIREWALL_TYPE=\"auto\" \\ #(17)\n    -e VPN_HEALTHCHECK_ENABLED=\"false\" \\ #(20)\n    -e VPN_NAMESERVERS=\"\" \\ #(16)\n    -e VPN_PIA_USER=\"\" \\ #(11)\n    -e VPN_PIA_PASS=\"\" \\ #(11)\n    -e VPN_PIA_PREFERRED_REGION=\"\" \\ #(7)\n    -e VPN_PIA_DIP_TOKEN=\"no\" \\ #(13)\n    -e VPN_PIA_PORT_FORWARD_PERSIST=\"false\" \\ #(14)\n    -e PRIVOXY_ENABLED=\"false\" \\ #(19)\n    -e UNBOUND_ENABLED=\"false\" \\ #(21)\n    -e UNBOUND_NAMESERVERS=\"\" \\ #(22)\n    --cap-add=NET_ADMIN \\\n    --sysctl=\"net.ipv4.conf.all.src_valid_mark=1\" \\ #(12)\n    --sysctl=\"net.ipv6.conf.all.disable_ipv6=1\" \\ #(3)\n    --device /dev/net/tun:/dev/net/tun \\ # OPTIONAL(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui. On MacOS set it to <code>192.168.65.0/24</code> (Verify with your settings [Resources &gt; Network &gt; Docker subnet]).</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>. Affiliate links: Proton VPN Proton Unlimited Private Internet Access</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> (for PIA this is done automatically, see <code>VPN_PROVIDER</code> variable) located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32 in most cases\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>DANGEROUS! Don't enable unless you know what you are doing!</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>Some of the possible values are for example <code>wg</code>, <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>wg</code> will use the nameservers from the <code>wg0.conf</code> file. A value in the format <code>8.8.8.8</code> is to use a plain old nameserver. A value in the format <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>If you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice.</p> </li> <li> <p>This will start Privoxy on the default port 8118 when set to <code>true</code>. By default Privoxy is not exposed on the LAN, so if you need that, you'll have to add <code>VPN_EXPOSE_PORTS_ON_LAN=8118/tcp,8118/udp</code>.</p> </li> <li> <p>Enabling this will bring down the container if the connectivity tests fail at the end of the Wireguard init process or for an extended period during the container runtime.</p> </li> <li> <p>Enable Unbound by setting to <code>true</code> when VPN is not active.</p> </li> <li> <p>Possible values are <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>8.8.8.8</code> is to use a plain old nameserver. The value <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> </ol> <pre><code>services:\n  app:\n    hostname: container-name.internal #(18)\n    environment:\n      - VPN_ENABLED=true #(5)\n      - VPN_CONF=wg0 #(8)\n      - VPN_PROVIDER=pia #(4)\n      - VPN_LAN_NETWORK=192.168.1.0/24 #(1)\n      - VPN_LAN_LEAK_ENABLED=false #(10)\n      - VPN_EXPOSE_PORTS_ON_LAN #(2)\n      - VPN_AUTO_PORT_FORWARD=true #(6)\n      - VPN_AUTO_PORT_FORWARD_TO_PORTS= #(15)\n      - VPN_FIREWALL_TYPE=auto #(17)\n      - VPN_HEALTHCHECK_ENABLED=false #(20)\n      - VPN_NAMESERVERS= #(16)\n      - VPN_PIA_USER #(11)\n      - VPN_PIA_PASS #(11)\n      - VPN_PIA_PREFERRED_REGION #(7)\n      - VPN_PIA_DIP_TOKEN=no #(13)\n      - VPN_PIA_PORT_FORWARD_PERSIST=false #(14)\n      - PRIVOXY_ENABLED=false #(19)\n      - UNBOUND_ENABLED=false #(21)\n      - UNBOUND_NAMESERVERS #(22)\n    cap_add:\n      - NET_ADMIN\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1 #(12)\n      - net.ipv6.conf.all.disable_ipv6=1 #(3)\n    devices:\n      - /dev/net/tun:/dev/net/tun # OPTIONAL(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui. On MacOS set it to <code>192.168.65.0/24</code> (Verify with your settings [Resources &gt; Network &gt; Docker subnet]).</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>. Affiliate links: Proton VPN Proton Unlimited Private Internet Access</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> (for PIA this is done automatically, see <code>VPN_PROVIDER</code> variable) located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32 in most cases\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>DANGEROUS! Don't enable unless you know what you are doing!</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>Some of the possible values are for example <code>wg</code>, <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>wg</code> will use the nameservers from the <code>wg0.conf</code> file. A value in the format <code>8.8.8.8</code> is to use a plain old nameserver. A value in the format <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>If you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice.</p> </li> <li> <p>This will start Privoxy on the default port 8118 when set to <code>true</code>. By default Privoxy is not exposed on the LAN, so if you need that, you'll have to add <code>VPN_EXPOSE_PORTS_ON_LAN=8118/tcp,8118/udp</code>.</p> </li> <li> <p>Enabling this will bring down the container if the connectivity tests fail at the end of the Wireguard init process or for an extended period during the container runtime.</p> </li> <li> <p>Enable Unbound by setting to <code>true</code> when VPN is not active.</p> </li> <li> <p>Possible values are <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>8.8.8.8</code> is to use a plain old nameserver. The value <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> </ol>"},{"location":"containers/base/","title":"hotio/base","text":"<p> GitHub ghcr.io</p>"},{"location":"containers/base/#starting-the-container","title":"Starting the container","text":"clicompose <pre><code>docker run --rm \\\n    --name base \\\n    -e PUID=1000 \\\n    -e PGID=1000 \\\n    -e UMASK=002 \\\n    -e TZ=\"Etc/UTC\" \\\n    -v /&lt;host_folder_config&gt;:/config \\\n    ghcr.io/hotio/base:alpinevpn\n</code></pre> <pre><code>services:\n  base:\n    container_name: base\n    image: ghcr.io/hotio/base:alpinevpn\n    environment:\n      - PUID=1000\n      - PGID=1000\n      - UMASK=002\n      - TZ=Etc/UTC\n    volumes:\n      - /&lt;host_folder_config&gt;:/config\n</code></pre> <p>This image is the base image for all other application images, however it can be used as a standalone VPN image for other images to attach to.</p>"},{"location":"containers/base/#tags","title":"Tags","text":"Tags Description Last Updated Age"},{"location":"containers/base/#wireguard","title":"WireGuard","text":"<p>Info</p> <p>This image includes VPN support. The cli/compose examples below are environment variables and settings complementary to the app image examples, this means you'll have to add/merge the stuff below with the stuff above. In case you are still in need of a VPN, consider using my affiliate links for Proton VPN, Proton Unlimited or Private Internet Access.</p> <p> </p> genericprotonpia clicompose <pre><code>docker run --rm \\\n    --hostname container-name.internal \\ #(18)\n    -e VPN_ENABLED=\"true\" \\ #(5)\n    -e VPN_CONF=\"wg0\" \\ #(8)\n    -e VPN_PROVIDER=\"generic\" \\ #(4)\n    -e VPN_LAN_NETWORK=\"192.168.1.0/24\" \\ #(1)\n    -e VPN_LAN_LEAK_ENABLED=\"false\" \\ #(10)\n    -e VPN_EXPOSE_PORTS_ON_LAN=\"\" \\ #(2)\n    -e VPN_AUTO_PORT_FORWARD=\"false\" \\ #(6)\n    -e VPN_AUTO_PORT_FORWARD_TO_PORTS=\"\" \\ #(15)\n    -e VPN_FIREWALL_TYPE=\"auto\" \\ #(17)\n    -e VPN_HEALTHCHECK_ENABLED=\"false\" \\ #(20)\n    -e VPN_NAMESERVERS=\"\" \\ #(16)\n    -e PRIVOXY_ENABLED=\"false\" \\ #(19)\n    -e UNBOUND_ENABLED=\"false\" \\ #(21)\n    -e UNBOUND_NAMESERVERS=\"\" \\ #(22)\n    --cap-add=NET_ADMIN \\\n    --sysctl=\"net.ipv4.conf.all.src_valid_mark=1\" \\ #(12)\n    --sysctl=\"net.ipv6.conf.all.disable_ipv6=1\" \\ #(3)\n    --device /dev/net/tun:/dev/net/tun \\ # OPTIONAL(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui. On MacOS set it to <code>192.168.65.0/24</code> (Verify with your settings [Resources &gt; Network &gt; Docker subnet]).</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>. Affiliate links: Proton VPN Proton Unlimited Private Internet Access</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> (for PIA this is done automatically, see <code>VPN_PROVIDER</code> variable) located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32 in most cases\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>DANGEROUS! Don't enable unless you know what you are doing!</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>Some of the possible values are for example <code>wg</code>, <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>wg</code> will use the nameservers from the <code>wg0.conf</code> file. A value in the format <code>8.8.8.8</code> is to use a plain old nameserver. A value in the format <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>If you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice.</p> </li> <li> <p>This will start Privoxy on the default port 8118 when set to <code>true</code>. By default Privoxy is not exposed on the LAN, so if you need that, you'll have to add <code>VPN_EXPOSE_PORTS_ON_LAN=8118/tcp,8118/udp</code>.</p> </li> <li> <p>Enabling this will bring down the container if the connectivity tests fail at the end of the Wireguard init process or for an extended period during the container runtime.</p> </li> <li> <p>Enable Unbound by setting to <code>true</code> when VPN is not active.</p> </li> <li> <p>Possible values are <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>8.8.8.8</code> is to use a plain old nameserver. The value <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> </ol> <pre><code>services:\n  app:\n    hostname: container-name.internal #(18)\n    environment:\n      - VPN_ENABLED=true #(5)\n      - VPN_CONF=wg0 #(8)\n      - VPN_PROVIDER=generic #(4)\n      - VPN_LAN_NETWORK=192.168.1.0/24 #(1)\n      - VPN_LAN_LEAK_ENABLED=false #(10)\n      - VPN_EXPOSE_PORTS_ON_LAN #(2)\n      - VPN_AUTO_PORT_FORWARD=false #(6)\n      - VPN_AUTO_PORT_FORWARD_TO_PORTS= #(15)\n      - VPN_FIREWALL_TYPE=auto #(17)\n      - VPN_HEALTHCHECK_ENABLED=false #(20)\n      - VPN_NAMESERVERS= #(16)\n      - PRIVOXY_ENABLED=false #(19)\n      - UNBOUND_ENABLED=false #(21)\n      - UNBOUND_NAMESERVERS #(22)\n    cap_add:\n      - NET_ADMIN\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1 #(12)\n      - net.ipv6.conf.all.disable_ipv6=1 #(3)\n    devices:\n      - /dev/net/tun:/dev/net/tun # OPTIONAL(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui. On MacOS set it to <code>192.168.65.0/24</code> (Verify with your settings [Resources &gt; Network &gt; Docker subnet]).</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>. Affiliate links: Proton VPN Proton Unlimited Private Internet Access</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> (for PIA this is done automatically, see <code>VPN_PROVIDER</code> variable) located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32 in most cases\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>DANGEROUS! Don't enable unless you know what you are doing!</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>Some of the possible values are for example <code>wg</code>, <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>wg</code> will use the nameservers from the <code>wg0.conf</code> file. A value in the format <code>8.8.8.8</code> is to use a plain old nameserver. A value in the format <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>If you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice.</p> </li> <li> <p>This will start Privoxy on the default port 8118 when set to <code>true</code>. By default Privoxy is not exposed on the LAN, so if you need that, you'll have to add <code>VPN_EXPOSE_PORTS_ON_LAN=8118/tcp,8118/udp</code>.</p> </li> <li> <p>Enabling this will bring down the container if the connectivity tests fail at the end of the Wireguard init process or for an extended period during the container runtime.</p> </li> <li> <p>Enable Unbound by setting to <code>true</code> when VPN is not active.</p> </li> <li> <p>Possible values are <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>8.8.8.8</code> is to use a plain old nameserver. The value <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> </ol> clicompose <pre><code>docker run --rm \\\n    --hostname container-name.internal \\ #(18)\n    -e VPN_ENABLED=\"true\" \\ #(5)\n    -e VPN_CONF=\"wg0\" \\ #(8)\n    -e VPN_PROVIDER=\"proton\" \\ #(4)\n    -e VPN_LAN_NETWORK=\"192.168.1.0/24\" \\ #(1)\n    -e VPN_LAN_LEAK_ENABLED=\"false\" \\ #(10)\n    -e VPN_EXPOSE_PORTS_ON_LAN=\"\" \\ #(2)\n    -e VPN_AUTO_PORT_FORWARD=\"true\" \\ #(6)\n    -e VPN_AUTO_PORT_FORWARD_TO_PORTS=\"\" \\ #(15)\n    -e VPN_FIREWALL_TYPE=\"auto\" \\ #(17)\n    -e VPN_HEALTHCHECK_ENABLED=\"false\" \\ #(20)\n    -e VPN_NAMESERVERS=\"\" \\ #(16)\n    -e PRIVOXY_ENABLED=\"false\" \\ #(19)\n    -e UNBOUND_ENABLED=\"false\" \\ #(21)\n    -e UNBOUND_NAMESERVERS=\"\" \\ #(22)\n    --cap-add=NET_ADMIN \\\n    --sysctl=\"net.ipv4.conf.all.src_valid_mark=1\" \\ #(12)\n    --sysctl=\"net.ipv6.conf.all.disable_ipv6=1\" \\ #(3)\n    --device /dev/net/tun:/dev/net/tun \\ # OPTIONAL(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui. On MacOS set it to <code>192.168.65.0/24</code> (Verify with your settings [Resources &gt; Network &gt; Docker subnet]).</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>. Affiliate links: Proton VPN Proton Unlimited Private Internet Access</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> (for PIA this is done automatically, see <code>VPN_PROVIDER</code> variable) located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32 in most cases\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>DANGEROUS! Don't enable unless you know what you are doing!</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>Some of the possible values are for example <code>wg</code>, <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>wg</code> will use the nameservers from the <code>wg0.conf</code> file. A value in the format <code>8.8.8.8</code> is to use a plain old nameserver. A value in the format <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>If you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice.</p> </li> <li> <p>This will start Privoxy on the default port 8118 when set to <code>true</code>. By default Privoxy is not exposed on the LAN, so if you need that, you'll have to add <code>VPN_EXPOSE_PORTS_ON_LAN=8118/tcp,8118/udp</code>.</p> </li> <li> <p>Enabling this will bring down the container if the connectivity tests fail at the end of the Wireguard init process or for an extended period during the container runtime.</p> </li> <li> <p>Enable Unbound by setting to <code>true</code> when VPN is not active.</p> </li> <li> <p>Possible values are <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>8.8.8.8</code> is to use a plain old nameserver. The value <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> </ol> <pre><code>services:\n  app:\n    hostname: container-name.internal #(18)\n    environment:\n      - VPN_ENABLED=true #(5)\n      - VPN_CONF=wg0 #(8)\n      - VPN_PROVIDER=proton #(4)\n      - VPN_LAN_NETWORK=192.168.1.0/24 #(1)\n      - VPN_LAN_LEAK_ENABLED=false #(10)\n      - VPN_EXPOSE_PORTS_ON_LAN #(2)\n      - VPN_AUTO_PORT_FORWARD=true #(6)\n      - VPN_AUTO_PORT_FORWARD_TO_PORTS= #(15)\n      - VPN_FIREWALL_TYPE=auto #(17)\n      - VPN_HEALTHCHECK_ENABLED=false #(20)\n      - VPN_NAMESERVERS= #(16)\n      - PRIVOXY_ENABLED=false #(19)\n      - UNBOUND_ENABLED=false #(21)\n      - UNBOUND_NAMESERVERS #(22)\n    cap_add:\n      - NET_ADMIN\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1 #(12)\n      - net.ipv6.conf.all.disable_ipv6=1 #(3)\n    devices:\n      - /dev/net/tun:/dev/net/tun # OPTIONAL(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui. On MacOS set it to <code>192.168.65.0/24</code> (Verify with your settings [Resources &gt; Network &gt; Docker subnet]).</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>. Affiliate links: Proton VPN Proton Unlimited Private Internet Access</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> (for PIA this is done automatically, see <code>VPN_PROVIDER</code> variable) located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32 in most cases\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>DANGEROUS! Don't enable unless you know what you are doing!</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>Some of the possible values are for example <code>wg</code>, <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>wg</code> will use the nameservers from the <code>wg0.conf</code> file. A value in the format <code>8.8.8.8</code> is to use a plain old nameserver. A value in the format <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>If you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice.</p> </li> <li> <p>This will start Privoxy on the default port 8118 when set to <code>true</code>. By default Privoxy is not exposed on the LAN, so if you need that, you'll have to add <code>VPN_EXPOSE_PORTS_ON_LAN=8118/tcp,8118/udp</code>.</p> </li> <li> <p>Enabling this will bring down the container if the connectivity tests fail at the end of the Wireguard init process or for an extended period during the container runtime.</p> </li> <li> <p>Enable Unbound by setting to <code>true</code> when VPN is not active.</p> </li> <li> <p>Possible values are <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>8.8.8.8</code> is to use a plain old nameserver. The value <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> </ol> clicompose <pre><code>docker run --rm \\\n    --hostname container-name.internal \\ #(18)\n    -e VPN_ENABLED=\"true\" \\ #(5)\n    -e VPN_CONF=\"wg0\" \\ #(8)\n    -e VPN_PROVIDER=\"pia\" \\ #(4)\n    -e VPN_LAN_NETWORK=\"192.168.1.0/24\" \\ #(1)\n    -e VPN_LAN_LEAK_ENABLED=\"false\" \\ #(10)\n    -e VPN_EXPOSE_PORTS_ON_LAN=\"\" \\ #(2)\n    -e VPN_AUTO_PORT_FORWARD=\"true\" \\ #(6)\n    -e VPN_AUTO_PORT_FORWARD_TO_PORTS=\"\" \\ #(15)\n    -e VPN_FIREWALL_TYPE=\"auto\" \\ #(17)\n    -e VPN_HEALTHCHECK_ENABLED=\"false\" \\ #(20)\n    -e VPN_NAMESERVERS=\"\" \\ #(16)\n    -e VPN_PIA_USER=\"\" \\ #(11)\n    -e VPN_PIA_PASS=\"\" \\ #(11)\n    -e VPN_PIA_PREFERRED_REGION=\"\" \\ #(7)\n    -e VPN_PIA_DIP_TOKEN=\"no\" \\ #(13)\n    -e VPN_PIA_PORT_FORWARD_PERSIST=\"false\" \\ #(14)\n    -e PRIVOXY_ENABLED=\"false\" \\ #(19)\n    -e UNBOUND_ENABLED=\"false\" \\ #(21)\n    -e UNBOUND_NAMESERVERS=\"\" \\ #(22)\n    --cap-add=NET_ADMIN \\\n    --sysctl=\"net.ipv4.conf.all.src_valid_mark=1\" \\ #(12)\n    --sysctl=\"net.ipv6.conf.all.disable_ipv6=1\" \\ #(3)\n    --device /dev/net/tun:/dev/net/tun \\ # OPTIONAL(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui. On MacOS set it to <code>192.168.65.0/24</code> (Verify with your settings [Resources &gt; Network &gt; Docker subnet]).</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>. Affiliate links: Proton VPN Proton Unlimited Private Internet Access</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> (for PIA this is done automatically, see <code>VPN_PROVIDER</code> variable) located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32 in most cases\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>DANGEROUS! Don't enable unless you know what you are doing!</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>Some of the possible values are for example <code>wg</code>, <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>wg</code> will use the nameservers from the <code>wg0.conf</code> file. A value in the format <code>8.8.8.8</code> is to use a plain old nameserver. A value in the format <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>If you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice.</p> </li> <li> <p>This will start Privoxy on the default port 8118 when set to <code>true</code>. By default Privoxy is not exposed on the LAN, so if you need that, you'll have to add <code>VPN_EXPOSE_PORTS_ON_LAN=8118/tcp,8118/udp</code>.</p> </li> <li> <p>Enabling this will bring down the container if the connectivity tests fail at the end of the Wireguard init process or for an extended period during the container runtime.</p> </li> <li> <p>Enable Unbound by setting to <code>true</code> when VPN is not active.</p> </li> <li> <p>Possible values are <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>8.8.8.8</code> is to use a plain old nameserver. The value <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> </ol> <pre><code>services:\n  app:\n    hostname: container-name.internal #(18)\n    environment:\n      - VPN_ENABLED=true #(5)\n      - VPN_CONF=wg0 #(8)\n      - VPN_PROVIDER=pia #(4)\n      - VPN_LAN_NETWORK=192.168.1.0/24 #(1)\n      - VPN_LAN_LEAK_ENABLED=false #(10)\n      - VPN_EXPOSE_PORTS_ON_LAN #(2)\n      - VPN_AUTO_PORT_FORWARD=true #(6)\n      - VPN_AUTO_PORT_FORWARD_TO_PORTS= #(15)\n      - VPN_FIREWALL_TYPE=auto #(17)\n      - VPN_HEALTHCHECK_ENABLED=false #(20)\n      - VPN_NAMESERVERS= #(16)\n      - VPN_PIA_USER #(11)\n      - VPN_PIA_PASS #(11)\n      - VPN_PIA_PREFERRED_REGION #(7)\n      - VPN_PIA_DIP_TOKEN=no #(13)\n      - VPN_PIA_PORT_FORWARD_PERSIST=false #(14)\n      - PRIVOXY_ENABLED=false #(19)\n      - UNBOUND_ENABLED=false #(21)\n      - UNBOUND_NAMESERVERS #(22)\n    cap_add:\n      - NET_ADMIN\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1 #(12)\n      - net.ipv6.conf.all.disable_ipv6=1 #(3)\n    devices:\n      - /dev/net/tun:/dev/net/tun # OPTIONAL(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui. On MacOS set it to <code>192.168.65.0/24</code> (Verify with your settings [Resources &gt; Network &gt; Docker subnet]).</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>. Affiliate links: Proton VPN Proton Unlimited Private Internet Access</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> (for PIA this is done automatically, see <code>VPN_PROVIDER</code> variable) located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32 in most cases\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>DANGEROUS! Don't enable unless you know what you are doing!</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>Some of the possible values are for example <code>wg</code>, <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>wg</code> will use the nameservers from the <code>wg0.conf</code> file. A value in the format <code>8.8.8.8</code> is to use a plain old nameserver. A value in the format <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>If you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice.</p> </li> <li> <p>This will start Privoxy on the default port 8118 when set to <code>true</code>. By default Privoxy is not exposed on the LAN, so if you need that, you'll have to add <code>VPN_EXPOSE_PORTS_ON_LAN=8118/tcp,8118/udp</code>.</p> </li> <li> <p>Enabling this will bring down the container if the connectivity tests fail at the end of the Wireguard init process or for an extended period during the container runtime.</p> </li> <li> <p>Enable Unbound by setting to <code>true</code> when VPN is not active.</p> </li> <li> <p>Possible values are <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>8.8.8.8</code> is to use a plain old nameserver. The value <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> </ol>"},{"location":"containers/bazarr/","title":"hotio/bazarr","text":"<p> GitHub ghcr.io</p>"},{"location":"containers/bazarr/#starting-the-container","title":"Starting the container","text":"clicompose <pre><code>docker run --rm \\\n    --name bazarr \\\n    -p 6767:6767 \\\n    -e PUID=1000 \\\n    -e PGID=1000 \\\n    -e UMASK=002 \\\n    -e TZ=\"Etc/UTC\" \\\n    -e WEBUI_PORTS=\"6767/tcp,6767/udp\" \\\n    -v /&lt;host_folder_config&gt;:/config \\\n    -v /&lt;host_folder_data&gt;:/data \\\n    ghcr.io/hotio/bazarr\n</code></pre> <pre><code>services:\n  bazarr:\n    container_name: bazarr\n    image: ghcr.io/hotio/bazarr\n    ports:\n      - \"6767:6767\"\n    environment:\n      - PUID=1000\n      - PGID=1000\n      - UMASK=002\n      - TZ=Etc/UTC\n      - WEBUI_PORTS=6767/tcp,6767/udp\n    volumes:\n      - /&lt;host_folder_config&gt;:/config\n      - /&lt;host_folder_data&gt;:/data\n</code></pre>"},{"location":"containers/bazarr/#tags","title":"Tags","text":"Tags Description Last Updated Age"},{"location":"containers/bazarr/#wireguard","title":"WireGuard","text":"<p>Info</p> <p>This image includes VPN support. The cli/compose examples below are environment variables and settings complementary to the app image examples, this means you'll have to add/merge the stuff below with the stuff above. In case you are still in need of a VPN, consider using my affiliate links for Proton VPN, Proton Unlimited or Private Internet Access.</p> <p> </p> genericprotonpia clicompose <pre><code>docker run --rm \\\n    --hostname container-name.internal \\ #(18)\n    -e VPN_ENABLED=\"true\" \\ #(5)\n    -e VPN_CONF=\"wg0\" \\ #(8)\n    -e VPN_PROVIDER=\"generic\" \\ #(4)\n    -e VPN_LAN_NETWORK=\"192.168.1.0/24\" \\ #(1)\n    -e VPN_LAN_LEAK_ENABLED=\"false\" \\ #(10)\n    -e VPN_EXPOSE_PORTS_ON_LAN=\"\" \\ #(2)\n    -e VPN_AUTO_PORT_FORWARD=\"false\" \\ #(6)\n    -e VPN_AUTO_PORT_FORWARD_TO_PORTS=\"\" \\ #(15)\n    -e VPN_FIREWALL_TYPE=\"auto\" \\ #(17)\n    -e VPN_HEALTHCHECK_ENABLED=\"false\" \\ #(20)\n    -e VPN_NAMESERVERS=\"\" \\ #(16)\n    -e PRIVOXY_ENABLED=\"false\" \\ #(19)\n    -e UNBOUND_ENABLED=\"false\" \\ #(21)\n    -e UNBOUND_NAMESERVERS=\"\" \\ #(22)\n    --cap-add=NET_ADMIN \\\n    --sysctl=\"net.ipv4.conf.all.src_valid_mark=1\" \\ #(12)\n    --sysctl=\"net.ipv6.conf.all.disable_ipv6=1\" \\ #(3)\n    --device /dev/net/tun:/dev/net/tun \\ # OPTIONAL(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui. On MacOS set it to <code>192.168.65.0/24</code> (Verify with your settings [Resources &gt; Network &gt; Docker subnet]).</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>. Affiliate links: Proton VPN Proton Unlimited Private Internet Access</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> (for PIA this is done automatically, see <code>VPN_PROVIDER</code> variable) located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32 in most cases\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>DANGEROUS! Don't enable unless you know what you are doing!</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>Some of the possible values are for example <code>wg</code>, <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>wg</code> will use the nameservers from the <code>wg0.conf</code> file. A value in the format <code>8.8.8.8</code> is to use a plain old nameserver. A value in the format <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>If you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice.</p> </li> <li> <p>This will start Privoxy on the default port 8118 when set to <code>true</code>. By default Privoxy is not exposed on the LAN, so if you need that, you'll have to add <code>VPN_EXPOSE_PORTS_ON_LAN=8118/tcp,8118/udp</code>.</p> </li> <li> <p>Enabling this will bring down the container if the connectivity tests fail at the end of the Wireguard init process or for an extended period during the container runtime.</p> </li> <li> <p>Enable Unbound by setting to <code>true</code> when VPN is not active.</p> </li> <li> <p>Possible values are <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>8.8.8.8</code> is to use a plain old nameserver. The value <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> </ol> <pre><code>services:\n  app:\n    hostname: container-name.internal #(18)\n    environment:\n      - VPN_ENABLED=true #(5)\n      - VPN_CONF=wg0 #(8)\n      - VPN_PROVIDER=generic #(4)\n      - VPN_LAN_NETWORK=192.168.1.0/24 #(1)\n      - VPN_LAN_LEAK_ENABLED=false #(10)\n      - VPN_EXPOSE_PORTS_ON_LAN #(2)\n      - VPN_AUTO_PORT_FORWARD=false #(6)\n      - VPN_AUTO_PORT_FORWARD_TO_PORTS= #(15)\n      - VPN_FIREWALL_TYPE=auto #(17)\n      - VPN_HEALTHCHECK_ENABLED=false #(20)\n      - VPN_NAMESERVERS= #(16)\n      - PRIVOXY_ENABLED=false #(19)\n      - UNBOUND_ENABLED=false #(21)\n      - UNBOUND_NAMESERVERS #(22)\n    cap_add:\n      - NET_ADMIN\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1 #(12)\n      - net.ipv6.conf.all.disable_ipv6=1 #(3)\n    devices:\n      - /dev/net/tun:/dev/net/tun # OPTIONAL(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui. On MacOS set it to <code>192.168.65.0/24</code> (Verify with your settings [Resources &gt; Network &gt; Docker subnet]).</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>. Affiliate links: Proton VPN Proton Unlimited Private Internet Access</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> (for PIA this is done automatically, see <code>VPN_PROVIDER</code> variable) located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32 in most cases\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>DANGEROUS! Don't enable unless you know what you are doing!</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>Some of the possible values are for example <code>wg</code>, <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>wg</code> will use the nameservers from the <code>wg0.conf</code> file. A value in the format <code>8.8.8.8</code> is to use a plain old nameserver. A value in the format <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>If you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice.</p> </li> <li> <p>This will start Privoxy on the default port 8118 when set to <code>true</code>. By default Privoxy is not exposed on the LAN, so if you need that, you'll have to add <code>VPN_EXPOSE_PORTS_ON_LAN=8118/tcp,8118/udp</code>.</p> </li> <li> <p>Enabling this will bring down the container if the connectivity tests fail at the end of the Wireguard init process or for an extended period during the container runtime.</p> </li> <li> <p>Enable Unbound by setting to <code>true</code> when VPN is not active.</p> </li> <li> <p>Possible values are <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>8.8.8.8</code> is to use a plain old nameserver. The value <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> </ol> clicompose <pre><code>docker run --rm \\\n    --hostname container-name.internal \\ #(18)\n    -e VPN_ENABLED=\"true\" \\ #(5)\n    -e VPN_CONF=\"wg0\" \\ #(8)\n    -e VPN_PROVIDER=\"proton\" \\ #(4)\n    -e VPN_LAN_NETWORK=\"192.168.1.0/24\" \\ #(1)\n    -e VPN_LAN_LEAK_ENABLED=\"false\" \\ #(10)\n    -e VPN_EXPOSE_PORTS_ON_LAN=\"\" \\ #(2)\n    -e VPN_AUTO_PORT_FORWARD=\"true\" \\ #(6)\n    -e VPN_AUTO_PORT_FORWARD_TO_PORTS=\"\" \\ #(15)\n    -e VPN_FIREWALL_TYPE=\"auto\" \\ #(17)\n    -e VPN_HEALTHCHECK_ENABLED=\"false\" \\ #(20)\n    -e VPN_NAMESERVERS=\"\" \\ #(16)\n    -e PRIVOXY_ENABLED=\"false\" \\ #(19)\n    -e UNBOUND_ENABLED=\"false\" \\ #(21)\n    -e UNBOUND_NAMESERVERS=\"\" \\ #(22)\n    --cap-add=NET_ADMIN \\\n    --sysctl=\"net.ipv4.conf.all.src_valid_mark=1\" \\ #(12)\n    --sysctl=\"net.ipv6.conf.all.disable_ipv6=1\" \\ #(3)\n    --device /dev/net/tun:/dev/net/tun \\ # OPTIONAL(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui. On MacOS set it to <code>192.168.65.0/24</code> (Verify with your settings [Resources &gt; Network &gt; Docker subnet]).</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>. Affiliate links: Proton VPN Proton Unlimited Private Internet Access</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> (for PIA this is done automatically, see <code>VPN_PROVIDER</code> variable) located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32 in most cases\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>DANGEROUS! Don't enable unless you know what you are doing!</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>Some of the possible values are for example <code>wg</code>, <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>wg</code> will use the nameservers from the <code>wg0.conf</code> file. A value in the format <code>8.8.8.8</code> is to use a plain old nameserver. A value in the format <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>If you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice.</p> </li> <li> <p>This will start Privoxy on the default port 8118 when set to <code>true</code>. By default Privoxy is not exposed on the LAN, so if you need that, you'll have to add <code>VPN_EXPOSE_PORTS_ON_LAN=8118/tcp,8118/udp</code>.</p> </li> <li> <p>Enabling this will bring down the container if the connectivity tests fail at the end of the Wireguard init process or for an extended period during the container runtime.</p> </li> <li> <p>Enable Unbound by setting to <code>true</code> when VPN is not active.</p> </li> <li> <p>Possible values are <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>8.8.8.8</code> is to use a plain old nameserver. The value <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> </ol> <pre><code>services:\n  app:\n    hostname: container-name.internal #(18)\n    environment:\n      - VPN_ENABLED=true #(5)\n      - VPN_CONF=wg0 #(8)\n      - VPN_PROVIDER=proton #(4)\n      - VPN_LAN_NETWORK=192.168.1.0/24 #(1)\n      - VPN_LAN_LEAK_ENABLED=false #(10)\n      - VPN_EXPOSE_PORTS_ON_LAN #(2)\n      - VPN_AUTO_PORT_FORWARD=true #(6)\n      - VPN_AUTO_PORT_FORWARD_TO_PORTS= #(15)\n      - VPN_FIREWALL_TYPE=auto #(17)\n      - VPN_HEALTHCHECK_ENABLED=false #(20)\n      - VPN_NAMESERVERS= #(16)\n      - PRIVOXY_ENABLED=false #(19)\n      - UNBOUND_ENABLED=false #(21)\n      - UNBOUND_NAMESERVERS #(22)\n    cap_add:\n      - NET_ADMIN\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1 #(12)\n      - net.ipv6.conf.all.disable_ipv6=1 #(3)\n    devices:\n      - /dev/net/tun:/dev/net/tun # OPTIONAL(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui. On MacOS set it to <code>192.168.65.0/24</code> (Verify with your settings [Resources &gt; Network &gt; Docker subnet]).</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>. Affiliate links: Proton VPN Proton Unlimited Private Internet Access</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> (for PIA this is done automatically, see <code>VPN_PROVIDER</code> variable) located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32 in most cases\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>DANGEROUS! Don't enable unless you know what you are doing!</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>Some of the possible values are for example <code>wg</code>, <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>wg</code> will use the nameservers from the <code>wg0.conf</code> file. A value in the format <code>8.8.8.8</code> is to use a plain old nameserver. A value in the format <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>If you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice.</p> </li> <li> <p>This will start Privoxy on the default port 8118 when set to <code>true</code>. By default Privoxy is not exposed on the LAN, so if you need that, you'll have to add <code>VPN_EXPOSE_PORTS_ON_LAN=8118/tcp,8118/udp</code>.</p> </li> <li> <p>Enabling this will bring down the container if the connectivity tests fail at the end of the Wireguard init process or for an extended period during the container runtime.</p> </li> <li> <p>Enable Unbound by setting to <code>true</code> when VPN is not active.</p> </li> <li> <p>Possible values are <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>8.8.8.8</code> is to use a plain old nameserver. The value <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> </ol> clicompose <pre><code>docker run --rm \\\n    --hostname container-name.internal \\ #(18)\n    -e VPN_ENABLED=\"true\" \\ #(5)\n    -e VPN_CONF=\"wg0\" \\ #(8)\n    -e VPN_PROVIDER=\"pia\" \\ #(4)\n    -e VPN_LAN_NETWORK=\"192.168.1.0/24\" \\ #(1)\n    -e VPN_LAN_LEAK_ENABLED=\"false\" \\ #(10)\n    -e VPN_EXPOSE_PORTS_ON_LAN=\"\" \\ #(2)\n    -e VPN_AUTO_PORT_FORWARD=\"true\" \\ #(6)\n    -e VPN_AUTO_PORT_FORWARD_TO_PORTS=\"\" \\ #(15)\n    -e VPN_FIREWALL_TYPE=\"auto\" \\ #(17)\n    -e VPN_HEALTHCHECK_ENABLED=\"false\" \\ #(20)\n    -e VPN_NAMESERVERS=\"\" \\ #(16)\n    -e VPN_PIA_USER=\"\" \\ #(11)\n    -e VPN_PIA_PASS=\"\" \\ #(11)\n    -e VPN_PIA_PREFERRED_REGION=\"\" \\ #(7)\n    -e VPN_PIA_DIP_TOKEN=\"no\" \\ #(13)\n    -e VPN_PIA_PORT_FORWARD_PERSIST=\"false\" \\ #(14)\n    -e PRIVOXY_ENABLED=\"false\" \\ #(19)\n    -e UNBOUND_ENABLED=\"false\" \\ #(21)\n    -e UNBOUND_NAMESERVERS=\"\" \\ #(22)\n    --cap-add=NET_ADMIN \\\n    --sysctl=\"net.ipv4.conf.all.src_valid_mark=1\" \\ #(12)\n    --sysctl=\"net.ipv6.conf.all.disable_ipv6=1\" \\ #(3)\n    --device /dev/net/tun:/dev/net/tun \\ # OPTIONAL(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui. On MacOS set it to <code>192.168.65.0/24</code> (Verify with your settings [Resources &gt; Network &gt; Docker subnet]).</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>. Affiliate links: Proton VPN Proton Unlimited Private Internet Access</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> (for PIA this is done automatically, see <code>VPN_PROVIDER</code> variable) located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32 in most cases\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>DANGEROUS! Don't enable unless you know what you are doing!</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>Some of the possible values are for example <code>wg</code>, <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>wg</code> will use the nameservers from the <code>wg0.conf</code> file. A value in the format <code>8.8.8.8</code> is to use a plain old nameserver. A value in the format <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>If you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice.</p> </li> <li> <p>This will start Privoxy on the default port 8118 when set to <code>true</code>. By default Privoxy is not exposed on the LAN, so if you need that, you'll have to add <code>VPN_EXPOSE_PORTS_ON_LAN=8118/tcp,8118/udp</code>.</p> </li> <li> <p>Enabling this will bring down the container if the connectivity tests fail at the end of the Wireguard init process or for an extended period during the container runtime.</p> </li> <li> <p>Enable Unbound by setting to <code>true</code> when VPN is not active.</p> </li> <li> <p>Possible values are <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>8.8.8.8</code> is to use a plain old nameserver. The value <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> </ol> <pre><code>services:\n  app:\n    hostname: container-name.internal #(18)\n    environment:\n      - VPN_ENABLED=true #(5)\n      - VPN_CONF=wg0 #(8)\n      - VPN_PROVIDER=pia #(4)\n      - VPN_LAN_NETWORK=192.168.1.0/24 #(1)\n      - VPN_LAN_LEAK_ENABLED=false #(10)\n      - VPN_EXPOSE_PORTS_ON_LAN #(2)\n      - VPN_AUTO_PORT_FORWARD=true #(6)\n      - VPN_AUTO_PORT_FORWARD_TO_PORTS= #(15)\n      - VPN_FIREWALL_TYPE=auto #(17)\n      - VPN_HEALTHCHECK_ENABLED=false #(20)\n      - VPN_NAMESERVERS= #(16)\n      - VPN_PIA_USER #(11)\n      - VPN_PIA_PASS #(11)\n      - VPN_PIA_PREFERRED_REGION #(7)\n      - VPN_PIA_DIP_TOKEN=no #(13)\n      - VPN_PIA_PORT_FORWARD_PERSIST=false #(14)\n      - PRIVOXY_ENABLED=false #(19)\n      - UNBOUND_ENABLED=false #(21)\n      - UNBOUND_NAMESERVERS #(22)\n    cap_add:\n      - NET_ADMIN\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1 #(12)\n      - net.ipv6.conf.all.disable_ipv6=1 #(3)\n    devices:\n      - /dev/net/tun:/dev/net/tun # OPTIONAL(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui. On MacOS set it to <code>192.168.65.0/24</code> (Verify with your settings [Resources &gt; Network &gt; Docker subnet]).</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>. Affiliate links: Proton VPN Proton Unlimited Private Internet Access</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> (for PIA this is done automatically, see <code>VPN_PROVIDER</code> variable) located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32 in most cases\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>DANGEROUS! Don't enable unless you know what you are doing!</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>Some of the possible values are for example <code>wg</code>, <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>wg</code> will use the nameservers from the <code>wg0.conf</code> file. A value in the format <code>8.8.8.8</code> is to use a plain old nameserver. A value in the format <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>If you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice.</p> </li> <li> <p>This will start Privoxy on the default port 8118 when set to <code>true</code>. By default Privoxy is not exposed on the LAN, so if you need that, you'll have to add <code>VPN_EXPOSE_PORTS_ON_LAN=8118/tcp,8118/udp</code>.</p> </li> <li> <p>Enabling this will bring down the container if the connectivity tests fail at the end of the Wireguard init process or for an extended period during the container runtime.</p> </li> <li> <p>Enable Unbound by setting to <code>true</code> when VPN is not active.</p> </li> <li> <p>Possible values are <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>8.8.8.8</code> is to use a plain old nameserver. The value <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> </ol>"},{"location":"containers/caddy/","title":"hotio/caddy","text":"<p> GitHub ghcr.io</p> <p>What is this?</p> <p>A docker image with Caddy 2 (included modules: caddy-dns/cloudflare, mholt/caddy-ratelimit). The default config only allows access from private ip ranges.</p>"},{"location":"containers/caddy/#starting-the-container","title":"Starting the container","text":"clicompose <pre><code>docker run --rm \\\n    --name caddy \\\n    -p 80:8080 \\\n    -p 443:8443 \\\n    -e PUID=1000 \\\n    -e PGID=1000 \\\n    -e UMASK=002 \\\n    -e TZ=\"Etc/UTC\" \\\n    -e CUSTOM_BUILD=\"\" \\\n    -v /&lt;host_folder_config&gt;:/config \\\n    ghcr.io/hotio/caddy\n</code></pre> <pre><code>services:\n  caddy:\n    container_name: caddy\n    image: ghcr.io/hotio/caddy\n    ports:\n      - \"80:8080\"\n      - \"443:8443\"\n    environment:\n      - PUID=1000\n      - PGID=1000\n      - UMASK=002\n      - TZ=Etc/UTC\n      - CUSTOM_BUILD\n    volumes:\n      - /&lt;host_folder_config&gt;:/config\n</code></pre>"},{"location":"containers/caddy/#tags","title":"Tags","text":"Tags Description Last Updated Age"},{"location":"containers/caddy/#custom-build","title":"Custom build","text":"<p>If you set the environment variable <code>CUSTOM_BUILD</code> to a file location like for example <code>/config/caddy_linux_amd64_custom</code>, an attempt is made to start Caddy with that binary. The custom build can be obtained from the Caddy download page. This is particularly useful if you need extra modules.</p>"},{"location":"containers/caddy/#wireguard","title":"WireGuard","text":"<p>Info</p> <p>This image includes VPN support. The cli/compose examples below are environment variables and settings complementary to the app image examples, this means you'll have to add/merge the stuff below with the stuff above. In case you are still in need of a VPN, consider using my affiliate links for Proton VPN, Proton Unlimited or Private Internet Access.</p> <p> </p> genericprotonpia clicompose <pre><code>docker run --rm \\\n    --hostname container-name.internal \\ #(18)\n    -e VPN_ENABLED=\"true\" \\ #(5)\n    -e VPN_CONF=\"wg0\" \\ #(8)\n    -e VPN_PROVIDER=\"generic\" \\ #(4)\n    -e VPN_LAN_NETWORK=\"192.168.1.0/24\" \\ #(1)\n    -e VPN_LAN_LEAK_ENABLED=\"false\" \\ #(10)\n    -e VPN_EXPOSE_PORTS_ON_LAN=\"\" \\ #(2)\n    -e VPN_AUTO_PORT_FORWARD=\"false\" \\ #(6)\n    -e VPN_AUTO_PORT_FORWARD_TO_PORTS=\"\" \\ #(15)\n    -e VPN_FIREWALL_TYPE=\"auto\" \\ #(17)\n    -e VPN_HEALTHCHECK_ENABLED=\"false\" \\ #(20)\n    -e VPN_NAMESERVERS=\"\" \\ #(16)\n    -e PRIVOXY_ENABLED=\"false\" \\ #(19)\n    -e UNBOUND_ENABLED=\"false\" \\ #(21)\n    -e UNBOUND_NAMESERVERS=\"\" \\ #(22)\n    --cap-add=NET_ADMIN \\\n    --sysctl=\"net.ipv4.conf.all.src_valid_mark=1\" \\ #(12)\n    --sysctl=\"net.ipv6.conf.all.disable_ipv6=1\" \\ #(3)\n    --device /dev/net/tun:/dev/net/tun \\ # OPTIONAL(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui. On MacOS set it to <code>192.168.65.0/24</code> (Verify with your settings [Resources &gt; Network &gt; Docker subnet]).</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>. Affiliate links: Proton VPN Proton Unlimited Private Internet Access</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> (for PIA this is done automatically, see <code>VPN_PROVIDER</code> variable) located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32 in most cases\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>DANGEROUS! Don't enable unless you know what you are doing!</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>Some of the possible values are for example <code>wg</code>, <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>wg</code> will use the nameservers from the <code>wg0.conf</code> file. A value in the format <code>8.8.8.8</code> is to use a plain old nameserver. A value in the format <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>If you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice.</p> </li> <li> <p>This will start Privoxy on the default port 8118 when set to <code>true</code>. By default Privoxy is not exposed on the LAN, so if you need that, you'll have to add <code>VPN_EXPOSE_PORTS_ON_LAN=8118/tcp,8118/udp</code>.</p> </li> <li> <p>Enabling this will bring down the container if the connectivity tests fail at the end of the Wireguard init process or for an extended period during the container runtime.</p> </li> <li> <p>Enable Unbound by setting to <code>true</code> when VPN is not active.</p> </li> <li> <p>Possible values are <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>8.8.8.8</code> is to use a plain old nameserver. The value <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> </ol> <pre><code>services:\n  app:\n    hostname: container-name.internal #(18)\n    environment:\n      - VPN_ENABLED=true #(5)\n      - VPN_CONF=wg0 #(8)\n      - VPN_PROVIDER=generic #(4)\n      - VPN_LAN_NETWORK=192.168.1.0/24 #(1)\n      - VPN_LAN_LEAK_ENABLED=false #(10)\n      - VPN_EXPOSE_PORTS_ON_LAN #(2)\n      - VPN_AUTO_PORT_FORWARD=false #(6)\n      - VPN_AUTO_PORT_FORWARD_TO_PORTS= #(15)\n      - VPN_FIREWALL_TYPE=auto #(17)\n      - VPN_HEALTHCHECK_ENABLED=false #(20)\n      - VPN_NAMESERVERS= #(16)\n      - PRIVOXY_ENABLED=false #(19)\n      - UNBOUND_ENABLED=false #(21)\n      - UNBOUND_NAMESERVERS #(22)\n    cap_add:\n      - NET_ADMIN\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1 #(12)\n      - net.ipv6.conf.all.disable_ipv6=1 #(3)\n    devices:\n      - /dev/net/tun:/dev/net/tun # OPTIONAL(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui. On MacOS set it to <code>192.168.65.0/24</code> (Verify with your settings [Resources &gt; Network &gt; Docker subnet]).</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>. Affiliate links: Proton VPN Proton Unlimited Private Internet Access</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> (for PIA this is done automatically, see <code>VPN_PROVIDER</code> variable) located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32 in most cases\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>DANGEROUS! Don't enable unless you know what you are doing!</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>Some of the possible values are for example <code>wg</code>, <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>wg</code> will use the nameservers from the <code>wg0.conf</code> file. A value in the format <code>8.8.8.8</code> is to use a plain old nameserver. A value in the format <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>If you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice.</p> </li> <li> <p>This will start Privoxy on the default port 8118 when set to <code>true</code>. By default Privoxy is not exposed on the LAN, so if you need that, you'll have to add <code>VPN_EXPOSE_PORTS_ON_LAN=8118/tcp,8118/udp</code>.</p> </li> <li> <p>Enabling this will bring down the container if the connectivity tests fail at the end of the Wireguard init process or for an extended period during the container runtime.</p> </li> <li> <p>Enable Unbound by setting to <code>true</code> when VPN is not active.</p> </li> <li> <p>Possible values are <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>8.8.8.8</code> is to use a plain old nameserver. The value <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> </ol> clicompose <pre><code>docker run --rm \\\n    --hostname container-name.internal \\ #(18)\n    -e VPN_ENABLED=\"true\" \\ #(5)\n    -e VPN_CONF=\"wg0\" \\ #(8)\n    -e VPN_PROVIDER=\"proton\" \\ #(4)\n    -e VPN_LAN_NETWORK=\"192.168.1.0/24\" \\ #(1)\n    -e VPN_LAN_LEAK_ENABLED=\"false\" \\ #(10)\n    -e VPN_EXPOSE_PORTS_ON_LAN=\"\" \\ #(2)\n    -e VPN_AUTO_PORT_FORWARD=\"true\" \\ #(6)\n    -e VPN_AUTO_PORT_FORWARD_TO_PORTS=\"\" \\ #(15)\n    -e VPN_FIREWALL_TYPE=\"auto\" \\ #(17)\n    -e VPN_HEALTHCHECK_ENABLED=\"false\" \\ #(20)\n    -e VPN_NAMESERVERS=\"\" \\ #(16)\n    -e PRIVOXY_ENABLED=\"false\" \\ #(19)\n    -e UNBOUND_ENABLED=\"false\" \\ #(21)\n    -e UNBOUND_NAMESERVERS=\"\" \\ #(22)\n    --cap-add=NET_ADMIN \\\n    --sysctl=\"net.ipv4.conf.all.src_valid_mark=1\" \\ #(12)\n    --sysctl=\"net.ipv6.conf.all.disable_ipv6=1\" \\ #(3)\n    --device /dev/net/tun:/dev/net/tun \\ # OPTIONAL(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui. On MacOS set it to <code>192.168.65.0/24</code> (Verify with your settings [Resources &gt; Network &gt; Docker subnet]).</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>. Affiliate links: Proton VPN Proton Unlimited Private Internet Access</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> (for PIA this is done automatically, see <code>VPN_PROVIDER</code> variable) located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32 in most cases\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>DANGEROUS! Don't enable unless you know what you are doing!</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>Some of the possible values are for example <code>wg</code>, <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>wg</code> will use the nameservers from the <code>wg0.conf</code> file. A value in the format <code>8.8.8.8</code> is to use a plain old nameserver. A value in the format <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>If you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice.</p> </li> <li> <p>This will start Privoxy on the default port 8118 when set to <code>true</code>. By default Privoxy is not exposed on the LAN, so if you need that, you'll have to add <code>VPN_EXPOSE_PORTS_ON_LAN=8118/tcp,8118/udp</code>.</p> </li> <li> <p>Enabling this will bring down the container if the connectivity tests fail at the end of the Wireguard init process or for an extended period during the container runtime.</p> </li> <li> <p>Enable Unbound by setting to <code>true</code> when VPN is not active.</p> </li> <li> <p>Possible values are <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>8.8.8.8</code> is to use a plain old nameserver. The value <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> </ol> <pre><code>services:\n  app:\n    hostname: container-name.internal #(18)\n    environment:\n      - VPN_ENABLED=true #(5)\n      - VPN_CONF=wg0 #(8)\n      - VPN_PROVIDER=proton #(4)\n      - VPN_LAN_NETWORK=192.168.1.0/24 #(1)\n      - VPN_LAN_LEAK_ENABLED=false #(10)\n      - VPN_EXPOSE_PORTS_ON_LAN #(2)\n      - VPN_AUTO_PORT_FORWARD=true #(6)\n      - VPN_AUTO_PORT_FORWARD_TO_PORTS= #(15)\n      - VPN_FIREWALL_TYPE=auto #(17)\n      - VPN_HEALTHCHECK_ENABLED=false #(20)\n      - VPN_NAMESERVERS= #(16)\n      - PRIVOXY_ENABLED=false #(19)\n      - UNBOUND_ENABLED=false #(21)\n      - UNBOUND_NAMESERVERS #(22)\n    cap_add:\n      - NET_ADMIN\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1 #(12)\n      - net.ipv6.conf.all.disable_ipv6=1 #(3)\n    devices:\n      - /dev/net/tun:/dev/net/tun # OPTIONAL(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui. On MacOS set it to <code>192.168.65.0/24</code> (Verify with your settings [Resources &gt; Network &gt; Docker subnet]).</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>. Affiliate links: Proton VPN Proton Unlimited Private Internet Access</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> (for PIA this is done automatically, see <code>VPN_PROVIDER</code> variable) located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32 in most cases\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>DANGEROUS! Don't enable unless you know what you are doing!</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>Some of the possible values are for example <code>wg</code>, <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>wg</code> will use the nameservers from the <code>wg0.conf</code> file. A value in the format <code>8.8.8.8</code> is to use a plain old nameserver. A value in the format <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>If you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice.</p> </li> <li> <p>This will start Privoxy on the default port 8118 when set to <code>true</code>. By default Privoxy is not exposed on the LAN, so if you need that, you'll have to add <code>VPN_EXPOSE_PORTS_ON_LAN=8118/tcp,8118/udp</code>.</p> </li> <li> <p>Enabling this will bring down the container if the connectivity tests fail at the end of the Wireguard init process or for an extended period during the container runtime.</p> </li> <li> <p>Enable Unbound by setting to <code>true</code> when VPN is not active.</p> </li> <li> <p>Possible values are <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>8.8.8.8</code> is to use a plain old nameserver. The value <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> </ol> clicompose <pre><code>docker run --rm \\\n    --hostname container-name.internal \\ #(18)\n    -e VPN_ENABLED=\"true\" \\ #(5)\n    -e VPN_CONF=\"wg0\" \\ #(8)\n    -e VPN_PROVIDER=\"pia\" \\ #(4)\n    -e VPN_LAN_NETWORK=\"192.168.1.0/24\" \\ #(1)\n    -e VPN_LAN_LEAK_ENABLED=\"false\" \\ #(10)\n    -e VPN_EXPOSE_PORTS_ON_LAN=\"\" \\ #(2)\n    -e VPN_AUTO_PORT_FORWARD=\"true\" \\ #(6)\n    -e VPN_AUTO_PORT_FORWARD_TO_PORTS=\"\" \\ #(15)\n    -e VPN_FIREWALL_TYPE=\"auto\" \\ #(17)\n    -e VPN_HEALTHCHECK_ENABLED=\"false\" \\ #(20)\n    -e VPN_NAMESERVERS=\"\" \\ #(16)\n    -e VPN_PIA_USER=\"\" \\ #(11)\n    -e VPN_PIA_PASS=\"\" \\ #(11)\n    -e VPN_PIA_PREFERRED_REGION=\"\" \\ #(7)\n    -e VPN_PIA_DIP_TOKEN=\"no\" \\ #(13)\n    -e VPN_PIA_PORT_FORWARD_PERSIST=\"false\" \\ #(14)\n    -e PRIVOXY_ENABLED=\"false\" \\ #(19)\n    -e UNBOUND_ENABLED=\"false\" \\ #(21)\n    -e UNBOUND_NAMESERVERS=\"\" \\ #(22)\n    --cap-add=NET_ADMIN \\\n    --sysctl=\"net.ipv4.conf.all.src_valid_mark=1\" \\ #(12)\n    --sysctl=\"net.ipv6.conf.all.disable_ipv6=1\" \\ #(3)\n    --device /dev/net/tun:/dev/net/tun \\ # OPTIONAL(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui. On MacOS set it to <code>192.168.65.0/24</code> (Verify with your settings [Resources &gt; Network &gt; Docker subnet]).</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>. Affiliate links: Proton VPN Proton Unlimited Private Internet Access</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> (for PIA this is done automatically, see <code>VPN_PROVIDER</code> variable) located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32 in most cases\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>DANGEROUS! Don't enable unless you know what you are doing!</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>Some of the possible values are for example <code>wg</code>, <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>wg</code> will use the nameservers from the <code>wg0.conf</code> file. A value in the format <code>8.8.8.8</code> is to use a plain old nameserver. A value in the format <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>If you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice.</p> </li> <li> <p>This will start Privoxy on the default port 8118 when set to <code>true</code>. By default Privoxy is not exposed on the LAN, so if you need that, you'll have to add <code>VPN_EXPOSE_PORTS_ON_LAN=8118/tcp,8118/udp</code>.</p> </li> <li> <p>Enabling this will bring down the container if the connectivity tests fail at the end of the Wireguard init process or for an extended period during the container runtime.</p> </li> <li> <p>Enable Unbound by setting to <code>true</code> when VPN is not active.</p> </li> <li> <p>Possible values are <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>8.8.8.8</code> is to use a plain old nameserver. The value <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> </ol> <pre><code>services:\n  app:\n    hostname: container-name.internal #(18)\n    environment:\n      - VPN_ENABLED=true #(5)\n      - VPN_CONF=wg0 #(8)\n      - VPN_PROVIDER=pia #(4)\n      - VPN_LAN_NETWORK=192.168.1.0/24 #(1)\n      - VPN_LAN_LEAK_ENABLED=false #(10)\n      - VPN_EXPOSE_PORTS_ON_LAN #(2)\n      - VPN_AUTO_PORT_FORWARD=true #(6)\n      - VPN_AUTO_PORT_FORWARD_TO_PORTS= #(15)\n      - VPN_FIREWALL_TYPE=auto #(17)\n      - VPN_HEALTHCHECK_ENABLED=false #(20)\n      - VPN_NAMESERVERS= #(16)\n      - VPN_PIA_USER #(11)\n      - VPN_PIA_PASS #(11)\n      - VPN_PIA_PREFERRED_REGION #(7)\n      - VPN_PIA_DIP_TOKEN=no #(13)\n      - VPN_PIA_PORT_FORWARD_PERSIST=false #(14)\n      - PRIVOXY_ENABLED=false #(19)\n      - UNBOUND_ENABLED=false #(21)\n      - UNBOUND_NAMESERVERS #(22)\n    cap_add:\n      - NET_ADMIN\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1 #(12)\n      - net.ipv6.conf.all.disable_ipv6=1 #(3)\n    devices:\n      - /dev/net/tun:/dev/net/tun # OPTIONAL(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui. On MacOS set it to <code>192.168.65.0/24</code> (Verify with your settings [Resources &gt; Network &gt; Docker subnet]).</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>. Affiliate links: Proton VPN Proton Unlimited Private Internet Access</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> (for PIA this is done automatically, see <code>VPN_PROVIDER</code> variable) located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32 in most cases\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>DANGEROUS! Don't enable unless you know what you are doing!</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>Some of the possible values are for example <code>wg</code>, <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>wg</code> will use the nameservers from the <code>wg0.conf</code> file. A value in the format <code>8.8.8.8</code> is to use a plain old nameserver. A value in the format <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>If you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice.</p> </li> <li> <p>This will start Privoxy on the default port 8118 when set to <code>true</code>. By default Privoxy is not exposed on the LAN, so if you need that, you'll have to add <code>VPN_EXPOSE_PORTS_ON_LAN=8118/tcp,8118/udp</code>.</p> </li> <li> <p>Enabling this will bring down the container if the connectivity tests fail at the end of the Wireguard init process or for an extended period during the container runtime.</p> </li> <li> <p>Enable Unbound by setting to <code>true</code> when VPN is not active.</p> </li> <li> <p>Possible values are <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>8.8.8.8</code> is to use a plain old nameserver. The value <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> </ol>"},{"location":"containers/cloudflareddns/","title":"hotio/cloudflareddns","text":"<p> GitHub ghcr.io</p>"},{"location":"containers/cloudflareddns/#starting-the-container","title":"Starting the container","text":"clicompose <pre><code>docker run --rm \\\n    --name cloudflareddns \\\n    -e PUID=1000 \\\n    -e PGID=1000 \\\n    -e UMASK=002 \\\n    -e TZ=\"Etc/UTC\" \\\n    -e INTERVAL=300 \\\n    -e DETECTION_MODE=\"dig-whoami.cloudflare\" \\\n    -e LOG_LEVEL=3 \\\n    -e CF_USER=\"your.cf.email@example.com\" \\\n    -e CF_APIKEY=\"your.global.apikey\" \\\n    -e CF_APITOKEN=\"\" \\\n    -e CF_APITOKEN_ZONE=\"\" \\\n    -e CF_HOSTS=\"test.example.com;test.foobar.com;test2.foobar.com\" \\\n    -e CF_ZONES=\"example.com;foobar.com;foobar.com\" \\\n    -e CF_RECORDTYPES=\"A;A;AAAA\" \\\n    -v /&lt;host_folder_config&gt;:/config \\\n    ghcr.io/hotio/cloudflareddns\n</code></pre> <pre><code>services:\n  cloudflareddns:\n    container_name: cloudflareddns\n    image: ghcr.io/hotio/cloudflareddns\n    environment:\n      - PUID=1000\n      - PGID=1000\n      - UMASK=002\n      - TZ=Etc/UTC\n      - INTERVAL=300\n      - DETECTION_MODE=dig-whoami.cloudflare\n      - LOG_LEVEL=3\n      - CF_USER=your.cf.email@example.com\n      - CF_APIKEY=your.global.apikey\n      - CF_APITOKEN\n      - CF_APITOKEN_ZONE\n      - CF_HOSTS=test.example.com;test.foobar.com;test2.foobar.com\n      - CF_ZONES=example.com;foobar.com;foobar.com\n      - CF_RECORDTYPES=A;A;AAAA\n    volumes:\n      - /&lt;host_folder_config&gt;:/config\n</code></pre> <p>Possible values for <code>DETECTION_MODE</code> are <code>dig-google.com</code>, <code>dig-opendns.com</code>, <code>dig-whoami.cloudflare</code>, <code>curl-icanhazip.com</code>, <code>curl-wtfismyip.com</code>, <code>curl-showmyip.ca</code>, <code>curl-da.gd</code>, <code>curl-seeip.org</code>, <code>curl-ifconfig.co</code> and <code>curl-ipw.cn</code>. If you want to get the local ip from a network interface, use something like <code>local:eth0</code> as <code>DETECTION_MODE</code>.</p> <p>Notice that we give 3 values each time for <code>CF_HOSTS</code>, <code>CF_ZONES</code> and <code>CF_RECORDTYPES</code>. In our example, the domain <code>test.foobar.com</code> belonging to the zone <code>foobar.com</code> will have its A record updated with an ipv4 ip. If you use <code>CF_APITOKEN</code>, you can leave <code>CF_USER</code> and <code>CF_APIKEY</code> empty.</p> <p>Important</p> <p>All the domain names in <code>CF_HOSTS</code> should have properly configured DNS records on Cloudflare, they will not be created.</p>"},{"location":"containers/cloudflareddns/#tags","title":"Tags","text":"Tags Description Last Updated Age"},{"location":"containers/cloudflareddns/#zone-id","title":"Zone ID","text":"<p>Instead of the <code>zone_name</code>, you can also fill in a <code>zone_id</code> in <code>CF_ZONES</code>. When using a <code>zone_id</code>, you can use a scoped token (<code>CF_APITOKEN</code>) that only needs the <code>Zone - DNS - Edit</code> permissions. This improves security. The configuration could look like the example below.</p> <pre><code>-e CF_APITOKEN=\"azkqvJ86wEScojvSJC8DyY67TwqNwZCtomEVrHwt\"\n-e CF_HOSTS=\"example.com;test.foobar.com\"\n-e CF_ZONES=\"zbpsi9ceikrdnnym27s2xnp6s5dvj6ep;dccbe6grakumohwwd4amh4o46yupepn8\"\n-e CF_RECORDTYPES=\"A;A\"\n</code></pre>"},{"location":"containers/cloudflareddns/#seperate-api-tokens","title":"Seperate API Tokens","text":"<p>If you do not prefer to use a <code>zone_id</code>, but prefer some more security, you can use 2 seperate tokens.</p> <p><code>CF_APITOKEN</code> configured with:</p> <p>Permissions <code>Zone - DNS - Edit</code> Zone Resources <code>Include - Specific zone - example.com</code> <code>Include - Specific zone - foobar.com</code></p> <p><code>CF_APITOKEN_ZONE</code> configured with:</p> <p>Permissions <code>Zone - Zone - Read</code> Zone Resources <code>Include - All zones</code></p> <p>Leaving <code>CF_APITOKEN_ZONE</code> blank would mean that only <code>CF_APITOKEN</code> will be used and thus that token should have all required permissions. Which usually means that the token could edit all zones or not be able to fetch the <code>zone_id</code> from the <code>zone_name</code>.</p>"},{"location":"containers/cloudflareddns/#configuration-combination-examples","title":"Configuration combination examples","text":"<p>Below are some example configuration combinations, ordered from most secure to least secure.</p> <ul> <li>We use a <code>zone_id</code> so that our token only needs the permissions <code>Zone - DNS - Edit</code>.</li> </ul> <pre><code>-e CF_APITOKEN=\"azkqvJ86wEScojvSJC8DyY67TwqNwZCtomEVrHwt\"\n-e CF_HOSTS=\"vpn.example.com;test.foobar.com\"\n-e CF_ZONES=\"zbpsi9ceikrdnnym27s2xnp6s5dvj6ep;axozor886pyja7nmbcvu5kh7dp9557j4\"\n-e CF_RECORDTYPES=\"A;A\"\n</code></pre> <ul> <li>We use additionally a <code>CF_APITOKEN_ZONE</code> with the permissions <code>Zone - Zone - Read</code> to query the zones and getting the <code>zone_id</code>.</li> </ul> <pre><code>-e CF_APITOKEN=\"azkqvJ86wEScojvSJC8DyY67TwqNwZCtomEVrHwt\"\n-e CF_APITOKEN_ZONE=\"8m4TxzWb9QHXEpTwQDMugkKuHRavsxoK8qmJ4P7M\"\n-e CF_HOSTS=\"vpn.example.com;test.foobar.com\"\n-e CF_ZONES=\"example.com;axozor886pyja7nmbcvu5kh7dp9557j4\"\n-e CF_RECORDTYPES=\"A;A\"\n</code></pre> <ul> <li>We use only <code>CF_APITOKEN</code>, but with the permissions <code>Zone - DNS - Edit</code> and <code>Zone - Zone - Read</code>.</li> </ul> <pre><code>-e CF_APITOKEN=\"azkqvJ86wEScojvSJC8DyY67TwqNwZCtomEVrHwt\"\n-e CF_HOSTS=\"vpn.example.com;test.foobar.com\"\n-e CF_ZONES=\"example.com;axozor886pyja7nmbcvu5kh7dp9557j4\"\n-e CF_RECORDTYPES=\"A;A\"\n</code></pre> <ul> <li>We use <code>CF_USER</code> and <code>CF_APIKEY</code>, basically giving full control over our account.</li> </ul> <pre><code>-e CF_USER=\"your.cf.email@example.com\"\n-e CF_APIKEY=\"your.global.apikey\"\n-e CF_HOSTS=\"vpn.example.com;test.foobar.com\"\n-e CF_ZONES=\"example.com;axozor886pyja7nmbcvu5kh7dp9557j4\"\n-e CF_RECORDTYPES=\"A;A\"\n</code></pre>"},{"location":"containers/cloudflareddns/#example-of-the-log-output","title":"Example of the log output","text":"<pre><code>2020-05-17 17:20:54 -    INFO - IPv4 detected by [dig-whoami.cloudflare] is [1.1.1.1].\n2020-05-17 17:20:54 -    INFO - [1/1] [A] [vpn.example.com] Reading zone list from Cloudflare.\n2020-05-17 17:20:54 -    INFO - [1/1] [A] [vpn.example.com] Retrieved zone list from Cloudflare.\n2020-05-17 17:20:54 -    INFO - [1/1] [A] [vpn.example.com] Zone ID [xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx] found for zone [example.com].\n2020-05-17 17:20:54 -    INFO - [1/1] [A] [vpn.example.com] Reading DNS record from Cloudflare.\n2020-05-17 17:20:55 -    INFO - [1/1] [A] [vpn.example.com] Writing DNS record to cache file [/config/cf-ddns-A-vpn.example.com.cache].\n2020-05-17 17:20:55 -    INFO - [1/1] [A] [vpn.example.com] Checking if update is needed.\n2020-05-17 17:20:55 -    INFO - [1/1] [A] [vpn.example.com] No update needed.\n2020-05-17 17:20:55 -    INFO - Going to sleep for [300] seconds...\n</code></pre>"},{"location":"containers/cloudflareddns/#log-levels","title":"Log levels","text":"<p>For <code>LOG_LEVEL</code> you can pick <code>0</code>, <code>1</code>, <code>2</code> or <code>3</code>.</p> <ul> <li> <p><code>0</code> will give no log output. It's not recommended to use.</p> </li> <li> <p><code>1</code> will give you the following output types. It's the recommended value when all things are configured and running as expected.</p> </li> </ul> <pre><code>UPDATE, WARNING, ERROR\n</code></pre> <ul> <li><code>2</code> will give you the following output types. Use this if you always wanna see what's going on, but <code>3</code> gives you too much output.</li> </ul> <pre><code>UPDATE, WARNING, ERROR, INFO\n</code></pre> <ul> <li><code>3</code> will give you the following output types. This is the default.</li> </ul> <pre><code>UPDATE, WARNING, ERROR, INFO, DEBUG\n</code></pre>"},{"location":"containers/cloudflareddns/#json-log","title":"JSON log","text":"<p>Every IP update is also logged to <code>/config/cf-ddns-updates.json</code>. This can be used with the Telegraf JSON parser and the <code>tail</code> input, to get your domain updates into InfluxDB. Example output below.</p> <pre><code>{\"domain\":\"vpn.example.com\",\"recordtype\":\"A\",\"ip\":\"1.1.1.1\",\"timestamp\":\"2020-05-17T20:27:14Z\"}\n{\"domain\":\"vpn.example.com\",\"recordtype\":\"A\",\"ip\":\"1.1.1.1\",\"timestamp\":\"2020-05-17T20:29:26Z\"}\n</code></pre>"},{"location":"containers/cloudflareddns/#cached-results-from-cloudflare","title":"Cached results from Cloudflare","text":"<p>The returned results from Cloudflare are cached. This means minimal api calls to Cloudflare. If you have made any manual changes to the IP on the Cloudflare webinterface, for instance when wanting to test an update, a container restart is needed to clear the cache.</p> <p>The proxy setting (orange cloud) and TTL is also cached and re-set based on the previous value, so if you made any modifications to these settings, you should restart the container so that the script is aware of the new settings.</p>"},{"location":"containers/cloudflareddns/#sending-notifications","title":"Sending notifications","text":"<p>You can send notifications when a DNS record gets updated with a new IP using Apprise. Use the environment variable <code>APPRISE</code> to configure notifications, see below for some examples.</p> <pre><code>-e APPRISE=\"pover://user@token\"\n-e APPRISE=\"pover://user@token;discord://webhook_id/webhook_token\"\n</code></pre>"},{"location":"containers/cloudflareddns/#wireguard","title":"WireGuard","text":"<p>Info</p> <p>This image includes VPN support. The cli/compose examples below are environment variables and settings complementary to the app image examples, this means you'll have to add/merge the stuff below with the stuff above. In case you are still in need of a VPN, consider using my affiliate links for Proton VPN, Proton Unlimited or Private Internet Access.</p> <p> </p> genericprotonpia clicompose <pre><code>docker run --rm \\\n    --hostname container-name.internal \\ #(18)\n    -e VPN_ENABLED=\"true\" \\ #(5)\n    -e VPN_CONF=\"wg0\" \\ #(8)\n    -e VPN_PROVIDER=\"generic\" \\ #(4)\n    -e VPN_LAN_NETWORK=\"192.168.1.0/24\" \\ #(1)\n    -e VPN_LAN_LEAK_ENABLED=\"false\" \\ #(10)\n    -e VPN_EXPOSE_PORTS_ON_LAN=\"\" \\ #(2)\n    -e VPN_AUTO_PORT_FORWARD=\"false\" \\ #(6)\n    -e VPN_AUTO_PORT_FORWARD_TO_PORTS=\"\" \\ #(15)\n    -e VPN_FIREWALL_TYPE=\"auto\" \\ #(17)\n    -e VPN_HEALTHCHECK_ENABLED=\"false\" \\ #(20)\n    -e VPN_NAMESERVERS=\"\" \\ #(16)\n    -e PRIVOXY_ENABLED=\"false\" \\ #(19)\n    -e UNBOUND_ENABLED=\"false\" \\ #(21)\n    -e UNBOUND_NAMESERVERS=\"\" \\ #(22)\n    --cap-add=NET_ADMIN \\\n    --sysctl=\"net.ipv4.conf.all.src_valid_mark=1\" \\ #(12)\n    --sysctl=\"net.ipv6.conf.all.disable_ipv6=1\" \\ #(3)\n    --device /dev/net/tun:/dev/net/tun \\ # OPTIONAL(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui. On MacOS set it to <code>192.168.65.0/24</code> (Verify with your settings [Resources &gt; Network &gt; Docker subnet]).</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>. Affiliate links: Proton VPN Proton Unlimited Private Internet Access</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> (for PIA this is done automatically, see <code>VPN_PROVIDER</code> variable) located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32 in most cases\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>DANGEROUS! Don't enable unless you know what you are doing!</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>Some of the possible values are for example <code>wg</code>, <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>wg</code> will use the nameservers from the <code>wg0.conf</code> file. A value in the format <code>8.8.8.8</code> is to use a plain old nameserver. A value in the format <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>If you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice.</p> </li> <li> <p>This will start Privoxy on the default port 8118 when set to <code>true</code>. By default Privoxy is not exposed on the LAN, so if you need that, you'll have to add <code>VPN_EXPOSE_PORTS_ON_LAN=8118/tcp,8118/udp</code>.</p> </li> <li> <p>Enabling this will bring down the container if the connectivity tests fail at the end of the Wireguard init process or for an extended period during the container runtime.</p> </li> <li> <p>Enable Unbound by setting to <code>true</code> when VPN is not active.</p> </li> <li> <p>Possible values are <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>8.8.8.8</code> is to use a plain old nameserver. The value <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> </ol> <pre><code>services:\n  app:\n    hostname: container-name.internal #(18)\n    environment:\n      - VPN_ENABLED=true #(5)\n      - VPN_CONF=wg0 #(8)\n      - VPN_PROVIDER=generic #(4)\n      - VPN_LAN_NETWORK=192.168.1.0/24 #(1)\n      - VPN_LAN_LEAK_ENABLED=false #(10)\n      - VPN_EXPOSE_PORTS_ON_LAN #(2)\n      - VPN_AUTO_PORT_FORWARD=false #(6)\n      - VPN_AUTO_PORT_FORWARD_TO_PORTS= #(15)\n      - VPN_FIREWALL_TYPE=auto #(17)\n      - VPN_HEALTHCHECK_ENABLED=false #(20)\n      - VPN_NAMESERVERS= #(16)\n      - PRIVOXY_ENABLED=false #(19)\n      - UNBOUND_ENABLED=false #(21)\n      - UNBOUND_NAMESERVERS #(22)\n    cap_add:\n      - NET_ADMIN\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1 #(12)\n      - net.ipv6.conf.all.disable_ipv6=1 #(3)\n    devices:\n      - /dev/net/tun:/dev/net/tun # OPTIONAL(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui. On MacOS set it to <code>192.168.65.0/24</code> (Verify with your settings [Resources &gt; Network &gt; Docker subnet]).</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>. Affiliate links: Proton VPN Proton Unlimited Private Internet Access</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> (for PIA this is done automatically, see <code>VPN_PROVIDER</code> variable) located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32 in most cases\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>DANGEROUS! Don't enable unless you know what you are doing!</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>Some of the possible values are for example <code>wg</code>, <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>wg</code> will use the nameservers from the <code>wg0.conf</code> file. A value in the format <code>8.8.8.8</code> is to use a plain old nameserver. A value in the format <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>If you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice.</p> </li> <li> <p>This will start Privoxy on the default port 8118 when set to <code>true</code>. By default Privoxy is not exposed on the LAN, so if you need that, you'll have to add <code>VPN_EXPOSE_PORTS_ON_LAN=8118/tcp,8118/udp</code>.</p> </li> <li> <p>Enabling this will bring down the container if the connectivity tests fail at the end of the Wireguard init process or for an extended period during the container runtime.</p> </li> <li> <p>Enable Unbound by setting to <code>true</code> when VPN is not active.</p> </li> <li> <p>Possible values are <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>8.8.8.8</code> is to use a plain old nameserver. The value <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> </ol> clicompose <pre><code>docker run --rm \\\n    --hostname container-name.internal \\ #(18)\n    -e VPN_ENABLED=\"true\" \\ #(5)\n    -e VPN_CONF=\"wg0\" \\ #(8)\n    -e VPN_PROVIDER=\"proton\" \\ #(4)\n    -e VPN_LAN_NETWORK=\"192.168.1.0/24\" \\ #(1)\n    -e VPN_LAN_LEAK_ENABLED=\"false\" \\ #(10)\n    -e VPN_EXPOSE_PORTS_ON_LAN=\"\" \\ #(2)\n    -e VPN_AUTO_PORT_FORWARD=\"true\" \\ #(6)\n    -e VPN_AUTO_PORT_FORWARD_TO_PORTS=\"\" \\ #(15)\n    -e VPN_FIREWALL_TYPE=\"auto\" \\ #(17)\n    -e VPN_HEALTHCHECK_ENABLED=\"false\" \\ #(20)\n    -e VPN_NAMESERVERS=\"\" \\ #(16)\n    -e PRIVOXY_ENABLED=\"false\" \\ #(19)\n    -e UNBOUND_ENABLED=\"false\" \\ #(21)\n    -e UNBOUND_NAMESERVERS=\"\" \\ #(22)\n    --cap-add=NET_ADMIN \\\n    --sysctl=\"net.ipv4.conf.all.src_valid_mark=1\" \\ #(12)\n    --sysctl=\"net.ipv6.conf.all.disable_ipv6=1\" \\ #(3)\n    --device /dev/net/tun:/dev/net/tun \\ # OPTIONAL(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui. On MacOS set it to <code>192.168.65.0/24</code> (Verify with your settings [Resources &gt; Network &gt; Docker subnet]).</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>. Affiliate links: Proton VPN Proton Unlimited Private Internet Access</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> (for PIA this is done automatically, see <code>VPN_PROVIDER</code> variable) located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32 in most cases\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>DANGEROUS! Don't enable unless you know what you are doing!</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>Some of the possible values are for example <code>wg</code>, <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>wg</code> will use the nameservers from the <code>wg0.conf</code> file. A value in the format <code>8.8.8.8</code> is to use a plain old nameserver. A value in the format <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>If you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice.</p> </li> <li> <p>This will start Privoxy on the default port 8118 when set to <code>true</code>. By default Privoxy is not exposed on the LAN, so if you need that, you'll have to add <code>VPN_EXPOSE_PORTS_ON_LAN=8118/tcp,8118/udp</code>.</p> </li> <li> <p>Enabling this will bring down the container if the connectivity tests fail at the end of the Wireguard init process or for an extended period during the container runtime.</p> </li> <li> <p>Enable Unbound by setting to <code>true</code> when VPN is not active.</p> </li> <li> <p>Possible values are <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>8.8.8.8</code> is to use a plain old nameserver. The value <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> </ol> <pre><code>services:\n  app:\n    hostname: container-name.internal #(18)\n    environment:\n      - VPN_ENABLED=true #(5)\n      - VPN_CONF=wg0 #(8)\n      - VPN_PROVIDER=proton #(4)\n      - VPN_LAN_NETWORK=192.168.1.0/24 #(1)\n      - VPN_LAN_LEAK_ENABLED=false #(10)\n      - VPN_EXPOSE_PORTS_ON_LAN #(2)\n      - VPN_AUTO_PORT_FORWARD=true #(6)\n      - VPN_AUTO_PORT_FORWARD_TO_PORTS= #(15)\n      - VPN_FIREWALL_TYPE=auto #(17)\n      - VPN_HEALTHCHECK_ENABLED=false #(20)\n      - VPN_NAMESERVERS= #(16)\n      - PRIVOXY_ENABLED=false #(19)\n      - UNBOUND_ENABLED=false #(21)\n      - UNBOUND_NAMESERVERS #(22)\n    cap_add:\n      - NET_ADMIN\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1 #(12)\n      - net.ipv6.conf.all.disable_ipv6=1 #(3)\n    devices:\n      - /dev/net/tun:/dev/net/tun # OPTIONAL(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui. On MacOS set it to <code>192.168.65.0/24</code> (Verify with your settings [Resources &gt; Network &gt; Docker subnet]).</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>. Affiliate links: Proton VPN Proton Unlimited Private Internet Access</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> (for PIA this is done automatically, see <code>VPN_PROVIDER</code> variable) located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32 in most cases\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>DANGEROUS! Don't enable unless you know what you are doing!</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>Some of the possible values are for example <code>wg</code>, <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>wg</code> will use the nameservers from the <code>wg0.conf</code> file. A value in the format <code>8.8.8.8</code> is to use a plain old nameserver. A value in the format <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>If you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice.</p> </li> <li> <p>This will start Privoxy on the default port 8118 when set to <code>true</code>. By default Privoxy is not exposed on the LAN, so if you need that, you'll have to add <code>VPN_EXPOSE_PORTS_ON_LAN=8118/tcp,8118/udp</code>.</p> </li> <li> <p>Enabling this will bring down the container if the connectivity tests fail at the end of the Wireguard init process or for an extended period during the container runtime.</p> </li> <li> <p>Enable Unbound by setting to <code>true</code> when VPN is not active.</p> </li> <li> <p>Possible values are <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>8.8.8.8</code> is to use a plain old nameserver. The value <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> </ol> clicompose <pre><code>docker run --rm \\\n    --hostname container-name.internal \\ #(18)\n    -e VPN_ENABLED=\"true\" \\ #(5)\n    -e VPN_CONF=\"wg0\" \\ #(8)\n    -e VPN_PROVIDER=\"pia\" \\ #(4)\n    -e VPN_LAN_NETWORK=\"192.168.1.0/24\" \\ #(1)\n    -e VPN_LAN_LEAK_ENABLED=\"false\" \\ #(10)\n    -e VPN_EXPOSE_PORTS_ON_LAN=\"\" \\ #(2)\n    -e VPN_AUTO_PORT_FORWARD=\"true\" \\ #(6)\n    -e VPN_AUTO_PORT_FORWARD_TO_PORTS=\"\" \\ #(15)\n    -e VPN_FIREWALL_TYPE=\"auto\" \\ #(17)\n    -e VPN_HEALTHCHECK_ENABLED=\"false\" \\ #(20)\n    -e VPN_NAMESERVERS=\"\" \\ #(16)\n    -e VPN_PIA_USER=\"\" \\ #(11)\n    -e VPN_PIA_PASS=\"\" \\ #(11)\n    -e VPN_PIA_PREFERRED_REGION=\"\" \\ #(7)\n    -e VPN_PIA_DIP_TOKEN=\"no\" \\ #(13)\n    -e VPN_PIA_PORT_FORWARD_PERSIST=\"false\" \\ #(14)\n    -e PRIVOXY_ENABLED=\"false\" \\ #(19)\n    -e UNBOUND_ENABLED=\"false\" \\ #(21)\n    -e UNBOUND_NAMESERVERS=\"\" \\ #(22)\n    --cap-add=NET_ADMIN \\\n    --sysctl=\"net.ipv4.conf.all.src_valid_mark=1\" \\ #(12)\n    --sysctl=\"net.ipv6.conf.all.disable_ipv6=1\" \\ #(3)\n    --device /dev/net/tun:/dev/net/tun \\ # OPTIONAL(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui. On MacOS set it to <code>192.168.65.0/24</code> (Verify with your settings [Resources &gt; Network &gt; Docker subnet]).</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>. Affiliate links: Proton VPN Proton Unlimited Private Internet Access</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> (for PIA this is done automatically, see <code>VPN_PROVIDER</code> variable) located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32 in most cases\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>DANGEROUS! Don't enable unless you know what you are doing!</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>Some of the possible values are for example <code>wg</code>, <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>wg</code> will use the nameservers from the <code>wg0.conf</code> file. A value in the format <code>8.8.8.8</code> is to use a plain old nameserver. A value in the format <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>If you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice.</p> </li> <li> <p>This will start Privoxy on the default port 8118 when set to <code>true</code>. By default Privoxy is not exposed on the LAN, so if you need that, you'll have to add <code>VPN_EXPOSE_PORTS_ON_LAN=8118/tcp,8118/udp</code>.</p> </li> <li> <p>Enabling this will bring down the container if the connectivity tests fail at the end of the Wireguard init process or for an extended period during the container runtime.</p> </li> <li> <p>Enable Unbound by setting to <code>true</code> when VPN is not active.</p> </li> <li> <p>Possible values are <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>8.8.8.8</code> is to use a plain old nameserver. The value <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> </ol> <pre><code>services:\n  app:\n    hostname: container-name.internal #(18)\n    environment:\n      - VPN_ENABLED=true #(5)\n      - VPN_CONF=wg0 #(8)\n      - VPN_PROVIDER=pia #(4)\n      - VPN_LAN_NETWORK=192.168.1.0/24 #(1)\n      - VPN_LAN_LEAK_ENABLED=false #(10)\n      - VPN_EXPOSE_PORTS_ON_LAN #(2)\n      - VPN_AUTO_PORT_FORWARD=true #(6)\n      - VPN_AUTO_PORT_FORWARD_TO_PORTS= #(15)\n      - VPN_FIREWALL_TYPE=auto #(17)\n      - VPN_HEALTHCHECK_ENABLED=false #(20)\n      - VPN_NAMESERVERS= #(16)\n      - VPN_PIA_USER #(11)\n      - VPN_PIA_PASS #(11)\n      - VPN_PIA_PREFERRED_REGION #(7)\n      - VPN_PIA_DIP_TOKEN=no #(13)\n      - VPN_PIA_PORT_FORWARD_PERSIST=false #(14)\n      - PRIVOXY_ENABLED=false #(19)\n      - UNBOUND_ENABLED=false #(21)\n      - UNBOUND_NAMESERVERS #(22)\n    cap_add:\n      - NET_ADMIN\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1 #(12)\n      - net.ipv6.conf.all.disable_ipv6=1 #(3)\n    devices:\n      - /dev/net/tun:/dev/net/tun # OPTIONAL(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui. On MacOS set it to <code>192.168.65.0/24</code> (Verify with your settings [Resources &gt; Network &gt; Docker subnet]).</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>. Affiliate links: Proton VPN Proton Unlimited Private Internet Access</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> (for PIA this is done automatically, see <code>VPN_PROVIDER</code> variable) located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32 in most cases\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>DANGEROUS! Don't enable unless you know what you are doing!</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>Some of the possible values are for example <code>wg</code>, <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>wg</code> will use the nameservers from the <code>wg0.conf</code> file. A value in the format <code>8.8.8.8</code> is to use a plain old nameserver. A value in the format <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>If you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice.</p> </li> <li> <p>This will start Privoxy on the default port 8118 when set to <code>true</code>. By default Privoxy is not exposed on the LAN, so if you need that, you'll have to add <code>VPN_EXPOSE_PORTS_ON_LAN=8118/tcp,8118/udp</code>.</p> </li> <li> <p>Enabling this will bring down the container if the connectivity tests fail at the end of the Wireguard init process or for an extended period during the container runtime.</p> </li> <li> <p>Enable Unbound by setting to <code>true</code> when VPN is not active.</p> </li> <li> <p>Possible values are <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>8.8.8.8</code> is to use a plain old nameserver. The value <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> </ol>"},{"location":"containers/doplarr/","title":"hotio/doplarr","text":"<p> GitHub ghcr.io</p>"},{"location":"containers/doplarr/#starting-the-container","title":"Starting the container","text":"clicompose <pre><code>docker run --rm \\\n    --name doplarr \\\n    -e PUID=1000 \\\n    -e PGID=1000 \\\n    -e UMASK=002 \\\n    -e TZ=\"Etc/UTC\" \\\n    -v /&lt;host_folder_config&gt;:/config \\\n    ghcr.io/hotio/doplarr\n</code></pre> <pre><code>services:\n  doplarr:\n    container_name: doplarr\n    image: ghcr.io/hotio/doplarr\n    environment:\n      - PUID=1000\n      - PGID=1000\n      - UMASK=002\n      - TZ=Etc/UTC\n    volumes:\n      - /&lt;host_folder_config&gt;:/config\n</code></pre>"},{"location":"containers/doplarr/#tags","title":"Tags","text":"Tags Description Last Updated Age"},{"location":"containers/doplarr/#wireguard","title":"WireGuard","text":"<p>Info</p> <p>This image includes VPN support. The cli/compose examples below are environment variables and settings complementary to the app image examples, this means you'll have to add/merge the stuff below with the stuff above. In case you are still in need of a VPN, consider using my affiliate links for Proton VPN, Proton Unlimited or Private Internet Access.</p> <p> </p> genericprotonpia clicompose <pre><code>docker run --rm \\\n    --hostname container-name.internal \\ #(18)\n    -e VPN_ENABLED=\"true\" \\ #(5)\n    -e VPN_CONF=\"wg0\" \\ #(8)\n    -e VPN_PROVIDER=\"generic\" \\ #(4)\n    -e VPN_LAN_NETWORK=\"192.168.1.0/24\" \\ #(1)\n    -e VPN_LAN_LEAK_ENABLED=\"false\" \\ #(10)\n    -e VPN_EXPOSE_PORTS_ON_LAN=\"\" \\ #(2)\n    -e VPN_AUTO_PORT_FORWARD=\"false\" \\ #(6)\n    -e VPN_AUTO_PORT_FORWARD_TO_PORTS=\"\" \\ #(15)\n    -e VPN_FIREWALL_TYPE=\"auto\" \\ #(17)\n    -e VPN_HEALTHCHECK_ENABLED=\"false\" \\ #(20)\n    -e VPN_NAMESERVERS=\"\" \\ #(16)\n    -e PRIVOXY_ENABLED=\"false\" \\ #(19)\n    -e UNBOUND_ENABLED=\"false\" \\ #(21)\n    -e UNBOUND_NAMESERVERS=\"\" \\ #(22)\n    --cap-add=NET_ADMIN \\\n    --sysctl=\"net.ipv4.conf.all.src_valid_mark=1\" \\ #(12)\n    --sysctl=\"net.ipv6.conf.all.disable_ipv6=1\" \\ #(3)\n    --device /dev/net/tun:/dev/net/tun \\ # OPTIONAL(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui. On MacOS set it to <code>192.168.65.0/24</code> (Verify with your settings [Resources &gt; Network &gt; Docker subnet]).</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>. Affiliate links: Proton VPN Proton Unlimited Private Internet Access</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> (for PIA this is done automatically, see <code>VPN_PROVIDER</code> variable) located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32 in most cases\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>DANGEROUS! Don't enable unless you know what you are doing!</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>Some of the possible values are for example <code>wg</code>, <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>wg</code> will use the nameservers from the <code>wg0.conf</code> file. A value in the format <code>8.8.8.8</code> is to use a plain old nameserver. A value in the format <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>If you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice.</p> </li> <li> <p>This will start Privoxy on the default port 8118 when set to <code>true</code>. By default Privoxy is not exposed on the LAN, so if you need that, you'll have to add <code>VPN_EXPOSE_PORTS_ON_LAN=8118/tcp,8118/udp</code>.</p> </li> <li> <p>Enabling this will bring down the container if the connectivity tests fail at the end of the Wireguard init process or for an extended period during the container runtime.</p> </li> <li> <p>Enable Unbound by setting to <code>true</code> when VPN is not active.</p> </li> <li> <p>Possible values are <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>8.8.8.8</code> is to use a plain old nameserver. The value <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> </ol> <pre><code>services:\n  app:\n    hostname: container-name.internal #(18)\n    environment:\n      - VPN_ENABLED=true #(5)\n      - VPN_CONF=wg0 #(8)\n      - VPN_PROVIDER=generic #(4)\n      - VPN_LAN_NETWORK=192.168.1.0/24 #(1)\n      - VPN_LAN_LEAK_ENABLED=false #(10)\n      - VPN_EXPOSE_PORTS_ON_LAN #(2)\n      - VPN_AUTO_PORT_FORWARD=false #(6)\n      - VPN_AUTO_PORT_FORWARD_TO_PORTS= #(15)\n      - VPN_FIREWALL_TYPE=auto #(17)\n      - VPN_HEALTHCHECK_ENABLED=false #(20)\n      - VPN_NAMESERVERS= #(16)\n      - PRIVOXY_ENABLED=false #(19)\n      - UNBOUND_ENABLED=false #(21)\n      - UNBOUND_NAMESERVERS #(22)\n    cap_add:\n      - NET_ADMIN\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1 #(12)\n      - net.ipv6.conf.all.disable_ipv6=1 #(3)\n    devices:\n      - /dev/net/tun:/dev/net/tun # OPTIONAL(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui. On MacOS set it to <code>192.168.65.0/24</code> (Verify with your settings [Resources &gt; Network &gt; Docker subnet]).</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>. Affiliate links: Proton VPN Proton Unlimited Private Internet Access</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> (for PIA this is done automatically, see <code>VPN_PROVIDER</code> variable) located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32 in most cases\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>DANGEROUS! Don't enable unless you know what you are doing!</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>Some of the possible values are for example <code>wg</code>, <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>wg</code> will use the nameservers from the <code>wg0.conf</code> file. A value in the format <code>8.8.8.8</code> is to use a plain old nameserver. A value in the format <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>If you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice.</p> </li> <li> <p>This will start Privoxy on the default port 8118 when set to <code>true</code>. By default Privoxy is not exposed on the LAN, so if you need that, you'll have to add <code>VPN_EXPOSE_PORTS_ON_LAN=8118/tcp,8118/udp</code>.</p> </li> <li> <p>Enabling this will bring down the container if the connectivity tests fail at the end of the Wireguard init process or for an extended period during the container runtime.</p> </li> <li> <p>Enable Unbound by setting to <code>true</code> when VPN is not active.</p> </li> <li> <p>Possible values are <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>8.8.8.8</code> is to use a plain old nameserver. The value <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> </ol> clicompose <pre><code>docker run --rm \\\n    --hostname container-name.internal \\ #(18)\n    -e VPN_ENABLED=\"true\" \\ #(5)\n    -e VPN_CONF=\"wg0\" \\ #(8)\n    -e VPN_PROVIDER=\"proton\" \\ #(4)\n    -e VPN_LAN_NETWORK=\"192.168.1.0/24\" \\ #(1)\n    -e VPN_LAN_LEAK_ENABLED=\"false\" \\ #(10)\n    -e VPN_EXPOSE_PORTS_ON_LAN=\"\" \\ #(2)\n    -e VPN_AUTO_PORT_FORWARD=\"true\" \\ #(6)\n    -e VPN_AUTO_PORT_FORWARD_TO_PORTS=\"\" \\ #(15)\n    -e VPN_FIREWALL_TYPE=\"auto\" \\ #(17)\n    -e VPN_HEALTHCHECK_ENABLED=\"false\" \\ #(20)\n    -e VPN_NAMESERVERS=\"\" \\ #(16)\n    -e PRIVOXY_ENABLED=\"false\" \\ #(19)\n    -e UNBOUND_ENABLED=\"false\" \\ #(21)\n    -e UNBOUND_NAMESERVERS=\"\" \\ #(22)\n    --cap-add=NET_ADMIN \\\n    --sysctl=\"net.ipv4.conf.all.src_valid_mark=1\" \\ #(12)\n    --sysctl=\"net.ipv6.conf.all.disable_ipv6=1\" \\ #(3)\n    --device /dev/net/tun:/dev/net/tun \\ # OPTIONAL(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui. On MacOS set it to <code>192.168.65.0/24</code> (Verify with your settings [Resources &gt; Network &gt; Docker subnet]).</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>. Affiliate links: Proton VPN Proton Unlimited Private Internet Access</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> (for PIA this is done automatically, see <code>VPN_PROVIDER</code> variable) located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32 in most cases\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>DANGEROUS! Don't enable unless you know what you are doing!</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>Some of the possible values are for example <code>wg</code>, <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>wg</code> will use the nameservers from the <code>wg0.conf</code> file. A value in the format <code>8.8.8.8</code> is to use a plain old nameserver. A value in the format <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>If you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice.</p> </li> <li> <p>This will start Privoxy on the default port 8118 when set to <code>true</code>. By default Privoxy is not exposed on the LAN, so if you need that, you'll have to add <code>VPN_EXPOSE_PORTS_ON_LAN=8118/tcp,8118/udp</code>.</p> </li> <li> <p>Enabling this will bring down the container if the connectivity tests fail at the end of the Wireguard init process or for an extended period during the container runtime.</p> </li> <li> <p>Enable Unbound by setting to <code>true</code> when VPN is not active.</p> </li> <li> <p>Possible values are <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>8.8.8.8</code> is to use a plain old nameserver. The value <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> </ol> <pre><code>services:\n  app:\n    hostname: container-name.internal #(18)\n    environment:\n      - VPN_ENABLED=true #(5)\n      - VPN_CONF=wg0 #(8)\n      - VPN_PROVIDER=proton #(4)\n      - VPN_LAN_NETWORK=192.168.1.0/24 #(1)\n      - VPN_LAN_LEAK_ENABLED=false #(10)\n      - VPN_EXPOSE_PORTS_ON_LAN #(2)\n      - VPN_AUTO_PORT_FORWARD=true #(6)\n      - VPN_AUTO_PORT_FORWARD_TO_PORTS= #(15)\n      - VPN_FIREWALL_TYPE=auto #(17)\n      - VPN_HEALTHCHECK_ENABLED=false #(20)\n      - VPN_NAMESERVERS= #(16)\n      - PRIVOXY_ENABLED=false #(19)\n      - UNBOUND_ENABLED=false #(21)\n      - UNBOUND_NAMESERVERS #(22)\n    cap_add:\n      - NET_ADMIN\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1 #(12)\n      - net.ipv6.conf.all.disable_ipv6=1 #(3)\n    devices:\n      - /dev/net/tun:/dev/net/tun # OPTIONAL(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui. On MacOS set it to <code>192.168.65.0/24</code> (Verify with your settings [Resources &gt; Network &gt; Docker subnet]).</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>. Affiliate links: Proton VPN Proton Unlimited Private Internet Access</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> (for PIA this is done automatically, see <code>VPN_PROVIDER</code> variable) located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32 in most cases\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>DANGEROUS! Don't enable unless you know what you are doing!</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>Some of the possible values are for example <code>wg</code>, <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>wg</code> will use the nameservers from the <code>wg0.conf</code> file. A value in the format <code>8.8.8.8</code> is to use a plain old nameserver. A value in the format <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>If you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice.</p> </li> <li> <p>This will start Privoxy on the default port 8118 when set to <code>true</code>. By default Privoxy is not exposed on the LAN, so if you need that, you'll have to add <code>VPN_EXPOSE_PORTS_ON_LAN=8118/tcp,8118/udp</code>.</p> </li> <li> <p>Enabling this will bring down the container if the connectivity tests fail at the end of the Wireguard init process or for an extended period during the container runtime.</p> </li> <li> <p>Enable Unbound by setting to <code>true</code> when VPN is not active.</p> </li> <li> <p>Possible values are <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>8.8.8.8</code> is to use a plain old nameserver. The value <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> </ol> clicompose <pre><code>docker run --rm \\\n    --hostname container-name.internal \\ #(18)\n    -e VPN_ENABLED=\"true\" \\ #(5)\n    -e VPN_CONF=\"wg0\" \\ #(8)\n    -e VPN_PROVIDER=\"pia\" \\ #(4)\n    -e VPN_LAN_NETWORK=\"192.168.1.0/24\" \\ #(1)\n    -e VPN_LAN_LEAK_ENABLED=\"false\" \\ #(10)\n    -e VPN_EXPOSE_PORTS_ON_LAN=\"\" \\ #(2)\n    -e VPN_AUTO_PORT_FORWARD=\"true\" \\ #(6)\n    -e VPN_AUTO_PORT_FORWARD_TO_PORTS=\"\" \\ #(15)\n    -e VPN_FIREWALL_TYPE=\"auto\" \\ #(17)\n    -e VPN_HEALTHCHECK_ENABLED=\"false\" \\ #(20)\n    -e VPN_NAMESERVERS=\"\" \\ #(16)\n    -e VPN_PIA_USER=\"\" \\ #(11)\n    -e VPN_PIA_PASS=\"\" \\ #(11)\n    -e VPN_PIA_PREFERRED_REGION=\"\" \\ #(7)\n    -e VPN_PIA_DIP_TOKEN=\"no\" \\ #(13)\n    -e VPN_PIA_PORT_FORWARD_PERSIST=\"false\" \\ #(14)\n    -e PRIVOXY_ENABLED=\"false\" \\ #(19)\n    -e UNBOUND_ENABLED=\"false\" \\ #(21)\n    -e UNBOUND_NAMESERVERS=\"\" \\ #(22)\n    --cap-add=NET_ADMIN \\\n    --sysctl=\"net.ipv4.conf.all.src_valid_mark=1\" \\ #(12)\n    --sysctl=\"net.ipv6.conf.all.disable_ipv6=1\" \\ #(3)\n    --device /dev/net/tun:/dev/net/tun \\ # OPTIONAL(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui. On MacOS set it to <code>192.168.65.0/24</code> (Verify with your settings [Resources &gt; Network &gt; Docker subnet]).</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>. Affiliate links: Proton VPN Proton Unlimited Private Internet Access</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> (for PIA this is done automatically, see <code>VPN_PROVIDER</code> variable) located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32 in most cases\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>DANGEROUS! Don't enable unless you know what you are doing!</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>Some of the possible values are for example <code>wg</code>, <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>wg</code> will use the nameservers from the <code>wg0.conf</code> file. A value in the format <code>8.8.8.8</code> is to use a plain old nameserver. A value in the format <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>If you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice.</p> </li> <li> <p>This will start Privoxy on the default port 8118 when set to <code>true</code>. By default Privoxy is not exposed on the LAN, so if you need that, you'll have to add <code>VPN_EXPOSE_PORTS_ON_LAN=8118/tcp,8118/udp</code>.</p> </li> <li> <p>Enabling this will bring down the container if the connectivity tests fail at the end of the Wireguard init process or for an extended period during the container runtime.</p> </li> <li> <p>Enable Unbound by setting to <code>true</code> when VPN is not active.</p> </li> <li> <p>Possible values are <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>8.8.8.8</code> is to use a plain old nameserver. The value <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> </ol> <pre><code>services:\n  app:\n    hostname: container-name.internal #(18)\n    environment:\n      - VPN_ENABLED=true #(5)\n      - VPN_CONF=wg0 #(8)\n      - VPN_PROVIDER=pia #(4)\n      - VPN_LAN_NETWORK=192.168.1.0/24 #(1)\n      - VPN_LAN_LEAK_ENABLED=false #(10)\n      - VPN_EXPOSE_PORTS_ON_LAN #(2)\n      - VPN_AUTO_PORT_FORWARD=true #(6)\n      - VPN_AUTO_PORT_FORWARD_TO_PORTS= #(15)\n      - VPN_FIREWALL_TYPE=auto #(17)\n      - VPN_HEALTHCHECK_ENABLED=false #(20)\n      - VPN_NAMESERVERS= #(16)\n      - VPN_PIA_USER #(11)\n      - VPN_PIA_PASS #(11)\n      - VPN_PIA_PREFERRED_REGION #(7)\n      - VPN_PIA_DIP_TOKEN=no #(13)\n      - VPN_PIA_PORT_FORWARD_PERSIST=false #(14)\n      - PRIVOXY_ENABLED=false #(19)\n      - UNBOUND_ENABLED=false #(21)\n      - UNBOUND_NAMESERVERS #(22)\n    cap_add:\n      - NET_ADMIN\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1 #(12)\n      - net.ipv6.conf.all.disable_ipv6=1 #(3)\n    devices:\n      - /dev/net/tun:/dev/net/tun # OPTIONAL(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui. On MacOS set it to <code>192.168.65.0/24</code> (Verify with your settings [Resources &gt; Network &gt; Docker subnet]).</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>. Affiliate links: Proton VPN Proton Unlimited Private Internet Access</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> (for PIA this is done automatically, see <code>VPN_PROVIDER</code> variable) located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32 in most cases\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>DANGEROUS! Don't enable unless you know what you are doing!</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>Some of the possible values are for example <code>wg</code>, <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>wg</code> will use the nameservers from the <code>wg0.conf</code> file. A value in the format <code>8.8.8.8</code> is to use a plain old nameserver. A value in the format <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>If you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice.</p> </li> <li> <p>This will start Privoxy on the default port 8118 when set to <code>true</code>. By default Privoxy is not exposed on the LAN, so if you need that, you'll have to add <code>VPN_EXPOSE_PORTS_ON_LAN=8118/tcp,8118/udp</code>.</p> </li> <li> <p>Enabling this will bring down the container if the connectivity tests fail at the end of the Wireguard init process or for an extended period during the container runtime.</p> </li> <li> <p>Enable Unbound by setting to <code>true</code> when VPN is not active.</p> </li> <li> <p>Possible values are <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>8.8.8.8</code> is to use a plain old nameserver. The value <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> </ol>"},{"location":"containers/duplicacy/","title":"hotio/duplicacy","text":"<p> GitHub ghcr.io</p>"},{"location":"containers/duplicacy/#starting-the-container","title":"Starting the container","text":"clicompose <pre><code>docker run --rm \\\n    --name duplicacy \\\n    --hostname duplicacy \\\n    -p 3875:3875 \\\n    -e PUID=1000 \\\n    -e PGID=1000 \\\n    -e UMASK=002 \\\n    -e TZ=\"Etc/UTC\" \\\n    -v /&lt;host_folder_config&gt;:/config \\\n    -v /&lt;host_folder_cache&gt;:/cache \\\n    -v /&lt;host_folder_logs&gt;:/logs \\\n    -v /&lt;host_folder_data&gt;:/data \\\n    ghcr.io/hotio/duplicacy\n</code></pre> <pre><code>services:\n  duplicacy:\n    container_name: duplicacy\n    hostname: duplicacy\n    image: ghcr.io/hotio/duplicacy\n    ports:\n      - \"3875:3875\"\n    environment:\n      - PUID=1000\n      - PGID=1000\n      - UMASK=002\n      - TZ=Etc/UTC\n    volumes:\n      - /&lt;host_folder_config&gt;:/config\n      - /&lt;host_folder_cache&gt;:/cache\n      - /&lt;host_folder_logs&gt;:/logs\n      - /&lt;host_folder_data&gt;:/data\n</code></pre> <p>If you don't want to enter your password every time you restart the container, you can set the environment variable <code>DWE_PASSWORD</code> with your password or starting with version 1.4.1 a file <code>/config/keyring</code> will be created that stores your password encryted if you click the checkmark on the login page.</p>"},{"location":"containers/duplicacy/#tags","title":"Tags","text":"Tags Description Last Updated Age"},{"location":"containers/duplicacy/#wireguard","title":"WireGuard","text":"<p>Info</p> <p>This image includes VPN support. The cli/compose examples below are environment variables and settings complementary to the app image examples, this means you'll have to add/merge the stuff below with the stuff above. In case you are still in need of a VPN, consider using my affiliate links for Proton VPN, Proton Unlimited or Private Internet Access.</p> <p> </p> genericprotonpia clicompose <pre><code>docker run --rm \\\n    --hostname container-name.internal \\ #(18)\n    -e VPN_ENABLED=\"true\" \\ #(5)\n    -e VPN_CONF=\"wg0\" \\ #(8)\n    -e VPN_PROVIDER=\"generic\" \\ #(4)\n    -e VPN_LAN_NETWORK=\"192.168.1.0/24\" \\ #(1)\n    -e VPN_LAN_LEAK_ENABLED=\"false\" \\ #(10)\n    -e VPN_EXPOSE_PORTS_ON_LAN=\"\" \\ #(2)\n    -e VPN_AUTO_PORT_FORWARD=\"false\" \\ #(6)\n    -e VPN_AUTO_PORT_FORWARD_TO_PORTS=\"\" \\ #(15)\n    -e VPN_FIREWALL_TYPE=\"auto\" \\ #(17)\n    -e VPN_HEALTHCHECK_ENABLED=\"false\" \\ #(20)\n    -e VPN_NAMESERVERS=\"\" \\ #(16)\n    -e PRIVOXY_ENABLED=\"false\" \\ #(19)\n    -e UNBOUND_ENABLED=\"false\" \\ #(21)\n    -e UNBOUND_NAMESERVERS=\"\" \\ #(22)\n    --cap-add=NET_ADMIN \\\n    --sysctl=\"net.ipv4.conf.all.src_valid_mark=1\" \\ #(12)\n    --sysctl=\"net.ipv6.conf.all.disable_ipv6=1\" \\ #(3)\n    --device /dev/net/tun:/dev/net/tun \\ # OPTIONAL(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui. On MacOS set it to <code>192.168.65.0/24</code> (Verify with your settings [Resources &gt; Network &gt; Docker subnet]).</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>. Affiliate links: Proton VPN Proton Unlimited Private Internet Access</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> (for PIA this is done automatically, see <code>VPN_PROVIDER</code> variable) located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32 in most cases\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>DANGEROUS! Don't enable unless you know what you are doing!</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>Some of the possible values are for example <code>wg</code>, <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>wg</code> will use the nameservers from the <code>wg0.conf</code> file. A value in the format <code>8.8.8.8</code> is to use a plain old nameserver. A value in the format <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>If you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice.</p> </li> <li> <p>This will start Privoxy on the default port 8118 when set to <code>true</code>. By default Privoxy is not exposed on the LAN, so if you need that, you'll have to add <code>VPN_EXPOSE_PORTS_ON_LAN=8118/tcp,8118/udp</code>.</p> </li> <li> <p>Enabling this will bring down the container if the connectivity tests fail at the end of the Wireguard init process or for an extended period during the container runtime.</p> </li> <li> <p>Enable Unbound by setting to <code>true</code> when VPN is not active.</p> </li> <li> <p>Possible values are <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>8.8.8.8</code> is to use a plain old nameserver. The value <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> </ol> <pre><code>services:\n  app:\n    hostname: container-name.internal #(18)\n    environment:\n      - VPN_ENABLED=true #(5)\n      - VPN_CONF=wg0 #(8)\n      - VPN_PROVIDER=generic #(4)\n      - VPN_LAN_NETWORK=192.168.1.0/24 #(1)\n      - VPN_LAN_LEAK_ENABLED=false #(10)\n      - VPN_EXPOSE_PORTS_ON_LAN #(2)\n      - VPN_AUTO_PORT_FORWARD=false #(6)\n      - VPN_AUTO_PORT_FORWARD_TO_PORTS= #(15)\n      - VPN_FIREWALL_TYPE=auto #(17)\n      - VPN_HEALTHCHECK_ENABLED=false #(20)\n      - VPN_NAMESERVERS= #(16)\n      - PRIVOXY_ENABLED=false #(19)\n      - UNBOUND_ENABLED=false #(21)\n      - UNBOUND_NAMESERVERS #(22)\n    cap_add:\n      - NET_ADMIN\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1 #(12)\n      - net.ipv6.conf.all.disable_ipv6=1 #(3)\n    devices:\n      - /dev/net/tun:/dev/net/tun # OPTIONAL(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui. On MacOS set it to <code>192.168.65.0/24</code> (Verify with your settings [Resources &gt; Network &gt; Docker subnet]).</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>. Affiliate links: Proton VPN Proton Unlimited Private Internet Access</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> (for PIA this is done automatically, see <code>VPN_PROVIDER</code> variable) located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32 in most cases\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>DANGEROUS! Don't enable unless you know what you are doing!</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>Some of the possible values are for example <code>wg</code>, <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>wg</code> will use the nameservers from the <code>wg0.conf</code> file. A value in the format <code>8.8.8.8</code> is to use a plain old nameserver. A value in the format <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>If you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice.</p> </li> <li> <p>This will start Privoxy on the default port 8118 when set to <code>true</code>. By default Privoxy is not exposed on the LAN, so if you need that, you'll have to add <code>VPN_EXPOSE_PORTS_ON_LAN=8118/tcp,8118/udp</code>.</p> </li> <li> <p>Enabling this will bring down the container if the connectivity tests fail at the end of the Wireguard init process or for an extended period during the container runtime.</p> </li> <li> <p>Enable Unbound by setting to <code>true</code> when VPN is not active.</p> </li> <li> <p>Possible values are <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>8.8.8.8</code> is to use a plain old nameserver. The value <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> </ol> clicompose <pre><code>docker run --rm \\\n    --hostname container-name.internal \\ #(18)\n    -e VPN_ENABLED=\"true\" \\ #(5)\n    -e VPN_CONF=\"wg0\" \\ #(8)\n    -e VPN_PROVIDER=\"proton\" \\ #(4)\n    -e VPN_LAN_NETWORK=\"192.168.1.0/24\" \\ #(1)\n    -e VPN_LAN_LEAK_ENABLED=\"false\" \\ #(10)\n    -e VPN_EXPOSE_PORTS_ON_LAN=\"\" \\ #(2)\n    -e VPN_AUTO_PORT_FORWARD=\"true\" \\ #(6)\n    -e VPN_AUTO_PORT_FORWARD_TO_PORTS=\"\" \\ #(15)\n    -e VPN_FIREWALL_TYPE=\"auto\" \\ #(17)\n    -e VPN_HEALTHCHECK_ENABLED=\"false\" \\ #(20)\n    -e VPN_NAMESERVERS=\"\" \\ #(16)\n    -e PRIVOXY_ENABLED=\"false\" \\ #(19)\n    -e UNBOUND_ENABLED=\"false\" \\ #(21)\n    -e UNBOUND_NAMESERVERS=\"\" \\ #(22)\n    --cap-add=NET_ADMIN \\\n    --sysctl=\"net.ipv4.conf.all.src_valid_mark=1\" \\ #(12)\n    --sysctl=\"net.ipv6.conf.all.disable_ipv6=1\" \\ #(3)\n    --device /dev/net/tun:/dev/net/tun \\ # OPTIONAL(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui. On MacOS set it to <code>192.168.65.0/24</code> (Verify with your settings [Resources &gt; Network &gt; Docker subnet]).</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>. Affiliate links: Proton VPN Proton Unlimited Private Internet Access</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> (for PIA this is done automatically, see <code>VPN_PROVIDER</code> variable) located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32 in most cases\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>DANGEROUS! Don't enable unless you know what you are doing!</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>Some of the possible values are for example <code>wg</code>, <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>wg</code> will use the nameservers from the <code>wg0.conf</code> file. A value in the format <code>8.8.8.8</code> is to use a plain old nameserver. A value in the format <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>If you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice.</p> </li> <li> <p>This will start Privoxy on the default port 8118 when set to <code>true</code>. By default Privoxy is not exposed on the LAN, so if you need that, you'll have to add <code>VPN_EXPOSE_PORTS_ON_LAN=8118/tcp,8118/udp</code>.</p> </li> <li> <p>Enabling this will bring down the container if the connectivity tests fail at the end of the Wireguard init process or for an extended period during the container runtime.</p> </li> <li> <p>Enable Unbound by setting to <code>true</code> when VPN is not active.</p> </li> <li> <p>Possible values are <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>8.8.8.8</code> is to use a plain old nameserver. The value <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> </ol> <pre><code>services:\n  app:\n    hostname: container-name.internal #(18)\n    environment:\n      - VPN_ENABLED=true #(5)\n      - VPN_CONF=wg0 #(8)\n      - VPN_PROVIDER=proton #(4)\n      - VPN_LAN_NETWORK=192.168.1.0/24 #(1)\n      - VPN_LAN_LEAK_ENABLED=false #(10)\n      - VPN_EXPOSE_PORTS_ON_LAN #(2)\n      - VPN_AUTO_PORT_FORWARD=true #(6)\n      - VPN_AUTO_PORT_FORWARD_TO_PORTS= #(15)\n      - VPN_FIREWALL_TYPE=auto #(17)\n      - VPN_HEALTHCHECK_ENABLED=false #(20)\n      - VPN_NAMESERVERS= #(16)\n      - PRIVOXY_ENABLED=false #(19)\n      - UNBOUND_ENABLED=false #(21)\n      - UNBOUND_NAMESERVERS #(22)\n    cap_add:\n      - NET_ADMIN\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1 #(12)\n      - net.ipv6.conf.all.disable_ipv6=1 #(3)\n    devices:\n      - /dev/net/tun:/dev/net/tun # OPTIONAL(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui. On MacOS set it to <code>192.168.65.0/24</code> (Verify with your settings [Resources &gt; Network &gt; Docker subnet]).</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>. Affiliate links: Proton VPN Proton Unlimited Private Internet Access</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> (for PIA this is done automatically, see <code>VPN_PROVIDER</code> variable) located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32 in most cases\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>DANGEROUS! Don't enable unless you know what you are doing!</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>Some of the possible values are for example <code>wg</code>, <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>wg</code> will use the nameservers from the <code>wg0.conf</code> file. A value in the format <code>8.8.8.8</code> is to use a plain old nameserver. A value in the format <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>If you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice.</p> </li> <li> <p>This will start Privoxy on the default port 8118 when set to <code>true</code>. By default Privoxy is not exposed on the LAN, so if you need that, you'll have to add <code>VPN_EXPOSE_PORTS_ON_LAN=8118/tcp,8118/udp</code>.</p> </li> <li> <p>Enabling this will bring down the container if the connectivity tests fail at the end of the Wireguard init process or for an extended period during the container runtime.</p> </li> <li> <p>Enable Unbound by setting to <code>true</code> when VPN is not active.</p> </li> <li> <p>Possible values are <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>8.8.8.8</code> is to use a plain old nameserver. The value <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> </ol> clicompose <pre><code>docker run --rm \\\n    --hostname container-name.internal \\ #(18)\n    -e VPN_ENABLED=\"true\" \\ #(5)\n    -e VPN_CONF=\"wg0\" \\ #(8)\n    -e VPN_PROVIDER=\"pia\" \\ #(4)\n    -e VPN_LAN_NETWORK=\"192.168.1.0/24\" \\ #(1)\n    -e VPN_LAN_LEAK_ENABLED=\"false\" \\ #(10)\n    -e VPN_EXPOSE_PORTS_ON_LAN=\"\" \\ #(2)\n    -e VPN_AUTO_PORT_FORWARD=\"true\" \\ #(6)\n    -e VPN_AUTO_PORT_FORWARD_TO_PORTS=\"\" \\ #(15)\n    -e VPN_FIREWALL_TYPE=\"auto\" \\ #(17)\n    -e VPN_HEALTHCHECK_ENABLED=\"false\" \\ #(20)\n    -e VPN_NAMESERVERS=\"\" \\ #(16)\n    -e VPN_PIA_USER=\"\" \\ #(11)\n    -e VPN_PIA_PASS=\"\" \\ #(11)\n    -e VPN_PIA_PREFERRED_REGION=\"\" \\ #(7)\n    -e VPN_PIA_DIP_TOKEN=\"no\" \\ #(13)\n    -e VPN_PIA_PORT_FORWARD_PERSIST=\"false\" \\ #(14)\n    -e PRIVOXY_ENABLED=\"false\" \\ #(19)\n    -e UNBOUND_ENABLED=\"false\" \\ #(21)\n    -e UNBOUND_NAMESERVERS=\"\" \\ #(22)\n    --cap-add=NET_ADMIN \\\n    --sysctl=\"net.ipv4.conf.all.src_valid_mark=1\" \\ #(12)\n    --sysctl=\"net.ipv6.conf.all.disable_ipv6=1\" \\ #(3)\n    --device /dev/net/tun:/dev/net/tun \\ # OPTIONAL(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui. On MacOS set it to <code>192.168.65.0/24</code> (Verify with your settings [Resources &gt; Network &gt; Docker subnet]).</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>. Affiliate links: Proton VPN Proton Unlimited Private Internet Access</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> (for PIA this is done automatically, see <code>VPN_PROVIDER</code> variable) located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32 in most cases\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>DANGEROUS! Don't enable unless you know what you are doing!</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>Some of the possible values are for example <code>wg</code>, <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>wg</code> will use the nameservers from the <code>wg0.conf</code> file. A value in the format <code>8.8.8.8</code> is to use a plain old nameserver. A value in the format <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>If you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice.</p> </li> <li> <p>This will start Privoxy on the default port 8118 when set to <code>true</code>. By default Privoxy is not exposed on the LAN, so if you need that, you'll have to add <code>VPN_EXPOSE_PORTS_ON_LAN=8118/tcp,8118/udp</code>.</p> </li> <li> <p>Enabling this will bring down the container if the connectivity tests fail at the end of the Wireguard init process or for an extended period during the container runtime.</p> </li> <li> <p>Enable Unbound by setting to <code>true</code> when VPN is not active.</p> </li> <li> <p>Possible values are <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>8.8.8.8</code> is to use a plain old nameserver. The value <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> </ol> <pre><code>services:\n  app:\n    hostname: container-name.internal #(18)\n    environment:\n      - VPN_ENABLED=true #(5)\n      - VPN_CONF=wg0 #(8)\n      - VPN_PROVIDER=pia #(4)\n      - VPN_LAN_NETWORK=192.168.1.0/24 #(1)\n      - VPN_LAN_LEAK_ENABLED=false #(10)\n      - VPN_EXPOSE_PORTS_ON_LAN #(2)\n      - VPN_AUTO_PORT_FORWARD=true #(6)\n      - VPN_AUTO_PORT_FORWARD_TO_PORTS= #(15)\n      - VPN_FIREWALL_TYPE=auto #(17)\n      - VPN_HEALTHCHECK_ENABLED=false #(20)\n      - VPN_NAMESERVERS= #(16)\n      - VPN_PIA_USER #(11)\n      - VPN_PIA_PASS #(11)\n      - VPN_PIA_PREFERRED_REGION #(7)\n      - VPN_PIA_DIP_TOKEN=no #(13)\n      - VPN_PIA_PORT_FORWARD_PERSIST=false #(14)\n      - PRIVOXY_ENABLED=false #(19)\n      - UNBOUND_ENABLED=false #(21)\n      - UNBOUND_NAMESERVERS #(22)\n    cap_add:\n      - NET_ADMIN\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1 #(12)\n      - net.ipv6.conf.all.disable_ipv6=1 #(3)\n    devices:\n      - /dev/net/tun:/dev/net/tun # OPTIONAL(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui. On MacOS set it to <code>192.168.65.0/24</code> (Verify with your settings [Resources &gt; Network &gt; Docker subnet]).</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>. Affiliate links: Proton VPN Proton Unlimited Private Internet Access</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> (for PIA this is done automatically, see <code>VPN_PROVIDER</code> variable) located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32 in most cases\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>DANGEROUS! Don't enable unless you know what you are doing!</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>Some of the possible values are for example <code>wg</code>, <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>wg</code> will use the nameservers from the <code>wg0.conf</code> file. A value in the format <code>8.8.8.8</code> is to use a plain old nameserver. A value in the format <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>If you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice.</p> </li> <li> <p>This will start Privoxy on the default port 8118 when set to <code>true</code>. By default Privoxy is not exposed on the LAN, so if you need that, you'll have to add <code>VPN_EXPOSE_PORTS_ON_LAN=8118/tcp,8118/udp</code>.</p> </li> <li> <p>Enabling this will bring down the container if the connectivity tests fail at the end of the Wireguard init process or for an extended period during the container runtime.</p> </li> <li> <p>Enable Unbound by setting to <code>true</code> when VPN is not active.</p> </li> <li> <p>Possible values are <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>8.8.8.8</code> is to use a plain old nameserver. The value <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> </ol>"},{"location":"containers/jackett/","title":"hotio/jackett","text":"<p> GitHub ghcr.io</p>"},{"location":"containers/jackett/#starting-the-container","title":"Starting the container","text":"clicompose <pre><code>docker run --rm \\\n    --name jackett \\\n    -p 9117:9117 \\\n    -e PUID=1000 \\\n    -e PGID=1000 \\\n    -e UMASK=002 \\\n    -e TZ=\"Etc/UTC\" \\\n    -v /&lt;host_folder_config&gt;:/config \\\n    ghcr.io/hotio/jackett\n</code></pre> <pre><code>services:\n  jackett:\n    container_name: jackett\n    image: ghcr.io/hotio/jackett\n    ports:\n      - \"9117:9117\"\n    environment:\n      - PUID=1000\n      - PGID=1000\n      - UMASK=002\n      - TZ=Etc/UTC\n    volumes:\n      - /&lt;host_folder_config&gt;:/config\n</code></pre>"},{"location":"containers/jackett/#tags","title":"Tags","text":"Tags Description Last Updated Age"},{"location":"containers/jackett/#wireguard","title":"WireGuard","text":"<p>Info</p> <p>This image includes VPN support. The cli/compose examples below are environment variables and settings complementary to the app image examples, this means you'll have to add/merge the stuff below with the stuff above. In case you are still in need of a VPN, consider using my affiliate links for Proton VPN, Proton Unlimited or Private Internet Access.</p> <p> </p> genericprotonpia clicompose <pre><code>docker run --rm \\\n    --hostname container-name.internal \\ #(18)\n    -e VPN_ENABLED=\"true\" \\ #(5)\n    -e VPN_CONF=\"wg0\" \\ #(8)\n    -e VPN_PROVIDER=\"generic\" \\ #(4)\n    -e VPN_LAN_NETWORK=\"192.168.1.0/24\" \\ #(1)\n    -e VPN_LAN_LEAK_ENABLED=\"false\" \\ #(10)\n    -e VPN_EXPOSE_PORTS_ON_LAN=\"\" \\ #(2)\n    -e VPN_AUTO_PORT_FORWARD=\"false\" \\ #(6)\n    -e VPN_AUTO_PORT_FORWARD_TO_PORTS=\"\" \\ #(15)\n    -e VPN_FIREWALL_TYPE=\"auto\" \\ #(17)\n    -e VPN_HEALTHCHECK_ENABLED=\"false\" \\ #(20)\n    -e VPN_NAMESERVERS=\"\" \\ #(16)\n    -e PRIVOXY_ENABLED=\"false\" \\ #(19)\n    -e UNBOUND_ENABLED=\"false\" \\ #(21)\n    -e UNBOUND_NAMESERVERS=\"\" \\ #(22)\n    --cap-add=NET_ADMIN \\\n    --sysctl=\"net.ipv4.conf.all.src_valid_mark=1\" \\ #(12)\n    --sysctl=\"net.ipv6.conf.all.disable_ipv6=1\" \\ #(3)\n    --device /dev/net/tun:/dev/net/tun \\ # OPTIONAL(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui. On MacOS set it to <code>192.168.65.0/24</code> (Verify with your settings [Resources &gt; Network &gt; Docker subnet]).</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>. Affiliate links: Proton VPN Proton Unlimited Private Internet Access</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> (for PIA this is done automatically, see <code>VPN_PROVIDER</code> variable) located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32 in most cases\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>DANGEROUS! Don't enable unless you know what you are doing!</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>Some of the possible values are for example <code>wg</code>, <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>wg</code> will use the nameservers from the <code>wg0.conf</code> file. A value in the format <code>8.8.8.8</code> is to use a plain old nameserver. A value in the format <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>If you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice.</p> </li> <li> <p>This will start Privoxy on the default port 8118 when set to <code>true</code>. By default Privoxy is not exposed on the LAN, so if you need that, you'll have to add <code>VPN_EXPOSE_PORTS_ON_LAN=8118/tcp,8118/udp</code>.</p> </li> <li> <p>Enabling this will bring down the container if the connectivity tests fail at the end of the Wireguard init process or for an extended period during the container runtime.</p> </li> <li> <p>Enable Unbound by setting to <code>true</code> when VPN is not active.</p> </li> <li> <p>Possible values are <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>8.8.8.8</code> is to use a plain old nameserver. The value <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> </ol> <pre><code>services:\n  app:\n    hostname: container-name.internal #(18)\n    environment:\n      - VPN_ENABLED=true #(5)\n      - VPN_CONF=wg0 #(8)\n      - VPN_PROVIDER=generic #(4)\n      - VPN_LAN_NETWORK=192.168.1.0/24 #(1)\n      - VPN_LAN_LEAK_ENABLED=false #(10)\n      - VPN_EXPOSE_PORTS_ON_LAN #(2)\n      - VPN_AUTO_PORT_FORWARD=false #(6)\n      - VPN_AUTO_PORT_FORWARD_TO_PORTS= #(15)\n      - VPN_FIREWALL_TYPE=auto #(17)\n      - VPN_HEALTHCHECK_ENABLED=false #(20)\n      - VPN_NAMESERVERS= #(16)\n      - PRIVOXY_ENABLED=false #(19)\n      - UNBOUND_ENABLED=false #(21)\n      - UNBOUND_NAMESERVERS #(22)\n    cap_add:\n      - NET_ADMIN\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1 #(12)\n      - net.ipv6.conf.all.disable_ipv6=1 #(3)\n    devices:\n      - /dev/net/tun:/dev/net/tun # OPTIONAL(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui. On MacOS set it to <code>192.168.65.0/24</code> (Verify with your settings [Resources &gt; Network &gt; Docker subnet]).</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>. Affiliate links: Proton VPN Proton Unlimited Private Internet Access</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> (for PIA this is done automatically, see <code>VPN_PROVIDER</code> variable) located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32 in most cases\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>DANGEROUS! Don't enable unless you know what you are doing!</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>Some of the possible values are for example <code>wg</code>, <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>wg</code> will use the nameservers from the <code>wg0.conf</code> file. A value in the format <code>8.8.8.8</code> is to use a plain old nameserver. A value in the format <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>If you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice.</p> </li> <li> <p>This will start Privoxy on the default port 8118 when set to <code>true</code>. By default Privoxy is not exposed on the LAN, so if you need that, you'll have to add <code>VPN_EXPOSE_PORTS_ON_LAN=8118/tcp,8118/udp</code>.</p> </li> <li> <p>Enabling this will bring down the container if the connectivity tests fail at the end of the Wireguard init process or for an extended period during the container runtime.</p> </li> <li> <p>Enable Unbound by setting to <code>true</code> when VPN is not active.</p> </li> <li> <p>Possible values are <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>8.8.8.8</code> is to use a plain old nameserver. The value <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> </ol> clicompose <pre><code>docker run --rm \\\n    --hostname container-name.internal \\ #(18)\n    -e VPN_ENABLED=\"true\" \\ #(5)\n    -e VPN_CONF=\"wg0\" \\ #(8)\n    -e VPN_PROVIDER=\"proton\" \\ #(4)\n    -e VPN_LAN_NETWORK=\"192.168.1.0/24\" \\ #(1)\n    -e VPN_LAN_LEAK_ENABLED=\"false\" \\ #(10)\n    -e VPN_EXPOSE_PORTS_ON_LAN=\"\" \\ #(2)\n    -e VPN_AUTO_PORT_FORWARD=\"true\" \\ #(6)\n    -e VPN_AUTO_PORT_FORWARD_TO_PORTS=\"\" \\ #(15)\n    -e VPN_FIREWALL_TYPE=\"auto\" \\ #(17)\n    -e VPN_HEALTHCHECK_ENABLED=\"false\" \\ #(20)\n    -e VPN_NAMESERVERS=\"\" \\ #(16)\n    -e PRIVOXY_ENABLED=\"false\" \\ #(19)\n    -e UNBOUND_ENABLED=\"false\" \\ #(21)\n    -e UNBOUND_NAMESERVERS=\"\" \\ #(22)\n    --cap-add=NET_ADMIN \\\n    --sysctl=\"net.ipv4.conf.all.src_valid_mark=1\" \\ #(12)\n    --sysctl=\"net.ipv6.conf.all.disable_ipv6=1\" \\ #(3)\n    --device /dev/net/tun:/dev/net/tun \\ # OPTIONAL(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui. On MacOS set it to <code>192.168.65.0/24</code> (Verify with your settings [Resources &gt; Network &gt; Docker subnet]).</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>. Affiliate links: Proton VPN Proton Unlimited Private Internet Access</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> (for PIA this is done automatically, see <code>VPN_PROVIDER</code> variable) located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32 in most cases\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>DANGEROUS! Don't enable unless you know what you are doing!</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>Some of the possible values are for example <code>wg</code>, <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>wg</code> will use the nameservers from the <code>wg0.conf</code> file. A value in the format <code>8.8.8.8</code> is to use a plain old nameserver. A value in the format <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>If you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice.</p> </li> <li> <p>This will start Privoxy on the default port 8118 when set to <code>true</code>. By default Privoxy is not exposed on the LAN, so if you need that, you'll have to add <code>VPN_EXPOSE_PORTS_ON_LAN=8118/tcp,8118/udp</code>.</p> </li> <li> <p>Enabling this will bring down the container if the connectivity tests fail at the end of the Wireguard init process or for an extended period during the container runtime.</p> </li> <li> <p>Enable Unbound by setting to <code>true</code> when VPN is not active.</p> </li> <li> <p>Possible values are <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>8.8.8.8</code> is to use a plain old nameserver. The value <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> </ol> <pre><code>services:\n  app:\n    hostname: container-name.internal #(18)\n    environment:\n      - VPN_ENABLED=true #(5)\n      - VPN_CONF=wg0 #(8)\n      - VPN_PROVIDER=proton #(4)\n      - VPN_LAN_NETWORK=192.168.1.0/24 #(1)\n      - VPN_LAN_LEAK_ENABLED=false #(10)\n      - VPN_EXPOSE_PORTS_ON_LAN #(2)\n      - VPN_AUTO_PORT_FORWARD=true #(6)\n      - VPN_AUTO_PORT_FORWARD_TO_PORTS= #(15)\n      - VPN_FIREWALL_TYPE=auto #(17)\n      - VPN_HEALTHCHECK_ENABLED=false #(20)\n      - VPN_NAMESERVERS= #(16)\n      - PRIVOXY_ENABLED=false #(19)\n      - UNBOUND_ENABLED=false #(21)\n      - UNBOUND_NAMESERVERS #(22)\n    cap_add:\n      - NET_ADMIN\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1 #(12)\n      - net.ipv6.conf.all.disable_ipv6=1 #(3)\n    devices:\n      - /dev/net/tun:/dev/net/tun # OPTIONAL(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui. On MacOS set it to <code>192.168.65.0/24</code> (Verify with your settings [Resources &gt; Network &gt; Docker subnet]).</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>. Affiliate links: Proton VPN Proton Unlimited Private Internet Access</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> (for PIA this is done automatically, see <code>VPN_PROVIDER</code> variable) located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32 in most cases\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>DANGEROUS! Don't enable unless you know what you are doing!</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>Some of the possible values are for example <code>wg</code>, <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>wg</code> will use the nameservers from the <code>wg0.conf</code> file. A value in the format <code>8.8.8.8</code> is to use a plain old nameserver. A value in the format <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>If you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice.</p> </li> <li> <p>This will start Privoxy on the default port 8118 when set to <code>true</code>. By default Privoxy is not exposed on the LAN, so if you need that, you'll have to add <code>VPN_EXPOSE_PORTS_ON_LAN=8118/tcp,8118/udp</code>.</p> </li> <li> <p>Enabling this will bring down the container if the connectivity tests fail at the end of the Wireguard init process or for an extended period during the container runtime.</p> </li> <li> <p>Enable Unbound by setting to <code>true</code> when VPN is not active.</p> </li> <li> <p>Possible values are <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>8.8.8.8</code> is to use a plain old nameserver. The value <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> </ol> clicompose <pre><code>docker run --rm \\\n    --hostname container-name.internal \\ #(18)\n    -e VPN_ENABLED=\"true\" \\ #(5)\n    -e VPN_CONF=\"wg0\" \\ #(8)\n    -e VPN_PROVIDER=\"pia\" \\ #(4)\n    -e VPN_LAN_NETWORK=\"192.168.1.0/24\" \\ #(1)\n    -e VPN_LAN_LEAK_ENABLED=\"false\" \\ #(10)\n    -e VPN_EXPOSE_PORTS_ON_LAN=\"\" \\ #(2)\n    -e VPN_AUTO_PORT_FORWARD=\"true\" \\ #(6)\n    -e VPN_AUTO_PORT_FORWARD_TO_PORTS=\"\" \\ #(15)\n    -e VPN_FIREWALL_TYPE=\"auto\" \\ #(17)\n    -e VPN_HEALTHCHECK_ENABLED=\"false\" \\ #(20)\n    -e VPN_NAMESERVERS=\"\" \\ #(16)\n    -e VPN_PIA_USER=\"\" \\ #(11)\n    -e VPN_PIA_PASS=\"\" \\ #(11)\n    -e VPN_PIA_PREFERRED_REGION=\"\" \\ #(7)\n    -e VPN_PIA_DIP_TOKEN=\"no\" \\ #(13)\n    -e VPN_PIA_PORT_FORWARD_PERSIST=\"false\" \\ #(14)\n    -e PRIVOXY_ENABLED=\"false\" \\ #(19)\n    -e UNBOUND_ENABLED=\"false\" \\ #(21)\n    -e UNBOUND_NAMESERVERS=\"\" \\ #(22)\n    --cap-add=NET_ADMIN \\\n    --sysctl=\"net.ipv4.conf.all.src_valid_mark=1\" \\ #(12)\n    --sysctl=\"net.ipv6.conf.all.disable_ipv6=1\" \\ #(3)\n    --device /dev/net/tun:/dev/net/tun \\ # OPTIONAL(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui. On MacOS set it to <code>192.168.65.0/24</code> (Verify with your settings [Resources &gt; Network &gt; Docker subnet]).</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>. Affiliate links: Proton VPN Proton Unlimited Private Internet Access</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> (for PIA this is done automatically, see <code>VPN_PROVIDER</code> variable) located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32 in most cases\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>DANGEROUS! Don't enable unless you know what you are doing!</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>Some of the possible values are for example <code>wg</code>, <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>wg</code> will use the nameservers from the <code>wg0.conf</code> file. A value in the format <code>8.8.8.8</code> is to use a plain old nameserver. A value in the format <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>If you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice.</p> </li> <li> <p>This will start Privoxy on the default port 8118 when set to <code>true</code>. By default Privoxy is not exposed on the LAN, so if you need that, you'll have to add <code>VPN_EXPOSE_PORTS_ON_LAN=8118/tcp,8118/udp</code>.</p> </li> <li> <p>Enabling this will bring down the container if the connectivity tests fail at the end of the Wireguard init process or for an extended period during the container runtime.</p> </li> <li> <p>Enable Unbound by setting to <code>true</code> when VPN is not active.</p> </li> <li> <p>Possible values are <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>8.8.8.8</code> is to use a plain old nameserver. The value <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> </ol> <pre><code>services:\n  app:\n    hostname: container-name.internal #(18)\n    environment:\n      - VPN_ENABLED=true #(5)\n      - VPN_CONF=wg0 #(8)\n      - VPN_PROVIDER=pia #(4)\n      - VPN_LAN_NETWORK=192.168.1.0/24 #(1)\n      - VPN_LAN_LEAK_ENABLED=false #(10)\n      - VPN_EXPOSE_PORTS_ON_LAN #(2)\n      - VPN_AUTO_PORT_FORWARD=true #(6)\n      - VPN_AUTO_PORT_FORWARD_TO_PORTS= #(15)\n      - VPN_FIREWALL_TYPE=auto #(17)\n      - VPN_HEALTHCHECK_ENABLED=false #(20)\n      - VPN_NAMESERVERS= #(16)\n      - VPN_PIA_USER #(11)\n      - VPN_PIA_PASS #(11)\n      - VPN_PIA_PREFERRED_REGION #(7)\n      - VPN_PIA_DIP_TOKEN=no #(13)\n      - VPN_PIA_PORT_FORWARD_PERSIST=false #(14)\n      - PRIVOXY_ENABLED=false #(19)\n      - UNBOUND_ENABLED=false #(21)\n      - UNBOUND_NAMESERVERS #(22)\n    cap_add:\n      - NET_ADMIN\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1 #(12)\n      - net.ipv6.conf.all.disable_ipv6=1 #(3)\n    devices:\n      - /dev/net/tun:/dev/net/tun # OPTIONAL(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui. On MacOS set it to <code>192.168.65.0/24</code> (Verify with your settings [Resources &gt; Network &gt; Docker subnet]).</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>. Affiliate links: Proton VPN Proton Unlimited Private Internet Access</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> (for PIA this is done automatically, see <code>VPN_PROVIDER</code> variable) located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32 in most cases\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>DANGEROUS! Don't enable unless you know what you are doing!</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>Some of the possible values are for example <code>wg</code>, <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>wg</code> will use the nameservers from the <code>wg0.conf</code> file. A value in the format <code>8.8.8.8</code> is to use a plain old nameserver. A value in the format <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>If you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice.</p> </li> <li> <p>This will start Privoxy on the default port 8118 when set to <code>true</code>. By default Privoxy is not exposed on the LAN, so if you need that, you'll have to add <code>VPN_EXPOSE_PORTS_ON_LAN=8118/tcp,8118/udp</code>.</p> </li> <li> <p>Enabling this will bring down the container if the connectivity tests fail at the end of the Wireguard init process or for an extended period during the container runtime.</p> </li> <li> <p>Enable Unbound by setting to <code>true</code> when VPN is not active.</p> </li> <li> <p>Possible values are <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>8.8.8.8</code> is to use a plain old nameserver. The value <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> </ol>"},{"location":"containers/jellyfin/","title":"hotio/jellyfin","text":"<p> GitHub ghcr.io</p>"},{"location":"containers/jellyfin/#starting-the-container","title":"Starting the container","text":"clicompose <pre><code>docker run --rm \\\n    --name jellyfin \\\n    -p 8096:8096 \\\n    -e PUID=1000 \\\n    -e PGID=1000 \\\n    -e UMASK=002 \\\n    -e TZ=\"Etc/UTC\" \\\n    -v /&lt;host_folder_config&gt;:/config \\\n    -v /&lt;host_folder_data&gt;:/data \\\n    ghcr.io/hotio/jellyfin\n</code></pre> <pre><code>services:\n  jellyfin:\n    container_name: jellyfin\n    image: ghcr.io/hotio/jellyfin\n    ports:\n      - \"8096:8096\"\n    environment:\n      - PUID=1000\n      - PGID=1000\n      - UMASK=002\n      - TZ=Etc/UTC\n    volumes:\n      - /&lt;host_folder_config&gt;:/config\n      - /&lt;host_folder_data&gt;:/data\n</code></pre>"},{"location":"containers/jellyfin/#tags","title":"Tags","text":"Tags Description Last Updated Age"},{"location":"containers/jellyfin/#configuration","title":"Configuration","text":"<p>The following jellyfin path locations are used by default.</p> <pre><code>JELLYFIN_CONFIG_DIR=\"/config\"\nJELLYFIN_DATA_DIR=\"/config/data\"\nJELLYFIN_LOG_DIR=\"/config/log\"\nJELLYFIN_CACHE_DIR=\"/config/cache\"\n</code></pre> <p>You can override these locations by setting them to a different value with a docker environment variable.</p>"},{"location":"containers/jellyfin/#wireguard","title":"WireGuard","text":"<p>Info</p> <p>This image includes VPN support. The cli/compose examples below are environment variables and settings complementary to the app image examples, this means you'll have to add/merge the stuff below with the stuff above. In case you are still in need of a VPN, consider using my affiliate links for Proton VPN, Proton Unlimited or Private Internet Access.</p> <p> </p> genericprotonpia clicompose <pre><code>docker run --rm \\\n    --hostname container-name.internal \\ #(18)\n    -e VPN_ENABLED=\"true\" \\ #(5)\n    -e VPN_CONF=\"wg0\" \\ #(8)\n    -e VPN_PROVIDER=\"generic\" \\ #(4)\n    -e VPN_LAN_NETWORK=\"192.168.1.0/24\" \\ #(1)\n    -e VPN_LAN_LEAK_ENABLED=\"false\" \\ #(10)\n    -e VPN_EXPOSE_PORTS_ON_LAN=\"\" \\ #(2)\n    -e VPN_AUTO_PORT_FORWARD=\"false\" \\ #(6)\n    -e VPN_AUTO_PORT_FORWARD_TO_PORTS=\"\" \\ #(15)\n    -e VPN_FIREWALL_TYPE=\"auto\" \\ #(17)\n    -e VPN_HEALTHCHECK_ENABLED=\"false\" \\ #(20)\n    -e VPN_NAMESERVERS=\"\" \\ #(16)\n    -e PRIVOXY_ENABLED=\"false\" \\ #(19)\n    -e UNBOUND_ENABLED=\"false\" \\ #(21)\n    -e UNBOUND_NAMESERVERS=\"\" \\ #(22)\n    --cap-add=NET_ADMIN \\\n    --sysctl=\"net.ipv4.conf.all.src_valid_mark=1\" \\ #(12)\n    --sysctl=\"net.ipv6.conf.all.disable_ipv6=1\" \\ #(3)\n    --device /dev/net/tun:/dev/net/tun \\ # OPTIONAL(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui. On MacOS set it to <code>192.168.65.0/24</code> (Verify with your settings [Resources &gt; Network &gt; Docker subnet]).</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>. Affiliate links: Proton VPN Proton Unlimited Private Internet Access</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> (for PIA this is done automatically, see <code>VPN_PROVIDER</code> variable) located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32 in most cases\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>DANGEROUS! Don't enable unless you know what you are doing!</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>Some of the possible values are for example <code>wg</code>, <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>wg</code> will use the nameservers from the <code>wg0.conf</code> file. A value in the format <code>8.8.8.8</code> is to use a plain old nameserver. A value in the format <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>If you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice.</p> </li> <li> <p>This will start Privoxy on the default port 8118 when set to <code>true</code>. By default Privoxy is not exposed on the LAN, so if you need that, you'll have to add <code>VPN_EXPOSE_PORTS_ON_LAN=8118/tcp,8118/udp</code>.</p> </li> <li> <p>Enabling this will bring down the container if the connectivity tests fail at the end of the Wireguard init process or for an extended period during the container runtime.</p> </li> <li> <p>Enable Unbound by setting to <code>true</code> when VPN is not active.</p> </li> <li> <p>Possible values are <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>8.8.8.8</code> is to use a plain old nameserver. The value <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> </ol> <pre><code>services:\n  app:\n    hostname: container-name.internal #(18)\n    environment:\n      - VPN_ENABLED=true #(5)\n      - VPN_CONF=wg0 #(8)\n      - VPN_PROVIDER=generic #(4)\n      - VPN_LAN_NETWORK=192.168.1.0/24 #(1)\n      - VPN_LAN_LEAK_ENABLED=false #(10)\n      - VPN_EXPOSE_PORTS_ON_LAN #(2)\n      - VPN_AUTO_PORT_FORWARD=false #(6)\n      - VPN_AUTO_PORT_FORWARD_TO_PORTS= #(15)\n      - VPN_FIREWALL_TYPE=auto #(17)\n      - VPN_HEALTHCHECK_ENABLED=false #(20)\n      - VPN_NAMESERVERS= #(16)\n      - PRIVOXY_ENABLED=false #(19)\n      - UNBOUND_ENABLED=false #(21)\n      - UNBOUND_NAMESERVERS #(22)\n    cap_add:\n      - NET_ADMIN\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1 #(12)\n      - net.ipv6.conf.all.disable_ipv6=1 #(3)\n    devices:\n      - /dev/net/tun:/dev/net/tun # OPTIONAL(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui. On MacOS set it to <code>192.168.65.0/24</code> (Verify with your settings [Resources &gt; Network &gt; Docker subnet]).</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>. Affiliate links: Proton VPN Proton Unlimited Private Internet Access</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> (for PIA this is done automatically, see <code>VPN_PROVIDER</code> variable) located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32 in most cases\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>DANGEROUS! Don't enable unless you know what you are doing!</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>Some of the possible values are for example <code>wg</code>, <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>wg</code> will use the nameservers from the <code>wg0.conf</code> file. A value in the format <code>8.8.8.8</code> is to use a plain old nameserver. A value in the format <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>If you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice.</p> </li> <li> <p>This will start Privoxy on the default port 8118 when set to <code>true</code>. By default Privoxy is not exposed on the LAN, so if you need that, you'll have to add <code>VPN_EXPOSE_PORTS_ON_LAN=8118/tcp,8118/udp</code>.</p> </li> <li> <p>Enabling this will bring down the container if the connectivity tests fail at the end of the Wireguard init process or for an extended period during the container runtime.</p> </li> <li> <p>Enable Unbound by setting to <code>true</code> when VPN is not active.</p> </li> <li> <p>Possible values are <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>8.8.8.8</code> is to use a plain old nameserver. The value <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> </ol> clicompose <pre><code>docker run --rm \\\n    --hostname container-name.internal \\ #(18)\n    -e VPN_ENABLED=\"true\" \\ #(5)\n    -e VPN_CONF=\"wg0\" \\ #(8)\n    -e VPN_PROVIDER=\"proton\" \\ #(4)\n    -e VPN_LAN_NETWORK=\"192.168.1.0/24\" \\ #(1)\n    -e VPN_LAN_LEAK_ENABLED=\"false\" \\ #(10)\n    -e VPN_EXPOSE_PORTS_ON_LAN=\"\" \\ #(2)\n    -e VPN_AUTO_PORT_FORWARD=\"true\" \\ #(6)\n    -e VPN_AUTO_PORT_FORWARD_TO_PORTS=\"\" \\ #(15)\n    -e VPN_FIREWALL_TYPE=\"auto\" \\ #(17)\n    -e VPN_HEALTHCHECK_ENABLED=\"false\" \\ #(20)\n    -e VPN_NAMESERVERS=\"\" \\ #(16)\n    -e PRIVOXY_ENABLED=\"false\" \\ #(19)\n    -e UNBOUND_ENABLED=\"false\" \\ #(21)\n    -e UNBOUND_NAMESERVERS=\"\" \\ #(22)\n    --cap-add=NET_ADMIN \\\n    --sysctl=\"net.ipv4.conf.all.src_valid_mark=1\" \\ #(12)\n    --sysctl=\"net.ipv6.conf.all.disable_ipv6=1\" \\ #(3)\n    --device /dev/net/tun:/dev/net/tun \\ # OPTIONAL(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui. On MacOS set it to <code>192.168.65.0/24</code> (Verify with your settings [Resources &gt; Network &gt; Docker subnet]).</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>. Affiliate links: Proton VPN Proton Unlimited Private Internet Access</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> (for PIA this is done automatically, see <code>VPN_PROVIDER</code> variable) located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32 in most cases\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>DANGEROUS! Don't enable unless you know what you are doing!</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>Some of the possible values are for example <code>wg</code>, <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>wg</code> will use the nameservers from the <code>wg0.conf</code> file. A value in the format <code>8.8.8.8</code> is to use a plain old nameserver. A value in the format <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>If you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice.</p> </li> <li> <p>This will start Privoxy on the default port 8118 when set to <code>true</code>. By default Privoxy is not exposed on the LAN, so if you need that, you'll have to add <code>VPN_EXPOSE_PORTS_ON_LAN=8118/tcp,8118/udp</code>.</p> </li> <li> <p>Enabling this will bring down the container if the connectivity tests fail at the end of the Wireguard init process or for an extended period during the container runtime.</p> </li> <li> <p>Enable Unbound by setting to <code>true</code> when VPN is not active.</p> </li> <li> <p>Possible values are <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>8.8.8.8</code> is to use a plain old nameserver. The value <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> </ol> <pre><code>services:\n  app:\n    hostname: container-name.internal #(18)\n    environment:\n      - VPN_ENABLED=true #(5)\n      - VPN_CONF=wg0 #(8)\n      - VPN_PROVIDER=proton #(4)\n      - VPN_LAN_NETWORK=192.168.1.0/24 #(1)\n      - VPN_LAN_LEAK_ENABLED=false #(10)\n      - VPN_EXPOSE_PORTS_ON_LAN #(2)\n      - VPN_AUTO_PORT_FORWARD=true #(6)\n      - VPN_AUTO_PORT_FORWARD_TO_PORTS= #(15)\n      - VPN_FIREWALL_TYPE=auto #(17)\n      - VPN_HEALTHCHECK_ENABLED=false #(20)\n      - VPN_NAMESERVERS= #(16)\n      - PRIVOXY_ENABLED=false #(19)\n      - UNBOUND_ENABLED=false #(21)\n      - UNBOUND_NAMESERVERS #(22)\n    cap_add:\n      - NET_ADMIN\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1 #(12)\n      - net.ipv6.conf.all.disable_ipv6=1 #(3)\n    devices:\n      - /dev/net/tun:/dev/net/tun # OPTIONAL(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui. On MacOS set it to <code>192.168.65.0/24</code> (Verify with your settings [Resources &gt; Network &gt; Docker subnet]).</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>. Affiliate links: Proton VPN Proton Unlimited Private Internet Access</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> (for PIA this is done automatically, see <code>VPN_PROVIDER</code> variable) located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32 in most cases\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>DANGEROUS! Don't enable unless you know what you are doing!</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>Some of the possible values are for example <code>wg</code>, <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>wg</code> will use the nameservers from the <code>wg0.conf</code> file. A value in the format <code>8.8.8.8</code> is to use a plain old nameserver. A value in the format <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>If you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice.</p> </li> <li> <p>This will start Privoxy on the default port 8118 when set to <code>true</code>. By default Privoxy is not exposed on the LAN, so if you need that, you'll have to add <code>VPN_EXPOSE_PORTS_ON_LAN=8118/tcp,8118/udp</code>.</p> </li> <li> <p>Enabling this will bring down the container if the connectivity tests fail at the end of the Wireguard init process or for an extended period during the container runtime.</p> </li> <li> <p>Enable Unbound by setting to <code>true</code> when VPN is not active.</p> </li> <li> <p>Possible values are <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>8.8.8.8</code> is to use a plain old nameserver. The value <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> </ol> clicompose <pre><code>docker run --rm \\\n    --hostname container-name.internal \\ #(18)\n    -e VPN_ENABLED=\"true\" \\ #(5)\n    -e VPN_CONF=\"wg0\" \\ #(8)\n    -e VPN_PROVIDER=\"pia\" \\ #(4)\n    -e VPN_LAN_NETWORK=\"192.168.1.0/24\" \\ #(1)\n    -e VPN_LAN_LEAK_ENABLED=\"false\" \\ #(10)\n    -e VPN_EXPOSE_PORTS_ON_LAN=\"\" \\ #(2)\n    -e VPN_AUTO_PORT_FORWARD=\"true\" \\ #(6)\n    -e VPN_AUTO_PORT_FORWARD_TO_PORTS=\"\" \\ #(15)\n    -e VPN_FIREWALL_TYPE=\"auto\" \\ #(17)\n    -e VPN_HEALTHCHECK_ENABLED=\"false\" \\ #(20)\n    -e VPN_NAMESERVERS=\"\" \\ #(16)\n    -e VPN_PIA_USER=\"\" \\ #(11)\n    -e VPN_PIA_PASS=\"\" \\ #(11)\n    -e VPN_PIA_PREFERRED_REGION=\"\" \\ #(7)\n    -e VPN_PIA_DIP_TOKEN=\"no\" \\ #(13)\n    -e VPN_PIA_PORT_FORWARD_PERSIST=\"false\" \\ #(14)\n    -e PRIVOXY_ENABLED=\"false\" \\ #(19)\n    -e UNBOUND_ENABLED=\"false\" \\ #(21)\n    -e UNBOUND_NAMESERVERS=\"\" \\ #(22)\n    --cap-add=NET_ADMIN \\\n    --sysctl=\"net.ipv4.conf.all.src_valid_mark=1\" \\ #(12)\n    --sysctl=\"net.ipv6.conf.all.disable_ipv6=1\" \\ #(3)\n    --device /dev/net/tun:/dev/net/tun \\ # OPTIONAL(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui. On MacOS set it to <code>192.168.65.0/24</code> (Verify with your settings [Resources &gt; Network &gt; Docker subnet]).</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>. Affiliate links: Proton VPN Proton Unlimited Private Internet Access</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> (for PIA this is done automatically, see <code>VPN_PROVIDER</code> variable) located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32 in most cases\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>DANGEROUS! Don't enable unless you know what you are doing!</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>Some of the possible values are for example <code>wg</code>, <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>wg</code> will use the nameservers from the <code>wg0.conf</code> file. A value in the format <code>8.8.8.8</code> is to use a plain old nameserver. A value in the format <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>If you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice.</p> </li> <li> <p>This will start Privoxy on the default port 8118 when set to <code>true</code>. By default Privoxy is not exposed on the LAN, so if you need that, you'll have to add <code>VPN_EXPOSE_PORTS_ON_LAN=8118/tcp,8118/udp</code>.</p> </li> <li> <p>Enabling this will bring down the container if the connectivity tests fail at the end of the Wireguard init process or for an extended period during the container runtime.</p> </li> <li> <p>Enable Unbound by setting to <code>true</code> when VPN is not active.</p> </li> <li> <p>Possible values are <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>8.8.8.8</code> is to use a plain old nameserver. The value <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> </ol> <pre><code>services:\n  app:\n    hostname: container-name.internal #(18)\n    environment:\n      - VPN_ENABLED=true #(5)\n      - VPN_CONF=wg0 #(8)\n      - VPN_PROVIDER=pia #(4)\n      - VPN_LAN_NETWORK=192.168.1.0/24 #(1)\n      - VPN_LAN_LEAK_ENABLED=false #(10)\n      - VPN_EXPOSE_PORTS_ON_LAN #(2)\n      - VPN_AUTO_PORT_FORWARD=true #(6)\n      - VPN_AUTO_PORT_FORWARD_TO_PORTS= #(15)\n      - VPN_FIREWALL_TYPE=auto #(17)\n      - VPN_HEALTHCHECK_ENABLED=false #(20)\n      - VPN_NAMESERVERS= #(16)\n      - VPN_PIA_USER #(11)\n      - VPN_PIA_PASS #(11)\n      - VPN_PIA_PREFERRED_REGION #(7)\n      - VPN_PIA_DIP_TOKEN=no #(13)\n      - VPN_PIA_PORT_FORWARD_PERSIST=false #(14)\n      - PRIVOXY_ENABLED=false #(19)\n      - UNBOUND_ENABLED=false #(21)\n      - UNBOUND_NAMESERVERS #(22)\n    cap_add:\n      - NET_ADMIN\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1 #(12)\n      - net.ipv6.conf.all.disable_ipv6=1 #(3)\n    devices:\n      - /dev/net/tun:/dev/net/tun # OPTIONAL(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui. On MacOS set it to <code>192.168.65.0/24</code> (Verify with your settings [Resources &gt; Network &gt; Docker subnet]).</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>. Affiliate links: Proton VPN Proton Unlimited Private Internet Access</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> (for PIA this is done automatically, see <code>VPN_PROVIDER</code> variable) located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32 in most cases\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>DANGEROUS! Don't enable unless you know what you are doing!</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>Some of the possible values are for example <code>wg</code>, <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>wg</code> will use the nameservers from the <code>wg0.conf</code> file. A value in the format <code>8.8.8.8</code> is to use a plain old nameserver. A value in the format <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>If you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice.</p> </li> <li> <p>This will start Privoxy on the default port 8118 when set to <code>true</code>. By default Privoxy is not exposed on the LAN, so if you need that, you'll have to add <code>VPN_EXPOSE_PORTS_ON_LAN=8118/tcp,8118/udp</code>.</p> </li> <li> <p>Enabling this will bring down the container if the connectivity tests fail at the end of the Wireguard init process or for an extended period during the container runtime.</p> </li> <li> <p>Enable Unbound by setting to <code>true</code> when VPN is not active.</p> </li> <li> <p>Possible values are <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>8.8.8.8</code> is to use a plain old nameserver. The value <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> </ol>"},{"location":"containers/jellyseerr/","title":"hotio/jellyseerr","text":"<p> GitHub ghcr.io</p>"},{"location":"containers/jellyseerr/#starting-the-container","title":"Starting the container","text":"clicompose <pre><code>docker run --rm \\\n    --name jellyseerr \\\n    -p 5055:5055 \\\n    -e PUID=1000 \\\n    -e PGID=1000 \\\n    -e UMASK=002 \\\n    -e TZ=\"Etc/UTC\" \\\n    -v /&lt;host_folder_config&gt;:/config \\\n    ghcr.io/hotio/jellyseerr\n</code></pre> <pre><code>services:\n  jellyseerr:\n    container_name: jellyseerr\n    image: ghcr.io/hotio/jellyseerr\n    ports:\n      - \"5055:5055\"\n    environment:\n      - PUID=1000\n      - PGID=1000\n      - UMASK=002\n      - TZ=Etc/UTC\n    volumes:\n      - /&lt;host_folder_config&gt;:/config\n</code></pre>"},{"location":"containers/jellyseerr/#tags","title":"Tags","text":"Tags Description Last Updated Age"},{"location":"containers/jellyseerr/#wireguard","title":"WireGuard","text":"<p>Info</p> <p>This image includes VPN support. The cli/compose examples below are environment variables and settings complementary to the app image examples, this means you'll have to add/merge the stuff below with the stuff above. In case you are still in need of a VPN, consider using my affiliate links for Proton VPN, Proton Unlimited or Private Internet Access.</p> <p> </p> genericprotonpia clicompose <pre><code>docker run --rm \\\n    --hostname container-name.internal \\ #(18)\n    -e VPN_ENABLED=\"true\" \\ #(5)\n    -e VPN_CONF=\"wg0\" \\ #(8)\n    -e VPN_PROVIDER=\"generic\" \\ #(4)\n    -e VPN_LAN_NETWORK=\"192.168.1.0/24\" \\ #(1)\n    -e VPN_LAN_LEAK_ENABLED=\"false\" \\ #(10)\n    -e VPN_EXPOSE_PORTS_ON_LAN=\"\" \\ #(2)\n    -e VPN_AUTO_PORT_FORWARD=\"false\" \\ #(6)\n    -e VPN_AUTO_PORT_FORWARD_TO_PORTS=\"\" \\ #(15)\n    -e VPN_FIREWALL_TYPE=\"auto\" \\ #(17)\n    -e VPN_HEALTHCHECK_ENABLED=\"false\" \\ #(20)\n    -e VPN_NAMESERVERS=\"\" \\ #(16)\n    -e PRIVOXY_ENABLED=\"false\" \\ #(19)\n    -e UNBOUND_ENABLED=\"false\" \\ #(21)\n    -e UNBOUND_NAMESERVERS=\"\" \\ #(22)\n    --cap-add=NET_ADMIN \\\n    --sysctl=\"net.ipv4.conf.all.src_valid_mark=1\" \\ #(12)\n    --sysctl=\"net.ipv6.conf.all.disable_ipv6=1\" \\ #(3)\n    --device /dev/net/tun:/dev/net/tun \\ # OPTIONAL(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui. On MacOS set it to <code>192.168.65.0/24</code> (Verify with your settings [Resources &gt; Network &gt; Docker subnet]).</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>. Affiliate links: Proton VPN Proton Unlimited Private Internet Access</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> (for PIA this is done automatically, see <code>VPN_PROVIDER</code> variable) located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32 in most cases\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>DANGEROUS! Don't enable unless you know what you are doing!</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>Some of the possible values are for example <code>wg</code>, <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>wg</code> will use the nameservers from the <code>wg0.conf</code> file. A value in the format <code>8.8.8.8</code> is to use a plain old nameserver. A value in the format <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>If you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice.</p> </li> <li> <p>This will start Privoxy on the default port 8118 when set to <code>true</code>. By default Privoxy is not exposed on the LAN, so if you need that, you'll have to add <code>VPN_EXPOSE_PORTS_ON_LAN=8118/tcp,8118/udp</code>.</p> </li> <li> <p>Enabling this will bring down the container if the connectivity tests fail at the end of the Wireguard init process or for an extended period during the container runtime.</p> </li> <li> <p>Enable Unbound by setting to <code>true</code> when VPN is not active.</p> </li> <li> <p>Possible values are <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>8.8.8.8</code> is to use a plain old nameserver. The value <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> </ol> <pre><code>services:\n  app:\n    hostname: container-name.internal #(18)\n    environment:\n      - VPN_ENABLED=true #(5)\n      - VPN_CONF=wg0 #(8)\n      - VPN_PROVIDER=generic #(4)\n      - VPN_LAN_NETWORK=192.168.1.0/24 #(1)\n      - VPN_LAN_LEAK_ENABLED=false #(10)\n      - VPN_EXPOSE_PORTS_ON_LAN #(2)\n      - VPN_AUTO_PORT_FORWARD=false #(6)\n      - VPN_AUTO_PORT_FORWARD_TO_PORTS= #(15)\n      - VPN_FIREWALL_TYPE=auto #(17)\n      - VPN_HEALTHCHECK_ENABLED=false #(20)\n      - VPN_NAMESERVERS= #(16)\n      - PRIVOXY_ENABLED=false #(19)\n      - UNBOUND_ENABLED=false #(21)\n      - UNBOUND_NAMESERVERS #(22)\n    cap_add:\n      - NET_ADMIN\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1 #(12)\n      - net.ipv6.conf.all.disable_ipv6=1 #(3)\n    devices:\n      - /dev/net/tun:/dev/net/tun # OPTIONAL(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui. On MacOS set it to <code>192.168.65.0/24</code> (Verify with your settings [Resources &gt; Network &gt; Docker subnet]).</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>. Affiliate links: Proton VPN Proton Unlimited Private Internet Access</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> (for PIA this is done automatically, see <code>VPN_PROVIDER</code> variable) located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32 in most cases\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>DANGEROUS! Don't enable unless you know what you are doing!</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>Some of the possible values are for example <code>wg</code>, <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>wg</code> will use the nameservers from the <code>wg0.conf</code> file. A value in the format <code>8.8.8.8</code> is to use a plain old nameserver. A value in the format <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>If you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice.</p> </li> <li> <p>This will start Privoxy on the default port 8118 when set to <code>true</code>. By default Privoxy is not exposed on the LAN, so if you need that, you'll have to add <code>VPN_EXPOSE_PORTS_ON_LAN=8118/tcp,8118/udp</code>.</p> </li> <li> <p>Enabling this will bring down the container if the connectivity tests fail at the end of the Wireguard init process or for an extended period during the container runtime.</p> </li> <li> <p>Enable Unbound by setting to <code>true</code> when VPN is not active.</p> </li> <li> <p>Possible values are <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>8.8.8.8</code> is to use a plain old nameserver. The value <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> </ol> clicompose <pre><code>docker run --rm \\\n    --hostname container-name.internal \\ #(18)\n    -e VPN_ENABLED=\"true\" \\ #(5)\n    -e VPN_CONF=\"wg0\" \\ #(8)\n    -e VPN_PROVIDER=\"proton\" \\ #(4)\n    -e VPN_LAN_NETWORK=\"192.168.1.0/24\" \\ #(1)\n    -e VPN_LAN_LEAK_ENABLED=\"false\" \\ #(10)\n    -e VPN_EXPOSE_PORTS_ON_LAN=\"\" \\ #(2)\n    -e VPN_AUTO_PORT_FORWARD=\"true\" \\ #(6)\n    -e VPN_AUTO_PORT_FORWARD_TO_PORTS=\"\" \\ #(15)\n    -e VPN_FIREWALL_TYPE=\"auto\" \\ #(17)\n    -e VPN_HEALTHCHECK_ENABLED=\"false\" \\ #(20)\n    -e VPN_NAMESERVERS=\"\" \\ #(16)\n    -e PRIVOXY_ENABLED=\"false\" \\ #(19)\n    -e UNBOUND_ENABLED=\"false\" \\ #(21)\n    -e UNBOUND_NAMESERVERS=\"\" \\ #(22)\n    --cap-add=NET_ADMIN \\\n    --sysctl=\"net.ipv4.conf.all.src_valid_mark=1\" \\ #(12)\n    --sysctl=\"net.ipv6.conf.all.disable_ipv6=1\" \\ #(3)\n    --device /dev/net/tun:/dev/net/tun \\ # OPTIONAL(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui. On MacOS set it to <code>192.168.65.0/24</code> (Verify with your settings [Resources &gt; Network &gt; Docker subnet]).</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>. Affiliate links: Proton VPN Proton Unlimited Private Internet Access</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> (for PIA this is done automatically, see <code>VPN_PROVIDER</code> variable) located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32 in most cases\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>DANGEROUS! Don't enable unless you know what you are doing!</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>Some of the possible values are for example <code>wg</code>, <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>wg</code> will use the nameservers from the <code>wg0.conf</code> file. A value in the format <code>8.8.8.8</code> is to use a plain old nameserver. A value in the format <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>If you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice.</p> </li> <li> <p>This will start Privoxy on the default port 8118 when set to <code>true</code>. By default Privoxy is not exposed on the LAN, so if you need that, you'll have to add <code>VPN_EXPOSE_PORTS_ON_LAN=8118/tcp,8118/udp</code>.</p> </li> <li> <p>Enabling this will bring down the container if the connectivity tests fail at the end of the Wireguard init process or for an extended period during the container runtime.</p> </li> <li> <p>Enable Unbound by setting to <code>true</code> when VPN is not active.</p> </li> <li> <p>Possible values are <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>8.8.8.8</code> is to use a plain old nameserver. The value <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> </ol> <pre><code>services:\n  app:\n    hostname: container-name.internal #(18)\n    environment:\n      - VPN_ENABLED=true #(5)\n      - VPN_CONF=wg0 #(8)\n      - VPN_PROVIDER=proton #(4)\n      - VPN_LAN_NETWORK=192.168.1.0/24 #(1)\n      - VPN_LAN_LEAK_ENABLED=false #(10)\n      - VPN_EXPOSE_PORTS_ON_LAN #(2)\n      - VPN_AUTO_PORT_FORWARD=true #(6)\n      - VPN_AUTO_PORT_FORWARD_TO_PORTS= #(15)\n      - VPN_FIREWALL_TYPE=auto #(17)\n      - VPN_HEALTHCHECK_ENABLED=false #(20)\n      - VPN_NAMESERVERS= #(16)\n      - PRIVOXY_ENABLED=false #(19)\n      - UNBOUND_ENABLED=false #(21)\n      - UNBOUND_NAMESERVERS #(22)\n    cap_add:\n      - NET_ADMIN\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1 #(12)\n      - net.ipv6.conf.all.disable_ipv6=1 #(3)\n    devices:\n      - /dev/net/tun:/dev/net/tun # OPTIONAL(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui. On MacOS set it to <code>192.168.65.0/24</code> (Verify with your settings [Resources &gt; Network &gt; Docker subnet]).</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>. Affiliate links: Proton VPN Proton Unlimited Private Internet Access</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> (for PIA this is done automatically, see <code>VPN_PROVIDER</code> variable) located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32 in most cases\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>DANGEROUS! Don't enable unless you know what you are doing!</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>Some of the possible values are for example <code>wg</code>, <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>wg</code> will use the nameservers from the <code>wg0.conf</code> file. A value in the format <code>8.8.8.8</code> is to use a plain old nameserver. A value in the format <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>If you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice.</p> </li> <li> <p>This will start Privoxy on the default port 8118 when set to <code>true</code>. By default Privoxy is not exposed on the LAN, so if you need that, you'll have to add <code>VPN_EXPOSE_PORTS_ON_LAN=8118/tcp,8118/udp</code>.</p> </li> <li> <p>Enabling this will bring down the container if the connectivity tests fail at the end of the Wireguard init process or for an extended period during the container runtime.</p> </li> <li> <p>Enable Unbound by setting to <code>true</code> when VPN is not active.</p> </li> <li> <p>Possible values are <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>8.8.8.8</code> is to use a plain old nameserver. The value <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> </ol> clicompose <pre><code>docker run --rm \\\n    --hostname container-name.internal \\ #(18)\n    -e VPN_ENABLED=\"true\" \\ #(5)\n    -e VPN_CONF=\"wg0\" \\ #(8)\n    -e VPN_PROVIDER=\"pia\" \\ #(4)\n    -e VPN_LAN_NETWORK=\"192.168.1.0/24\" \\ #(1)\n    -e VPN_LAN_LEAK_ENABLED=\"false\" \\ #(10)\n    -e VPN_EXPOSE_PORTS_ON_LAN=\"\" \\ #(2)\n    -e VPN_AUTO_PORT_FORWARD=\"true\" \\ #(6)\n    -e VPN_AUTO_PORT_FORWARD_TO_PORTS=\"\" \\ #(15)\n    -e VPN_FIREWALL_TYPE=\"auto\" \\ #(17)\n    -e VPN_HEALTHCHECK_ENABLED=\"false\" \\ #(20)\n    -e VPN_NAMESERVERS=\"\" \\ #(16)\n    -e VPN_PIA_USER=\"\" \\ #(11)\n    -e VPN_PIA_PASS=\"\" \\ #(11)\n    -e VPN_PIA_PREFERRED_REGION=\"\" \\ #(7)\n    -e VPN_PIA_DIP_TOKEN=\"no\" \\ #(13)\n    -e VPN_PIA_PORT_FORWARD_PERSIST=\"false\" \\ #(14)\n    -e PRIVOXY_ENABLED=\"false\" \\ #(19)\n    -e UNBOUND_ENABLED=\"false\" \\ #(21)\n    -e UNBOUND_NAMESERVERS=\"\" \\ #(22)\n    --cap-add=NET_ADMIN \\\n    --sysctl=\"net.ipv4.conf.all.src_valid_mark=1\" \\ #(12)\n    --sysctl=\"net.ipv6.conf.all.disable_ipv6=1\" \\ #(3)\n    --device /dev/net/tun:/dev/net/tun \\ # OPTIONAL(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui. On MacOS set it to <code>192.168.65.0/24</code> (Verify with your settings [Resources &gt; Network &gt; Docker subnet]).</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>. Affiliate links: Proton VPN Proton Unlimited Private Internet Access</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> (for PIA this is done automatically, see <code>VPN_PROVIDER</code> variable) located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32 in most cases\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>DANGEROUS! Don't enable unless you know what you are doing!</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>Some of the possible values are for example <code>wg</code>, <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>wg</code> will use the nameservers from the <code>wg0.conf</code> file. A value in the format <code>8.8.8.8</code> is to use a plain old nameserver. A value in the format <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>If you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice.</p> </li> <li> <p>This will start Privoxy on the default port 8118 when set to <code>true</code>. By default Privoxy is not exposed on the LAN, so if you need that, you'll have to add <code>VPN_EXPOSE_PORTS_ON_LAN=8118/tcp,8118/udp</code>.</p> </li> <li> <p>Enabling this will bring down the container if the connectivity tests fail at the end of the Wireguard init process or for an extended period during the container runtime.</p> </li> <li> <p>Enable Unbound by setting to <code>true</code> when VPN is not active.</p> </li> <li> <p>Possible values are <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>8.8.8.8</code> is to use a plain old nameserver. The value <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> </ol> <pre><code>services:\n  app:\n    hostname: container-name.internal #(18)\n    environment:\n      - VPN_ENABLED=true #(5)\n      - VPN_CONF=wg0 #(8)\n      - VPN_PROVIDER=pia #(4)\n      - VPN_LAN_NETWORK=192.168.1.0/24 #(1)\n      - VPN_LAN_LEAK_ENABLED=false #(10)\n      - VPN_EXPOSE_PORTS_ON_LAN #(2)\n      - VPN_AUTO_PORT_FORWARD=true #(6)\n      - VPN_AUTO_PORT_FORWARD_TO_PORTS= #(15)\n      - VPN_FIREWALL_TYPE=auto #(17)\n      - VPN_HEALTHCHECK_ENABLED=false #(20)\n      - VPN_NAMESERVERS= #(16)\n      - VPN_PIA_USER #(11)\n      - VPN_PIA_PASS #(11)\n      - VPN_PIA_PREFERRED_REGION #(7)\n      - VPN_PIA_DIP_TOKEN=no #(13)\n      - VPN_PIA_PORT_FORWARD_PERSIST=false #(14)\n      - PRIVOXY_ENABLED=false #(19)\n      - UNBOUND_ENABLED=false #(21)\n      - UNBOUND_NAMESERVERS #(22)\n    cap_add:\n      - NET_ADMIN\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1 #(12)\n      - net.ipv6.conf.all.disable_ipv6=1 #(3)\n    devices:\n      - /dev/net/tun:/dev/net/tun # OPTIONAL(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui. On MacOS set it to <code>192.168.65.0/24</code> (Verify with your settings [Resources &gt; Network &gt; Docker subnet]).</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>. Affiliate links: Proton VPN Proton Unlimited Private Internet Access</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> (for PIA this is done automatically, see <code>VPN_PROVIDER</code> variable) located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32 in most cases\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>DANGEROUS! Don't enable unless you know what you are doing!</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>Some of the possible values are for example <code>wg</code>, <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>wg</code> will use the nameservers from the <code>wg0.conf</code> file. A value in the format <code>8.8.8.8</code> is to use a plain old nameserver. A value in the format <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>If you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice.</p> </li> <li> <p>This will start Privoxy on the default port 8118 when set to <code>true</code>. By default Privoxy is not exposed on the LAN, so if you need that, you'll have to add <code>VPN_EXPOSE_PORTS_ON_LAN=8118/tcp,8118/udp</code>.</p> </li> <li> <p>Enabling this will bring down the container if the connectivity tests fail at the end of the Wireguard init process or for an extended period during the container runtime.</p> </li> <li> <p>Enable Unbound by setting to <code>true</code> when VPN is not active.</p> </li> <li> <p>Possible values are <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>8.8.8.8</code> is to use a plain old nameserver. The value <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> </ol>"},{"location":"containers/lidarr/","title":"hotio/lidarr","text":"<p> GitHub ghcr.io</p>"},{"location":"containers/lidarr/#starting-the-container","title":"Starting the container","text":"clicompose <pre><code>docker run --rm \\\n    --name lidarr \\\n    -p 8686:8686 \\\n    -e PUID=1000 \\\n    -e PGID=1000 \\\n    -e UMASK=002 \\\n    -e TZ=\"Etc/UTC\" \\\n    -v /&lt;host_folder_config&gt;:/config \\\n    -v /&lt;host_folder_data&gt;:/data \\\n    ghcr.io/hotio/lidarr\n</code></pre> <pre><code>services:\n  lidarr:\n    container_name: lidarr\n    image: ghcr.io/hotio/lidarr\n    ports:\n      - \"8686:8686\"\n    environment:\n      - PUID=1000\n      - PGID=1000\n      - UMASK=002\n      - TZ=Etc/UTC\n    volumes:\n      - /&lt;host_folder_config&gt;:/config\n      - /&lt;host_folder_data&gt;:/data\n</code></pre>"},{"location":"containers/lidarr/#tags","title":"Tags","text":"Tags Description Last Updated Age"},{"location":"containers/lidarr/#wireguard","title":"WireGuard","text":"<p>Info</p> <p>This image includes VPN support. The cli/compose examples below are environment variables and settings complementary to the app image examples, this means you'll have to add/merge the stuff below with the stuff above. In case you are still in need of a VPN, consider using my affiliate links for Proton VPN, Proton Unlimited or Private Internet Access.</p> <p> </p> genericprotonpia clicompose <pre><code>docker run --rm \\\n    --hostname container-name.internal \\ #(18)\n    -e VPN_ENABLED=\"true\" \\ #(5)\n    -e VPN_CONF=\"wg0\" \\ #(8)\n    -e VPN_PROVIDER=\"generic\" \\ #(4)\n    -e VPN_LAN_NETWORK=\"192.168.1.0/24\" \\ #(1)\n    -e VPN_LAN_LEAK_ENABLED=\"false\" \\ #(10)\n    -e VPN_EXPOSE_PORTS_ON_LAN=\"\" \\ #(2)\n    -e VPN_AUTO_PORT_FORWARD=\"false\" \\ #(6)\n    -e VPN_AUTO_PORT_FORWARD_TO_PORTS=\"\" \\ #(15)\n    -e VPN_FIREWALL_TYPE=\"auto\" \\ #(17)\n    -e VPN_HEALTHCHECK_ENABLED=\"false\" \\ #(20)\n    -e VPN_NAMESERVERS=\"\" \\ #(16)\n    -e PRIVOXY_ENABLED=\"false\" \\ #(19)\n    -e UNBOUND_ENABLED=\"false\" \\ #(21)\n    -e UNBOUND_NAMESERVERS=\"\" \\ #(22)\n    --cap-add=NET_ADMIN \\\n    --sysctl=\"net.ipv4.conf.all.src_valid_mark=1\" \\ #(12)\n    --sysctl=\"net.ipv6.conf.all.disable_ipv6=1\" \\ #(3)\n    --device /dev/net/tun:/dev/net/tun \\ # OPTIONAL(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui. On MacOS set it to <code>192.168.65.0/24</code> (Verify with your settings [Resources &gt; Network &gt; Docker subnet]).</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>. Affiliate links: Proton VPN Proton Unlimited Private Internet Access</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> (for PIA this is done automatically, see <code>VPN_PROVIDER</code> variable) located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32 in most cases\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>DANGEROUS! Don't enable unless you know what you are doing!</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>Some of the possible values are for example <code>wg</code>, <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>wg</code> will use the nameservers from the <code>wg0.conf</code> file. A value in the format <code>8.8.8.8</code> is to use a plain old nameserver. A value in the format <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>If you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice.</p> </li> <li> <p>This will start Privoxy on the default port 8118 when set to <code>true</code>. By default Privoxy is not exposed on the LAN, so if you need that, you'll have to add <code>VPN_EXPOSE_PORTS_ON_LAN=8118/tcp,8118/udp</code>.</p> </li> <li> <p>Enabling this will bring down the container if the connectivity tests fail at the end of the Wireguard init process or for an extended period during the container runtime.</p> </li> <li> <p>Enable Unbound by setting to <code>true</code> when VPN is not active.</p> </li> <li> <p>Possible values are <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>8.8.8.8</code> is to use a plain old nameserver. The value <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> </ol> <pre><code>services:\n  app:\n    hostname: container-name.internal #(18)\n    environment:\n      - VPN_ENABLED=true #(5)\n      - VPN_CONF=wg0 #(8)\n      - VPN_PROVIDER=generic #(4)\n      - VPN_LAN_NETWORK=192.168.1.0/24 #(1)\n      - VPN_LAN_LEAK_ENABLED=false #(10)\n      - VPN_EXPOSE_PORTS_ON_LAN #(2)\n      - VPN_AUTO_PORT_FORWARD=false #(6)\n      - VPN_AUTO_PORT_FORWARD_TO_PORTS= #(15)\n      - VPN_FIREWALL_TYPE=auto #(17)\n      - VPN_HEALTHCHECK_ENABLED=false #(20)\n      - VPN_NAMESERVERS= #(16)\n      - PRIVOXY_ENABLED=false #(19)\n      - UNBOUND_ENABLED=false #(21)\n      - UNBOUND_NAMESERVERS #(22)\n    cap_add:\n      - NET_ADMIN\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1 #(12)\n      - net.ipv6.conf.all.disable_ipv6=1 #(3)\n    devices:\n      - /dev/net/tun:/dev/net/tun # OPTIONAL(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui. On MacOS set it to <code>192.168.65.0/24</code> (Verify with your settings [Resources &gt; Network &gt; Docker subnet]).</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>. Affiliate links: Proton VPN Proton Unlimited Private Internet Access</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> (for PIA this is done automatically, see <code>VPN_PROVIDER</code> variable) located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32 in most cases\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>DANGEROUS! Don't enable unless you know what you are doing!</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>Some of the possible values are for example <code>wg</code>, <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>wg</code> will use the nameservers from the <code>wg0.conf</code> file. A value in the format <code>8.8.8.8</code> is to use a plain old nameserver. A value in the format <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>If you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice.</p> </li> <li> <p>This will start Privoxy on the default port 8118 when set to <code>true</code>. By default Privoxy is not exposed on the LAN, so if you need that, you'll have to add <code>VPN_EXPOSE_PORTS_ON_LAN=8118/tcp,8118/udp</code>.</p> </li> <li> <p>Enabling this will bring down the container if the connectivity tests fail at the end of the Wireguard init process or for an extended period during the container runtime.</p> </li> <li> <p>Enable Unbound by setting to <code>true</code> when VPN is not active.</p> </li> <li> <p>Possible values are <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>8.8.8.8</code> is to use a plain old nameserver. The value <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> </ol> clicompose <pre><code>docker run --rm \\\n    --hostname container-name.internal \\ #(18)\n    -e VPN_ENABLED=\"true\" \\ #(5)\n    -e VPN_CONF=\"wg0\" \\ #(8)\n    -e VPN_PROVIDER=\"proton\" \\ #(4)\n    -e VPN_LAN_NETWORK=\"192.168.1.0/24\" \\ #(1)\n    -e VPN_LAN_LEAK_ENABLED=\"false\" \\ #(10)\n    -e VPN_EXPOSE_PORTS_ON_LAN=\"\" \\ #(2)\n    -e VPN_AUTO_PORT_FORWARD=\"true\" \\ #(6)\n    -e VPN_AUTO_PORT_FORWARD_TO_PORTS=\"\" \\ #(15)\n    -e VPN_FIREWALL_TYPE=\"auto\" \\ #(17)\n    -e VPN_HEALTHCHECK_ENABLED=\"false\" \\ #(20)\n    -e VPN_NAMESERVERS=\"\" \\ #(16)\n    -e PRIVOXY_ENABLED=\"false\" \\ #(19)\n    -e UNBOUND_ENABLED=\"false\" \\ #(21)\n    -e UNBOUND_NAMESERVERS=\"\" \\ #(22)\n    --cap-add=NET_ADMIN \\\n    --sysctl=\"net.ipv4.conf.all.src_valid_mark=1\" \\ #(12)\n    --sysctl=\"net.ipv6.conf.all.disable_ipv6=1\" \\ #(3)\n    --device /dev/net/tun:/dev/net/tun \\ # OPTIONAL(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui. On MacOS set it to <code>192.168.65.0/24</code> (Verify with your settings [Resources &gt; Network &gt; Docker subnet]).</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>. Affiliate links: Proton VPN Proton Unlimited Private Internet Access</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> (for PIA this is done automatically, see <code>VPN_PROVIDER</code> variable) located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32 in most cases\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>DANGEROUS! Don't enable unless you know what you are doing!</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>Some of the possible values are for example <code>wg</code>, <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>wg</code> will use the nameservers from the <code>wg0.conf</code> file. A value in the format <code>8.8.8.8</code> is to use a plain old nameserver. A value in the format <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>If you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice.</p> </li> <li> <p>This will start Privoxy on the default port 8118 when set to <code>true</code>. By default Privoxy is not exposed on the LAN, so if you need that, you'll have to add <code>VPN_EXPOSE_PORTS_ON_LAN=8118/tcp,8118/udp</code>.</p> </li> <li> <p>Enabling this will bring down the container if the connectivity tests fail at the end of the Wireguard init process or for an extended period during the container runtime.</p> </li> <li> <p>Enable Unbound by setting to <code>true</code> when VPN is not active.</p> </li> <li> <p>Possible values are <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>8.8.8.8</code> is to use a plain old nameserver. The value <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> </ol> <pre><code>services:\n  app:\n    hostname: container-name.internal #(18)\n    environment:\n      - VPN_ENABLED=true #(5)\n      - VPN_CONF=wg0 #(8)\n      - VPN_PROVIDER=proton #(4)\n      - VPN_LAN_NETWORK=192.168.1.0/24 #(1)\n      - VPN_LAN_LEAK_ENABLED=false #(10)\n      - VPN_EXPOSE_PORTS_ON_LAN #(2)\n      - VPN_AUTO_PORT_FORWARD=true #(6)\n      - VPN_AUTO_PORT_FORWARD_TO_PORTS= #(15)\n      - VPN_FIREWALL_TYPE=auto #(17)\n      - VPN_HEALTHCHECK_ENABLED=false #(20)\n      - VPN_NAMESERVERS= #(16)\n      - PRIVOXY_ENABLED=false #(19)\n      - UNBOUND_ENABLED=false #(21)\n      - UNBOUND_NAMESERVERS #(22)\n    cap_add:\n      - NET_ADMIN\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1 #(12)\n      - net.ipv6.conf.all.disable_ipv6=1 #(3)\n    devices:\n      - /dev/net/tun:/dev/net/tun # OPTIONAL(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui. On MacOS set it to <code>192.168.65.0/24</code> (Verify with your settings [Resources &gt; Network &gt; Docker subnet]).</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>. Affiliate links: Proton VPN Proton Unlimited Private Internet Access</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> (for PIA this is done automatically, see <code>VPN_PROVIDER</code> variable) located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32 in most cases\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>DANGEROUS! Don't enable unless you know what you are doing!</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>Some of the possible values are for example <code>wg</code>, <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>wg</code> will use the nameservers from the <code>wg0.conf</code> file. A value in the format <code>8.8.8.8</code> is to use a plain old nameserver. A value in the format <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>If you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice.</p> </li> <li> <p>This will start Privoxy on the default port 8118 when set to <code>true</code>. By default Privoxy is not exposed on the LAN, so if you need that, you'll have to add <code>VPN_EXPOSE_PORTS_ON_LAN=8118/tcp,8118/udp</code>.</p> </li> <li> <p>Enabling this will bring down the container if the connectivity tests fail at the end of the Wireguard init process or for an extended period during the container runtime.</p> </li> <li> <p>Enable Unbound by setting to <code>true</code> when VPN is not active.</p> </li> <li> <p>Possible values are <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>8.8.8.8</code> is to use a plain old nameserver. The value <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> </ol> clicompose <pre><code>docker run --rm \\\n    --hostname container-name.internal \\ #(18)\n    -e VPN_ENABLED=\"true\" \\ #(5)\n    -e VPN_CONF=\"wg0\" \\ #(8)\n    -e VPN_PROVIDER=\"pia\" \\ #(4)\n    -e VPN_LAN_NETWORK=\"192.168.1.0/24\" \\ #(1)\n    -e VPN_LAN_LEAK_ENABLED=\"false\" \\ #(10)\n    -e VPN_EXPOSE_PORTS_ON_LAN=\"\" \\ #(2)\n    -e VPN_AUTO_PORT_FORWARD=\"true\" \\ #(6)\n    -e VPN_AUTO_PORT_FORWARD_TO_PORTS=\"\" \\ #(15)\n    -e VPN_FIREWALL_TYPE=\"auto\" \\ #(17)\n    -e VPN_HEALTHCHECK_ENABLED=\"false\" \\ #(20)\n    -e VPN_NAMESERVERS=\"\" \\ #(16)\n    -e VPN_PIA_USER=\"\" \\ #(11)\n    -e VPN_PIA_PASS=\"\" \\ #(11)\n    -e VPN_PIA_PREFERRED_REGION=\"\" \\ #(7)\n    -e VPN_PIA_DIP_TOKEN=\"no\" \\ #(13)\n    -e VPN_PIA_PORT_FORWARD_PERSIST=\"false\" \\ #(14)\n    -e PRIVOXY_ENABLED=\"false\" \\ #(19)\n    -e UNBOUND_ENABLED=\"false\" \\ #(21)\n    -e UNBOUND_NAMESERVERS=\"\" \\ #(22)\n    --cap-add=NET_ADMIN \\\n    --sysctl=\"net.ipv4.conf.all.src_valid_mark=1\" \\ #(12)\n    --sysctl=\"net.ipv6.conf.all.disable_ipv6=1\" \\ #(3)\n    --device /dev/net/tun:/dev/net/tun \\ # OPTIONAL(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui. On MacOS set it to <code>192.168.65.0/24</code> (Verify with your settings [Resources &gt; Network &gt; Docker subnet]).</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>. Affiliate links: Proton VPN Proton Unlimited Private Internet Access</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> (for PIA this is done automatically, see <code>VPN_PROVIDER</code> variable) located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32 in most cases\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>DANGEROUS! Don't enable unless you know what you are doing!</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>Some of the possible values are for example <code>wg</code>, <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>wg</code> will use the nameservers from the <code>wg0.conf</code> file. A value in the format <code>8.8.8.8</code> is to use a plain old nameserver. A value in the format <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>If you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice.</p> </li> <li> <p>This will start Privoxy on the default port 8118 when set to <code>true</code>. By default Privoxy is not exposed on the LAN, so if you need that, you'll have to add <code>VPN_EXPOSE_PORTS_ON_LAN=8118/tcp,8118/udp</code>.</p> </li> <li> <p>Enabling this will bring down the container if the connectivity tests fail at the end of the Wireguard init process or for an extended period during the container runtime.</p> </li> <li> <p>Enable Unbound by setting to <code>true</code> when VPN is not active.</p> </li> <li> <p>Possible values are <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>8.8.8.8</code> is to use a plain old nameserver. The value <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> </ol> <pre><code>services:\n  app:\n    hostname: container-name.internal #(18)\n    environment:\n      - VPN_ENABLED=true #(5)\n      - VPN_CONF=wg0 #(8)\n      - VPN_PROVIDER=pia #(4)\n      - VPN_LAN_NETWORK=192.168.1.0/24 #(1)\n      - VPN_LAN_LEAK_ENABLED=false #(10)\n      - VPN_EXPOSE_PORTS_ON_LAN #(2)\n      - VPN_AUTO_PORT_FORWARD=true #(6)\n      - VPN_AUTO_PORT_FORWARD_TO_PORTS= #(15)\n      - VPN_FIREWALL_TYPE=auto #(17)\n      - VPN_HEALTHCHECK_ENABLED=false #(20)\n      - VPN_NAMESERVERS= #(16)\n      - VPN_PIA_USER #(11)\n      - VPN_PIA_PASS #(11)\n      - VPN_PIA_PREFERRED_REGION #(7)\n      - VPN_PIA_DIP_TOKEN=no #(13)\n      - VPN_PIA_PORT_FORWARD_PERSIST=false #(14)\n      - PRIVOXY_ENABLED=false #(19)\n      - UNBOUND_ENABLED=false #(21)\n      - UNBOUND_NAMESERVERS #(22)\n    cap_add:\n      - NET_ADMIN\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1 #(12)\n      - net.ipv6.conf.all.disable_ipv6=1 #(3)\n    devices:\n      - /dev/net/tun:/dev/net/tun # OPTIONAL(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui. On MacOS set it to <code>192.168.65.0/24</code> (Verify with your settings [Resources &gt; Network &gt; Docker subnet]).</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>. Affiliate links: Proton VPN Proton Unlimited Private Internet Access</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> (for PIA this is done automatically, see <code>VPN_PROVIDER</code> variable) located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32 in most cases\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>DANGEROUS! Don't enable unless you know what you are doing!</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>Some of the possible values are for example <code>wg</code>, <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>wg</code> will use the nameservers from the <code>wg0.conf</code> file. A value in the format <code>8.8.8.8</code> is to use a plain old nameserver. A value in the format <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>If you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice.</p> </li> <li> <p>This will start Privoxy on the default port 8118 when set to <code>true</code>. By default Privoxy is not exposed on the LAN, so if you need that, you'll have to add <code>VPN_EXPOSE_PORTS_ON_LAN=8118/tcp,8118/udp</code>.</p> </li> <li> <p>Enabling this will bring down the container if the connectivity tests fail at the end of the Wireguard init process or for an extended period during the container runtime.</p> </li> <li> <p>Enable Unbound by setting to <code>true</code> when VPN is not active.</p> </li> <li> <p>Possible values are <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>8.8.8.8</code> is to use a plain old nameserver. The value <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> </ol>"},{"location":"containers/mergerfs/","title":"hotio/mergerfs","text":"<p> GitHub ghcr.io</p>"},{"location":"containers/mergerfs/#starting-the-container","title":"Starting the container","text":"cli <pre><code>docker run --rm \\\n    --init \\\n    -v /&lt;host_folder_branch_1&gt;:/branch_1 \\\n    -v /&lt;host_folder_branch_2&gt;:/branch_2 \\\n    -v /&lt;host_folder_mountpoint&gt;:/mountpoint:shared \\\n    --cap-add SYS_ADMIN \\\n    --device /dev/fuse \\\n    ghcr.io/hotio/mergerfs -o allow_other /branch_1:/branch_2 /mountpoint\n</code></pre> <p>The default <code>ENTRYPOINT</code> is <code>mergerfs -f</code>.</p>"},{"location":"containers/mergerfs/#tags","title":"Tags","text":"Tags Description Last Updated Age"},{"location":"containers/mergerfs/#using-the-mergerfs-mount-on-the-host","title":"Using the mergerfs mount on the host","text":"<p>By setting the <code>bind-propagation</code> to <code>shared</code> on the volume <code>mountpoint</code>, like this <code>-v /data/mountpoint:/mountpoint:shared</code>, you are able to access the mount from the host. If you want to use this mount in another container, the best solution is to create a volume on the parent folder of that mount with <code>bind-propagation</code> set to <code>slave</code>. For example, <code>-v /data:/data:slave</code> (<code>/data</code> on the host, would contain the previously created volume <code>mountpoint</code>). Doing it like this will ensure that when the container creating the mount restarts, the other containers using that mount will recover and keep working.</p>"},{"location":"containers/mergerfs/#extra-docker-privileges","title":"Extra docker privileges","text":"<p>On some systems you'll also need the following privileges.</p> <pre><code>--security-opt apparmor:unconfined\n</code></pre>"},{"location":"containers/nzbget/","title":"hotio/nzbget","text":"<p> GitHub ghcr.io</p>"},{"location":"containers/nzbget/#starting-the-container","title":"Starting the container","text":"clicompose <pre><code>docker run --rm \\\n    --name nzbget \\\n    -p 6789:6789 \\\n    -e PUID=1000 \\\n    -e PGID=1000 \\\n    -e UMASK=002 \\\n    -e TZ=\"Etc/UTC\" \\\n    -v /&lt;host_folder_config&gt;:/config \\\n    -v /&lt;host_folder_data&gt;:/data \\\n    ghcr.io/hotio/nzbget\n</code></pre> <pre><code>services:\n  nzbget:\n    container_name: nzbget\n    image: ghcr.io/hotio/nzbget\n    ports:\n      - \"6789:6789\"\n    environment:\n      - PUID=1000\n      - PGID=1000\n      - UMASK=002\n      - TZ=Etc/UTC\n    volumes:\n      - /&lt;host_folder_config&gt;:/config\n      - /&lt;host_folder_data&gt;:/data\n</code></pre>"},{"location":"containers/nzbget/#tags","title":"Tags","text":"Tags Description Last Updated Age"},{"location":"containers/nzbget/#wireguard","title":"WireGuard","text":"<p>Info</p> <p>This image includes VPN support. The cli/compose examples below are environment variables and settings complementary to the app image examples, this means you'll have to add/merge the stuff below with the stuff above. In case you are still in need of a VPN, consider using my affiliate links for Proton VPN, Proton Unlimited or Private Internet Access.</p> <p> </p> genericprotonpia clicompose <pre><code>docker run --rm \\\n    --hostname container-name.internal \\ #(18)\n    -e VPN_ENABLED=\"true\" \\ #(5)\n    -e VPN_CONF=\"wg0\" \\ #(8)\n    -e VPN_PROVIDER=\"generic\" \\ #(4)\n    -e VPN_LAN_NETWORK=\"192.168.1.0/24\" \\ #(1)\n    -e VPN_LAN_LEAK_ENABLED=\"false\" \\ #(10)\n    -e VPN_EXPOSE_PORTS_ON_LAN=\"\" \\ #(2)\n    -e VPN_AUTO_PORT_FORWARD=\"false\" \\ #(6)\n    -e VPN_AUTO_PORT_FORWARD_TO_PORTS=\"\" \\ #(15)\n    -e VPN_FIREWALL_TYPE=\"auto\" \\ #(17)\n    -e VPN_HEALTHCHECK_ENABLED=\"false\" \\ #(20)\n    -e VPN_NAMESERVERS=\"\" \\ #(16)\n    -e PRIVOXY_ENABLED=\"false\" \\ #(19)\n    -e UNBOUND_ENABLED=\"false\" \\ #(21)\n    -e UNBOUND_NAMESERVERS=\"\" \\ #(22)\n    --cap-add=NET_ADMIN \\\n    --sysctl=\"net.ipv4.conf.all.src_valid_mark=1\" \\ #(12)\n    --sysctl=\"net.ipv6.conf.all.disable_ipv6=1\" \\ #(3)\n    --device /dev/net/tun:/dev/net/tun \\ # OPTIONAL(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui. On MacOS set it to <code>192.168.65.0/24</code> (Verify with your settings [Resources &gt; Network &gt; Docker subnet]).</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>. Affiliate links: Proton VPN Proton Unlimited Private Internet Access</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> (for PIA this is done automatically, see <code>VPN_PROVIDER</code> variable) located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32 in most cases\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>DANGEROUS! Don't enable unless you know what you are doing!</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>Some of the possible values are for example <code>wg</code>, <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>wg</code> will use the nameservers from the <code>wg0.conf</code> file. A value in the format <code>8.8.8.8</code> is to use a plain old nameserver. A value in the format <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>If you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice.</p> </li> <li> <p>This will start Privoxy on the default port 8118 when set to <code>true</code>. By default Privoxy is not exposed on the LAN, so if you need that, you'll have to add <code>VPN_EXPOSE_PORTS_ON_LAN=8118/tcp,8118/udp</code>.</p> </li> <li> <p>Enabling this will bring down the container if the connectivity tests fail at the end of the Wireguard init process or for an extended period during the container runtime.</p> </li> <li> <p>Enable Unbound by setting to <code>true</code> when VPN is not active.</p> </li> <li> <p>Possible values are <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>8.8.8.8</code> is to use a plain old nameserver. The value <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> </ol> <pre><code>services:\n  app:\n    hostname: container-name.internal #(18)\n    environment:\n      - VPN_ENABLED=true #(5)\n      - VPN_CONF=wg0 #(8)\n      - VPN_PROVIDER=generic #(4)\n      - VPN_LAN_NETWORK=192.168.1.0/24 #(1)\n      - VPN_LAN_LEAK_ENABLED=false #(10)\n      - VPN_EXPOSE_PORTS_ON_LAN #(2)\n      - VPN_AUTO_PORT_FORWARD=false #(6)\n      - VPN_AUTO_PORT_FORWARD_TO_PORTS= #(15)\n      - VPN_FIREWALL_TYPE=auto #(17)\n      - VPN_HEALTHCHECK_ENABLED=false #(20)\n      - VPN_NAMESERVERS= #(16)\n      - PRIVOXY_ENABLED=false #(19)\n      - UNBOUND_ENABLED=false #(21)\n      - UNBOUND_NAMESERVERS #(22)\n    cap_add:\n      - NET_ADMIN\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1 #(12)\n      - net.ipv6.conf.all.disable_ipv6=1 #(3)\n    devices:\n      - /dev/net/tun:/dev/net/tun # OPTIONAL(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui. On MacOS set it to <code>192.168.65.0/24</code> (Verify with your settings [Resources &gt; Network &gt; Docker subnet]).</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>. Affiliate links: Proton VPN Proton Unlimited Private Internet Access</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> (for PIA this is done automatically, see <code>VPN_PROVIDER</code> variable) located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32 in most cases\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>DANGEROUS! Don't enable unless you know what you are doing!</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>Some of the possible values are for example <code>wg</code>, <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>wg</code> will use the nameservers from the <code>wg0.conf</code> file. A value in the format <code>8.8.8.8</code> is to use a plain old nameserver. A value in the format <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>If you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice.</p> </li> <li> <p>This will start Privoxy on the default port 8118 when set to <code>true</code>. By default Privoxy is not exposed on the LAN, so if you need that, you'll have to add <code>VPN_EXPOSE_PORTS_ON_LAN=8118/tcp,8118/udp</code>.</p> </li> <li> <p>Enabling this will bring down the container if the connectivity tests fail at the end of the Wireguard init process or for an extended period during the container runtime.</p> </li> <li> <p>Enable Unbound by setting to <code>true</code> when VPN is not active.</p> </li> <li> <p>Possible values are <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>8.8.8.8</code> is to use a plain old nameserver. The value <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> </ol> clicompose <pre><code>docker run --rm \\\n    --hostname container-name.internal \\ #(18)\n    -e VPN_ENABLED=\"true\" \\ #(5)\n    -e VPN_CONF=\"wg0\" \\ #(8)\n    -e VPN_PROVIDER=\"proton\" \\ #(4)\n    -e VPN_LAN_NETWORK=\"192.168.1.0/24\" \\ #(1)\n    -e VPN_LAN_LEAK_ENABLED=\"false\" \\ #(10)\n    -e VPN_EXPOSE_PORTS_ON_LAN=\"\" \\ #(2)\n    -e VPN_AUTO_PORT_FORWARD=\"true\" \\ #(6)\n    -e VPN_AUTO_PORT_FORWARD_TO_PORTS=\"\" \\ #(15)\n    -e VPN_FIREWALL_TYPE=\"auto\" \\ #(17)\n    -e VPN_HEALTHCHECK_ENABLED=\"false\" \\ #(20)\n    -e VPN_NAMESERVERS=\"\" \\ #(16)\n    -e PRIVOXY_ENABLED=\"false\" \\ #(19)\n    -e UNBOUND_ENABLED=\"false\" \\ #(21)\n    -e UNBOUND_NAMESERVERS=\"\" \\ #(22)\n    --cap-add=NET_ADMIN \\\n    --sysctl=\"net.ipv4.conf.all.src_valid_mark=1\" \\ #(12)\n    --sysctl=\"net.ipv6.conf.all.disable_ipv6=1\" \\ #(3)\n    --device /dev/net/tun:/dev/net/tun \\ # OPTIONAL(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui. On MacOS set it to <code>192.168.65.0/24</code> (Verify with your settings [Resources &gt; Network &gt; Docker subnet]).</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>. Affiliate links: Proton VPN Proton Unlimited Private Internet Access</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> (for PIA this is done automatically, see <code>VPN_PROVIDER</code> variable) located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32 in most cases\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>DANGEROUS! Don't enable unless you know what you are doing!</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>Some of the possible values are for example <code>wg</code>, <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>wg</code> will use the nameservers from the <code>wg0.conf</code> file. A value in the format <code>8.8.8.8</code> is to use a plain old nameserver. A value in the format <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>If you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice.</p> </li> <li> <p>This will start Privoxy on the default port 8118 when set to <code>true</code>. By default Privoxy is not exposed on the LAN, so if you need that, you'll have to add <code>VPN_EXPOSE_PORTS_ON_LAN=8118/tcp,8118/udp</code>.</p> </li> <li> <p>Enabling this will bring down the container if the connectivity tests fail at the end of the Wireguard init process or for an extended period during the container runtime.</p> </li> <li> <p>Enable Unbound by setting to <code>true</code> when VPN is not active.</p> </li> <li> <p>Possible values are <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>8.8.8.8</code> is to use a plain old nameserver. The value <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> </ol> <pre><code>services:\n  app:\n    hostname: container-name.internal #(18)\n    environment:\n      - VPN_ENABLED=true #(5)\n      - VPN_CONF=wg0 #(8)\n      - VPN_PROVIDER=proton #(4)\n      - VPN_LAN_NETWORK=192.168.1.0/24 #(1)\n      - VPN_LAN_LEAK_ENABLED=false #(10)\n      - VPN_EXPOSE_PORTS_ON_LAN #(2)\n      - VPN_AUTO_PORT_FORWARD=true #(6)\n      - VPN_AUTO_PORT_FORWARD_TO_PORTS= #(15)\n      - VPN_FIREWALL_TYPE=auto #(17)\n      - VPN_HEALTHCHECK_ENABLED=false #(20)\n      - VPN_NAMESERVERS= #(16)\n      - PRIVOXY_ENABLED=false #(19)\n      - UNBOUND_ENABLED=false #(21)\n      - UNBOUND_NAMESERVERS #(22)\n    cap_add:\n      - NET_ADMIN\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1 #(12)\n      - net.ipv6.conf.all.disable_ipv6=1 #(3)\n    devices:\n      - /dev/net/tun:/dev/net/tun # OPTIONAL(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui. On MacOS set it to <code>192.168.65.0/24</code> (Verify with your settings [Resources &gt; Network &gt; Docker subnet]).</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>. Affiliate links: Proton VPN Proton Unlimited Private Internet Access</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> (for PIA this is done automatically, see <code>VPN_PROVIDER</code> variable) located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32 in most cases\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>DANGEROUS! Don't enable unless you know what you are doing!</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>Some of the possible values are for example <code>wg</code>, <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>wg</code> will use the nameservers from the <code>wg0.conf</code> file. A value in the format <code>8.8.8.8</code> is to use a plain old nameserver. A value in the format <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>If you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice.</p> </li> <li> <p>This will start Privoxy on the default port 8118 when set to <code>true</code>. By default Privoxy is not exposed on the LAN, so if you need that, you'll have to add <code>VPN_EXPOSE_PORTS_ON_LAN=8118/tcp,8118/udp</code>.</p> </li> <li> <p>Enabling this will bring down the container if the connectivity tests fail at the end of the Wireguard init process or for an extended period during the container runtime.</p> </li> <li> <p>Enable Unbound by setting to <code>true</code> when VPN is not active.</p> </li> <li> <p>Possible values are <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>8.8.8.8</code> is to use a plain old nameserver. The value <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> </ol> clicompose <pre><code>docker run --rm \\\n    --hostname container-name.internal \\ #(18)\n    -e VPN_ENABLED=\"true\" \\ #(5)\n    -e VPN_CONF=\"wg0\" \\ #(8)\n    -e VPN_PROVIDER=\"pia\" \\ #(4)\n    -e VPN_LAN_NETWORK=\"192.168.1.0/24\" \\ #(1)\n    -e VPN_LAN_LEAK_ENABLED=\"false\" \\ #(10)\n    -e VPN_EXPOSE_PORTS_ON_LAN=\"\" \\ #(2)\n    -e VPN_AUTO_PORT_FORWARD=\"true\" \\ #(6)\n    -e VPN_AUTO_PORT_FORWARD_TO_PORTS=\"\" \\ #(15)\n    -e VPN_FIREWALL_TYPE=\"auto\" \\ #(17)\n    -e VPN_HEALTHCHECK_ENABLED=\"false\" \\ #(20)\n    -e VPN_NAMESERVERS=\"\" \\ #(16)\n    -e VPN_PIA_USER=\"\" \\ #(11)\n    -e VPN_PIA_PASS=\"\" \\ #(11)\n    -e VPN_PIA_PREFERRED_REGION=\"\" \\ #(7)\n    -e VPN_PIA_DIP_TOKEN=\"no\" \\ #(13)\n    -e VPN_PIA_PORT_FORWARD_PERSIST=\"false\" \\ #(14)\n    -e PRIVOXY_ENABLED=\"false\" \\ #(19)\n    -e UNBOUND_ENABLED=\"false\" \\ #(21)\n    -e UNBOUND_NAMESERVERS=\"\" \\ #(22)\n    --cap-add=NET_ADMIN \\\n    --sysctl=\"net.ipv4.conf.all.src_valid_mark=1\" \\ #(12)\n    --sysctl=\"net.ipv6.conf.all.disable_ipv6=1\" \\ #(3)\n    --device /dev/net/tun:/dev/net/tun \\ # OPTIONAL(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui. On MacOS set it to <code>192.168.65.0/24</code> (Verify with your settings [Resources &gt; Network &gt; Docker subnet]).</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>. Affiliate links: Proton VPN Proton Unlimited Private Internet Access</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> (for PIA this is done automatically, see <code>VPN_PROVIDER</code> variable) located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32 in most cases\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>DANGEROUS! Don't enable unless you know what you are doing!</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>Some of the possible values are for example <code>wg</code>, <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>wg</code> will use the nameservers from the <code>wg0.conf</code> file. A value in the format <code>8.8.8.8</code> is to use a plain old nameserver. A value in the format <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>If you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice.</p> </li> <li> <p>This will start Privoxy on the default port 8118 when set to <code>true</code>. By default Privoxy is not exposed on the LAN, so if you need that, you'll have to add <code>VPN_EXPOSE_PORTS_ON_LAN=8118/tcp,8118/udp</code>.</p> </li> <li> <p>Enabling this will bring down the container if the connectivity tests fail at the end of the Wireguard init process or for an extended period during the container runtime.</p> </li> <li> <p>Enable Unbound by setting to <code>true</code> when VPN is not active.</p> </li> <li> <p>Possible values are <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>8.8.8.8</code> is to use a plain old nameserver. The value <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> </ol> <pre><code>services:\n  app:\n    hostname: container-name.internal #(18)\n    environment:\n      - VPN_ENABLED=true #(5)\n      - VPN_CONF=wg0 #(8)\n      - VPN_PROVIDER=pia #(4)\n      - VPN_LAN_NETWORK=192.168.1.0/24 #(1)\n      - VPN_LAN_LEAK_ENABLED=false #(10)\n      - VPN_EXPOSE_PORTS_ON_LAN #(2)\n      - VPN_AUTO_PORT_FORWARD=true #(6)\n      - VPN_AUTO_PORT_FORWARD_TO_PORTS= #(15)\n      - VPN_FIREWALL_TYPE=auto #(17)\n      - VPN_HEALTHCHECK_ENABLED=false #(20)\n      - VPN_NAMESERVERS= #(16)\n      - VPN_PIA_USER #(11)\n      - VPN_PIA_PASS #(11)\n      - VPN_PIA_PREFERRED_REGION #(7)\n      - VPN_PIA_DIP_TOKEN=no #(13)\n      - VPN_PIA_PORT_FORWARD_PERSIST=false #(14)\n      - PRIVOXY_ENABLED=false #(19)\n      - UNBOUND_ENABLED=false #(21)\n      - UNBOUND_NAMESERVERS #(22)\n    cap_add:\n      - NET_ADMIN\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1 #(12)\n      - net.ipv6.conf.all.disable_ipv6=1 #(3)\n    devices:\n      - /dev/net/tun:/dev/net/tun # OPTIONAL(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui. On MacOS set it to <code>192.168.65.0/24</code> (Verify with your settings [Resources &gt; Network &gt; Docker subnet]).</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>. Affiliate links: Proton VPN Proton Unlimited Private Internet Access</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> (for PIA this is done automatically, see <code>VPN_PROVIDER</code> variable) located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32 in most cases\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>DANGEROUS! Don't enable unless you know what you are doing!</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>Some of the possible values are for example <code>wg</code>, <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>wg</code> will use the nameservers from the <code>wg0.conf</code> file. A value in the format <code>8.8.8.8</code> is to use a plain old nameserver. A value in the format <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>If you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice.</p> </li> <li> <p>This will start Privoxy on the default port 8118 when set to <code>true</code>. By default Privoxy is not exposed on the LAN, so if you need that, you'll have to add <code>VPN_EXPOSE_PORTS_ON_LAN=8118/tcp,8118/udp</code>.</p> </li> <li> <p>Enabling this will bring down the container if the connectivity tests fail at the end of the Wireguard init process or for an extended period during the container runtime.</p> </li> <li> <p>Enable Unbound by setting to <code>true</code> when VPN is not active.</p> </li> <li> <p>Possible values are <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>8.8.8.8</code> is to use a plain old nameserver. The value <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> </ol>"},{"location":"containers/nzbhydra2/","title":"hotio/nzbhydra2","text":"<p> GitHub ghcr.io</p>"},{"location":"containers/nzbhydra2/#starting-the-container","title":"Starting the container","text":"clicompose <pre><code>docker run --rm \\\n    --name nzbhydra2 \\\n    -p 5076:5076 \\\n    -e PUID=1000 \\\n    -e PGID=1000 \\\n    -e UMASK=002 \\\n    -e TZ=\"Etc/UTC\" \\\n    -v /&lt;host_folder_config&gt;:/config \\\n    ghcr.io/hotio/nzbhydra2\n</code></pre> <pre><code>services:\n  nzbhydra2:\n    container_name: nzbhydra2\n    image: ghcr.io/hotio/nzbhydra2\n    ports:\n      - \"5076:5076\"\n    environment:\n      - PUID=1000\n      - PGID=1000\n      - UMASK=002\n      - TZ=Etc/UTC\n    volumes:\n      - /&lt;host_folder_config&gt;:/config\n</code></pre>"},{"location":"containers/nzbhydra2/#tags","title":"Tags","text":"Tags Description Last Updated Age"},{"location":"containers/nzbhydra2/#wireguard","title":"WireGuard","text":"<p>Info</p> <p>This image includes VPN support. The cli/compose examples below are environment variables and settings complementary to the app image examples, this means you'll have to add/merge the stuff below with the stuff above. In case you are still in need of a VPN, consider using my affiliate links for Proton VPN, Proton Unlimited or Private Internet Access.</p> <p> </p> genericprotonpia clicompose <pre><code>docker run --rm \\\n    --hostname container-name.internal \\ #(18)\n    -e VPN_ENABLED=\"true\" \\ #(5)\n    -e VPN_CONF=\"wg0\" \\ #(8)\n    -e VPN_PROVIDER=\"generic\" \\ #(4)\n    -e VPN_LAN_NETWORK=\"192.168.1.0/24\" \\ #(1)\n    -e VPN_LAN_LEAK_ENABLED=\"false\" \\ #(10)\n    -e VPN_EXPOSE_PORTS_ON_LAN=\"\" \\ #(2)\n    -e VPN_AUTO_PORT_FORWARD=\"false\" \\ #(6)\n    -e VPN_AUTO_PORT_FORWARD_TO_PORTS=\"\" \\ #(15)\n    -e VPN_FIREWALL_TYPE=\"auto\" \\ #(17)\n    -e VPN_HEALTHCHECK_ENABLED=\"false\" \\ #(20)\n    -e VPN_NAMESERVERS=\"\" \\ #(16)\n    -e PRIVOXY_ENABLED=\"false\" \\ #(19)\n    -e UNBOUND_ENABLED=\"false\" \\ #(21)\n    -e UNBOUND_NAMESERVERS=\"\" \\ #(22)\n    --cap-add=NET_ADMIN \\\n    --sysctl=\"net.ipv4.conf.all.src_valid_mark=1\" \\ #(12)\n    --sysctl=\"net.ipv6.conf.all.disable_ipv6=1\" \\ #(3)\n    --device /dev/net/tun:/dev/net/tun \\ # OPTIONAL(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui. On MacOS set it to <code>192.168.65.0/24</code> (Verify with your settings [Resources &gt; Network &gt; Docker subnet]).</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>. Affiliate links: Proton VPN Proton Unlimited Private Internet Access</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> (for PIA this is done automatically, see <code>VPN_PROVIDER</code> variable) located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32 in most cases\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>DANGEROUS! Don't enable unless you know what you are doing!</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>Some of the possible values are for example <code>wg</code>, <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>wg</code> will use the nameservers from the <code>wg0.conf</code> file. A value in the format <code>8.8.8.8</code> is to use a plain old nameserver. A value in the format <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>If you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice.</p> </li> <li> <p>This will start Privoxy on the default port 8118 when set to <code>true</code>. By default Privoxy is not exposed on the LAN, so if you need that, you'll have to add <code>VPN_EXPOSE_PORTS_ON_LAN=8118/tcp,8118/udp</code>.</p> </li> <li> <p>Enabling this will bring down the container if the connectivity tests fail at the end of the Wireguard init process or for an extended period during the container runtime.</p> </li> <li> <p>Enable Unbound by setting to <code>true</code> when VPN is not active.</p> </li> <li> <p>Possible values are <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>8.8.8.8</code> is to use a plain old nameserver. The value <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> </ol> <pre><code>services:\n  app:\n    hostname: container-name.internal #(18)\n    environment:\n      - VPN_ENABLED=true #(5)\n      - VPN_CONF=wg0 #(8)\n      - VPN_PROVIDER=generic #(4)\n      - VPN_LAN_NETWORK=192.168.1.0/24 #(1)\n      - VPN_LAN_LEAK_ENABLED=false #(10)\n      - VPN_EXPOSE_PORTS_ON_LAN #(2)\n      - VPN_AUTO_PORT_FORWARD=false #(6)\n      - VPN_AUTO_PORT_FORWARD_TO_PORTS= #(15)\n      - VPN_FIREWALL_TYPE=auto #(17)\n      - VPN_HEALTHCHECK_ENABLED=false #(20)\n      - VPN_NAMESERVERS= #(16)\n      - PRIVOXY_ENABLED=false #(19)\n      - UNBOUND_ENABLED=false #(21)\n      - UNBOUND_NAMESERVERS #(22)\n    cap_add:\n      - NET_ADMIN\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1 #(12)\n      - net.ipv6.conf.all.disable_ipv6=1 #(3)\n    devices:\n      - /dev/net/tun:/dev/net/tun # OPTIONAL(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui. On MacOS set it to <code>192.168.65.0/24</code> (Verify with your settings [Resources &gt; Network &gt; Docker subnet]).</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>. Affiliate links: Proton VPN Proton Unlimited Private Internet Access</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> (for PIA this is done automatically, see <code>VPN_PROVIDER</code> variable) located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32 in most cases\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>DANGEROUS! Don't enable unless you know what you are doing!</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>Some of the possible values are for example <code>wg</code>, <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>wg</code> will use the nameservers from the <code>wg0.conf</code> file. A value in the format <code>8.8.8.8</code> is to use a plain old nameserver. A value in the format <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>If you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice.</p> </li> <li> <p>This will start Privoxy on the default port 8118 when set to <code>true</code>. By default Privoxy is not exposed on the LAN, so if you need that, you'll have to add <code>VPN_EXPOSE_PORTS_ON_LAN=8118/tcp,8118/udp</code>.</p> </li> <li> <p>Enabling this will bring down the container if the connectivity tests fail at the end of the Wireguard init process or for an extended period during the container runtime.</p> </li> <li> <p>Enable Unbound by setting to <code>true</code> when VPN is not active.</p> </li> <li> <p>Possible values are <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>8.8.8.8</code> is to use a plain old nameserver. The value <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> </ol> clicompose <pre><code>docker run --rm \\\n    --hostname container-name.internal \\ #(18)\n    -e VPN_ENABLED=\"true\" \\ #(5)\n    -e VPN_CONF=\"wg0\" \\ #(8)\n    -e VPN_PROVIDER=\"proton\" \\ #(4)\n    -e VPN_LAN_NETWORK=\"192.168.1.0/24\" \\ #(1)\n    -e VPN_LAN_LEAK_ENABLED=\"false\" \\ #(10)\n    -e VPN_EXPOSE_PORTS_ON_LAN=\"\" \\ #(2)\n    -e VPN_AUTO_PORT_FORWARD=\"true\" \\ #(6)\n    -e VPN_AUTO_PORT_FORWARD_TO_PORTS=\"\" \\ #(15)\n    -e VPN_FIREWALL_TYPE=\"auto\" \\ #(17)\n    -e VPN_HEALTHCHECK_ENABLED=\"false\" \\ #(20)\n    -e VPN_NAMESERVERS=\"\" \\ #(16)\n    -e PRIVOXY_ENABLED=\"false\" \\ #(19)\n    -e UNBOUND_ENABLED=\"false\" \\ #(21)\n    -e UNBOUND_NAMESERVERS=\"\" \\ #(22)\n    --cap-add=NET_ADMIN \\\n    --sysctl=\"net.ipv4.conf.all.src_valid_mark=1\" \\ #(12)\n    --sysctl=\"net.ipv6.conf.all.disable_ipv6=1\" \\ #(3)\n    --device /dev/net/tun:/dev/net/tun \\ # OPTIONAL(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui. On MacOS set it to <code>192.168.65.0/24</code> (Verify with your settings [Resources &gt; Network &gt; Docker subnet]).</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>. Affiliate links: Proton VPN Proton Unlimited Private Internet Access</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> (for PIA this is done automatically, see <code>VPN_PROVIDER</code> variable) located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32 in most cases\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>DANGEROUS! Don't enable unless you know what you are doing!</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>Some of the possible values are for example <code>wg</code>, <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>wg</code> will use the nameservers from the <code>wg0.conf</code> file. A value in the format <code>8.8.8.8</code> is to use a plain old nameserver. A value in the format <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>If you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice.</p> </li> <li> <p>This will start Privoxy on the default port 8118 when set to <code>true</code>. By default Privoxy is not exposed on the LAN, so if you need that, you'll have to add <code>VPN_EXPOSE_PORTS_ON_LAN=8118/tcp,8118/udp</code>.</p> </li> <li> <p>Enabling this will bring down the container if the connectivity tests fail at the end of the Wireguard init process or for an extended period during the container runtime.</p> </li> <li> <p>Enable Unbound by setting to <code>true</code> when VPN is not active.</p> </li> <li> <p>Possible values are <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>8.8.8.8</code> is to use a plain old nameserver. The value <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> </ol> <pre><code>services:\n  app:\n    hostname: container-name.internal #(18)\n    environment:\n      - VPN_ENABLED=true #(5)\n      - VPN_CONF=wg0 #(8)\n      - VPN_PROVIDER=proton #(4)\n      - VPN_LAN_NETWORK=192.168.1.0/24 #(1)\n      - VPN_LAN_LEAK_ENABLED=false #(10)\n      - VPN_EXPOSE_PORTS_ON_LAN #(2)\n      - VPN_AUTO_PORT_FORWARD=true #(6)\n      - VPN_AUTO_PORT_FORWARD_TO_PORTS= #(15)\n      - VPN_FIREWALL_TYPE=auto #(17)\n      - VPN_HEALTHCHECK_ENABLED=false #(20)\n      - VPN_NAMESERVERS= #(16)\n      - PRIVOXY_ENABLED=false #(19)\n      - UNBOUND_ENABLED=false #(21)\n      - UNBOUND_NAMESERVERS #(22)\n    cap_add:\n      - NET_ADMIN\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1 #(12)\n      - net.ipv6.conf.all.disable_ipv6=1 #(3)\n    devices:\n      - /dev/net/tun:/dev/net/tun # OPTIONAL(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui. On MacOS set it to <code>192.168.65.0/24</code> (Verify with your settings [Resources &gt; Network &gt; Docker subnet]).</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>. Affiliate links: Proton VPN Proton Unlimited Private Internet Access</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> (for PIA this is done automatically, see <code>VPN_PROVIDER</code> variable) located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32 in most cases\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>DANGEROUS! Don't enable unless you know what you are doing!</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>Some of the possible values are for example <code>wg</code>, <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>wg</code> will use the nameservers from the <code>wg0.conf</code> file. A value in the format <code>8.8.8.8</code> is to use a plain old nameserver. A value in the format <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>If you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice.</p> </li> <li> <p>This will start Privoxy on the default port 8118 when set to <code>true</code>. By default Privoxy is not exposed on the LAN, so if you need that, you'll have to add <code>VPN_EXPOSE_PORTS_ON_LAN=8118/tcp,8118/udp</code>.</p> </li> <li> <p>Enabling this will bring down the container if the connectivity tests fail at the end of the Wireguard init process or for an extended period during the container runtime.</p> </li> <li> <p>Enable Unbound by setting to <code>true</code> when VPN is not active.</p> </li> <li> <p>Possible values are <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>8.8.8.8</code> is to use a plain old nameserver. The value <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> </ol> clicompose <pre><code>docker run --rm \\\n    --hostname container-name.internal \\ #(18)\n    -e VPN_ENABLED=\"true\" \\ #(5)\n    -e VPN_CONF=\"wg0\" \\ #(8)\n    -e VPN_PROVIDER=\"pia\" \\ #(4)\n    -e VPN_LAN_NETWORK=\"192.168.1.0/24\" \\ #(1)\n    -e VPN_LAN_LEAK_ENABLED=\"false\" \\ #(10)\n    -e VPN_EXPOSE_PORTS_ON_LAN=\"\" \\ #(2)\n    -e VPN_AUTO_PORT_FORWARD=\"true\" \\ #(6)\n    -e VPN_AUTO_PORT_FORWARD_TO_PORTS=\"\" \\ #(15)\n    -e VPN_FIREWALL_TYPE=\"auto\" \\ #(17)\n    -e VPN_HEALTHCHECK_ENABLED=\"false\" \\ #(20)\n    -e VPN_NAMESERVERS=\"\" \\ #(16)\n    -e VPN_PIA_USER=\"\" \\ #(11)\n    -e VPN_PIA_PASS=\"\" \\ #(11)\n    -e VPN_PIA_PREFERRED_REGION=\"\" \\ #(7)\n    -e VPN_PIA_DIP_TOKEN=\"no\" \\ #(13)\n    -e VPN_PIA_PORT_FORWARD_PERSIST=\"false\" \\ #(14)\n    -e PRIVOXY_ENABLED=\"false\" \\ #(19)\n    -e UNBOUND_ENABLED=\"false\" \\ #(21)\n    -e UNBOUND_NAMESERVERS=\"\" \\ #(22)\n    --cap-add=NET_ADMIN \\\n    --sysctl=\"net.ipv4.conf.all.src_valid_mark=1\" \\ #(12)\n    --sysctl=\"net.ipv6.conf.all.disable_ipv6=1\" \\ #(3)\n    --device /dev/net/tun:/dev/net/tun \\ # OPTIONAL(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui. On MacOS set it to <code>192.168.65.0/24</code> (Verify with your settings [Resources &gt; Network &gt; Docker subnet]).</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>. Affiliate links: Proton VPN Proton Unlimited Private Internet Access</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> (for PIA this is done automatically, see <code>VPN_PROVIDER</code> variable) located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32 in most cases\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>DANGEROUS! Don't enable unless you know what you are doing!</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>Some of the possible values are for example <code>wg</code>, <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>wg</code> will use the nameservers from the <code>wg0.conf</code> file. A value in the format <code>8.8.8.8</code> is to use a plain old nameserver. A value in the format <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>If you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice.</p> </li> <li> <p>This will start Privoxy on the default port 8118 when set to <code>true</code>. By default Privoxy is not exposed on the LAN, so if you need that, you'll have to add <code>VPN_EXPOSE_PORTS_ON_LAN=8118/tcp,8118/udp</code>.</p> </li> <li> <p>Enabling this will bring down the container if the connectivity tests fail at the end of the Wireguard init process or for an extended period during the container runtime.</p> </li> <li> <p>Enable Unbound by setting to <code>true</code> when VPN is not active.</p> </li> <li> <p>Possible values are <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>8.8.8.8</code> is to use a plain old nameserver. The value <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> </ol> <pre><code>services:\n  app:\n    hostname: container-name.internal #(18)\n    environment:\n      - VPN_ENABLED=true #(5)\n      - VPN_CONF=wg0 #(8)\n      - VPN_PROVIDER=pia #(4)\n      - VPN_LAN_NETWORK=192.168.1.0/24 #(1)\n      - VPN_LAN_LEAK_ENABLED=false #(10)\n      - VPN_EXPOSE_PORTS_ON_LAN #(2)\n      - VPN_AUTO_PORT_FORWARD=true #(6)\n      - VPN_AUTO_PORT_FORWARD_TO_PORTS= #(15)\n      - VPN_FIREWALL_TYPE=auto #(17)\n      - VPN_HEALTHCHECK_ENABLED=false #(20)\n      - VPN_NAMESERVERS= #(16)\n      - VPN_PIA_USER #(11)\n      - VPN_PIA_PASS #(11)\n      - VPN_PIA_PREFERRED_REGION #(7)\n      - VPN_PIA_DIP_TOKEN=no #(13)\n      - VPN_PIA_PORT_FORWARD_PERSIST=false #(14)\n      - PRIVOXY_ENABLED=false #(19)\n      - UNBOUND_ENABLED=false #(21)\n      - UNBOUND_NAMESERVERS #(22)\n    cap_add:\n      - NET_ADMIN\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1 #(12)\n      - net.ipv6.conf.all.disable_ipv6=1 #(3)\n    devices:\n      - /dev/net/tun:/dev/net/tun # OPTIONAL(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui. On MacOS set it to <code>192.168.65.0/24</code> (Verify with your settings [Resources &gt; Network &gt; Docker subnet]).</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>. Affiliate links: Proton VPN Proton Unlimited Private Internet Access</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> (for PIA this is done automatically, see <code>VPN_PROVIDER</code> variable) located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32 in most cases\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>DANGEROUS! Don't enable unless you know what you are doing!</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>Some of the possible values are for example <code>wg</code>, <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>wg</code> will use the nameservers from the <code>wg0.conf</code> file. A value in the format <code>8.8.8.8</code> is to use a plain old nameserver. A value in the format <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>If you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice.</p> </li> <li> <p>This will start Privoxy on the default port 8118 when set to <code>true</code>. By default Privoxy is not exposed on the LAN, so if you need that, you'll have to add <code>VPN_EXPOSE_PORTS_ON_LAN=8118/tcp,8118/udp</code>.</p> </li> <li> <p>Enabling this will bring down the container if the connectivity tests fail at the end of the Wireguard init process or for an extended period during the container runtime.</p> </li> <li> <p>Enable Unbound by setting to <code>true</code> when VPN is not active.</p> </li> <li> <p>Possible values are <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>8.8.8.8</code> is to use a plain old nameserver. The value <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> </ol>"},{"location":"containers/overseerr/","title":"hotio/overseerr","text":"<p> GitHub ghcr.io</p>"},{"location":"containers/overseerr/#starting-the-container","title":"Starting the container","text":"clicompose <pre><code>docker run --rm \\\n    --name overseerr \\\n    -p 5055:5055 \\\n    -e PUID=1000 \\\n    -e PGID=1000 \\\n    -e UMASK=002 \\\n    -e TZ=\"Etc/UTC\" \\\n    -v /&lt;host_folder_config&gt;:/config \\\n    ghcr.io/hotio/overseerr\n</code></pre> <pre><code>services:\n  overseerr:\n    container_name: overseerr\n    image: ghcr.io/hotio/overseerr\n    ports:\n      - \"5055:5055\"\n    environment:\n      - PUID=1000\n      - PGID=1000\n      - UMASK=002\n      - TZ=Etc/UTC\n    volumes:\n      - /&lt;host_folder_config&gt;:/config\n</code></pre>"},{"location":"containers/overseerr/#tags","title":"Tags","text":"Tags Description Last Updated Age"},{"location":"containers/overseerr/#wireguard","title":"WireGuard","text":"<p>Info</p> <p>This image includes VPN support. The cli/compose examples below are environment variables and settings complementary to the app image examples, this means you'll have to add/merge the stuff below with the stuff above. In case you are still in need of a VPN, consider using my affiliate links for Proton VPN, Proton Unlimited or Private Internet Access.</p> <p> </p> genericprotonpia clicompose <pre><code>docker run --rm \\\n    --hostname container-name.internal \\ #(18)\n    -e VPN_ENABLED=\"true\" \\ #(5)\n    -e VPN_CONF=\"wg0\" \\ #(8)\n    -e VPN_PROVIDER=\"generic\" \\ #(4)\n    -e VPN_LAN_NETWORK=\"192.168.1.0/24\" \\ #(1)\n    -e VPN_LAN_LEAK_ENABLED=\"false\" \\ #(10)\n    -e VPN_EXPOSE_PORTS_ON_LAN=\"\" \\ #(2)\n    -e VPN_AUTO_PORT_FORWARD=\"false\" \\ #(6)\n    -e VPN_AUTO_PORT_FORWARD_TO_PORTS=\"\" \\ #(15)\n    -e VPN_FIREWALL_TYPE=\"auto\" \\ #(17)\n    -e VPN_HEALTHCHECK_ENABLED=\"false\" \\ #(20)\n    -e VPN_NAMESERVERS=\"\" \\ #(16)\n    -e PRIVOXY_ENABLED=\"false\" \\ #(19)\n    -e UNBOUND_ENABLED=\"false\" \\ #(21)\n    -e UNBOUND_NAMESERVERS=\"\" \\ #(22)\n    --cap-add=NET_ADMIN \\\n    --sysctl=\"net.ipv4.conf.all.src_valid_mark=1\" \\ #(12)\n    --sysctl=\"net.ipv6.conf.all.disable_ipv6=1\" \\ #(3)\n    --device /dev/net/tun:/dev/net/tun \\ # OPTIONAL(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui. On MacOS set it to <code>192.168.65.0/24</code> (Verify with your settings [Resources &gt; Network &gt; Docker subnet]).</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>. Affiliate links: Proton VPN Proton Unlimited Private Internet Access</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> (for PIA this is done automatically, see <code>VPN_PROVIDER</code> variable) located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32 in most cases\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>DANGEROUS! Don't enable unless you know what you are doing!</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>Some of the possible values are for example <code>wg</code>, <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>wg</code> will use the nameservers from the <code>wg0.conf</code> file. A value in the format <code>8.8.8.8</code> is to use a plain old nameserver. A value in the format <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>If you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice.</p> </li> <li> <p>This will start Privoxy on the default port 8118 when set to <code>true</code>. By default Privoxy is not exposed on the LAN, so if you need that, you'll have to add <code>VPN_EXPOSE_PORTS_ON_LAN=8118/tcp,8118/udp</code>.</p> </li> <li> <p>Enabling this will bring down the container if the connectivity tests fail at the end of the Wireguard init process or for an extended period during the container runtime.</p> </li> <li> <p>Enable Unbound by setting to <code>true</code> when VPN is not active.</p> </li> <li> <p>Possible values are <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>8.8.8.8</code> is to use a plain old nameserver. The value <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> </ol> <pre><code>services:\n  app:\n    hostname: container-name.internal #(18)\n    environment:\n      - VPN_ENABLED=true #(5)\n      - VPN_CONF=wg0 #(8)\n      - VPN_PROVIDER=generic #(4)\n      - VPN_LAN_NETWORK=192.168.1.0/24 #(1)\n      - VPN_LAN_LEAK_ENABLED=false #(10)\n      - VPN_EXPOSE_PORTS_ON_LAN #(2)\n      - VPN_AUTO_PORT_FORWARD=false #(6)\n      - VPN_AUTO_PORT_FORWARD_TO_PORTS= #(15)\n      - VPN_FIREWALL_TYPE=auto #(17)\n      - VPN_HEALTHCHECK_ENABLED=false #(20)\n      - VPN_NAMESERVERS= #(16)\n      - PRIVOXY_ENABLED=false #(19)\n      - UNBOUND_ENABLED=false #(21)\n      - UNBOUND_NAMESERVERS #(22)\n    cap_add:\n      - NET_ADMIN\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1 #(12)\n      - net.ipv6.conf.all.disable_ipv6=1 #(3)\n    devices:\n      - /dev/net/tun:/dev/net/tun # OPTIONAL(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui. On MacOS set it to <code>192.168.65.0/24</code> (Verify with your settings [Resources &gt; Network &gt; Docker subnet]).</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>. Affiliate links: Proton VPN Proton Unlimited Private Internet Access</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> (for PIA this is done automatically, see <code>VPN_PROVIDER</code> variable) located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32 in most cases\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>DANGEROUS! Don't enable unless you know what you are doing!</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>Some of the possible values are for example <code>wg</code>, <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>wg</code> will use the nameservers from the <code>wg0.conf</code> file. A value in the format <code>8.8.8.8</code> is to use a plain old nameserver. A value in the format <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>If you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice.</p> </li> <li> <p>This will start Privoxy on the default port 8118 when set to <code>true</code>. By default Privoxy is not exposed on the LAN, so if you need that, you'll have to add <code>VPN_EXPOSE_PORTS_ON_LAN=8118/tcp,8118/udp</code>.</p> </li> <li> <p>Enabling this will bring down the container if the connectivity tests fail at the end of the Wireguard init process or for an extended period during the container runtime.</p> </li> <li> <p>Enable Unbound by setting to <code>true</code> when VPN is not active.</p> </li> <li> <p>Possible values are <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>8.8.8.8</code> is to use a plain old nameserver. The value <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> </ol> clicompose <pre><code>docker run --rm \\\n    --hostname container-name.internal \\ #(18)\n    -e VPN_ENABLED=\"true\" \\ #(5)\n    -e VPN_CONF=\"wg0\" \\ #(8)\n    -e VPN_PROVIDER=\"proton\" \\ #(4)\n    -e VPN_LAN_NETWORK=\"192.168.1.0/24\" \\ #(1)\n    -e VPN_LAN_LEAK_ENABLED=\"false\" \\ #(10)\n    -e VPN_EXPOSE_PORTS_ON_LAN=\"\" \\ #(2)\n    -e VPN_AUTO_PORT_FORWARD=\"true\" \\ #(6)\n    -e VPN_AUTO_PORT_FORWARD_TO_PORTS=\"\" \\ #(15)\n    -e VPN_FIREWALL_TYPE=\"auto\" \\ #(17)\n    -e VPN_HEALTHCHECK_ENABLED=\"false\" \\ #(20)\n    -e VPN_NAMESERVERS=\"\" \\ #(16)\n    -e PRIVOXY_ENABLED=\"false\" \\ #(19)\n    -e UNBOUND_ENABLED=\"false\" \\ #(21)\n    -e UNBOUND_NAMESERVERS=\"\" \\ #(22)\n    --cap-add=NET_ADMIN \\\n    --sysctl=\"net.ipv4.conf.all.src_valid_mark=1\" \\ #(12)\n    --sysctl=\"net.ipv6.conf.all.disable_ipv6=1\" \\ #(3)\n    --device /dev/net/tun:/dev/net/tun \\ # OPTIONAL(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui. On MacOS set it to <code>192.168.65.0/24</code> (Verify with your settings [Resources &gt; Network &gt; Docker subnet]).</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>. Affiliate links: Proton VPN Proton Unlimited Private Internet Access</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> (for PIA this is done automatically, see <code>VPN_PROVIDER</code> variable) located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32 in most cases\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>DANGEROUS! Don't enable unless you know what you are doing!</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>Some of the possible values are for example <code>wg</code>, <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>wg</code> will use the nameservers from the <code>wg0.conf</code> file. A value in the format <code>8.8.8.8</code> is to use a plain old nameserver. A value in the format <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>If you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice.</p> </li> <li> <p>This will start Privoxy on the default port 8118 when set to <code>true</code>. By default Privoxy is not exposed on the LAN, so if you need that, you'll have to add <code>VPN_EXPOSE_PORTS_ON_LAN=8118/tcp,8118/udp</code>.</p> </li> <li> <p>Enabling this will bring down the container if the connectivity tests fail at the end of the Wireguard init process or for an extended period during the container runtime.</p> </li> <li> <p>Enable Unbound by setting to <code>true</code> when VPN is not active.</p> </li> <li> <p>Possible values are <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>8.8.8.8</code> is to use a plain old nameserver. The value <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> </ol> <pre><code>services:\n  app:\n    hostname: container-name.internal #(18)\n    environment:\n      - VPN_ENABLED=true #(5)\n      - VPN_CONF=wg0 #(8)\n      - VPN_PROVIDER=proton #(4)\n      - VPN_LAN_NETWORK=192.168.1.0/24 #(1)\n      - VPN_LAN_LEAK_ENABLED=false #(10)\n      - VPN_EXPOSE_PORTS_ON_LAN #(2)\n      - VPN_AUTO_PORT_FORWARD=true #(6)\n      - VPN_AUTO_PORT_FORWARD_TO_PORTS= #(15)\n      - VPN_FIREWALL_TYPE=auto #(17)\n      - VPN_HEALTHCHECK_ENABLED=false #(20)\n      - VPN_NAMESERVERS= #(16)\n      - PRIVOXY_ENABLED=false #(19)\n      - UNBOUND_ENABLED=false #(21)\n      - UNBOUND_NAMESERVERS #(22)\n    cap_add:\n      - NET_ADMIN\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1 #(12)\n      - net.ipv6.conf.all.disable_ipv6=1 #(3)\n    devices:\n      - /dev/net/tun:/dev/net/tun # OPTIONAL(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui. On MacOS set it to <code>192.168.65.0/24</code> (Verify with your settings [Resources &gt; Network &gt; Docker subnet]).</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>. Affiliate links: Proton VPN Proton Unlimited Private Internet Access</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> (for PIA this is done automatically, see <code>VPN_PROVIDER</code> variable) located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32 in most cases\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>DANGEROUS! Don't enable unless you know what you are doing!</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>Some of the possible values are for example <code>wg</code>, <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>wg</code> will use the nameservers from the <code>wg0.conf</code> file. A value in the format <code>8.8.8.8</code> is to use a plain old nameserver. A value in the format <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>If you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice.</p> </li> <li> <p>This will start Privoxy on the default port 8118 when set to <code>true</code>. By default Privoxy is not exposed on the LAN, so if you need that, you'll have to add <code>VPN_EXPOSE_PORTS_ON_LAN=8118/tcp,8118/udp</code>.</p> </li> <li> <p>Enabling this will bring down the container if the connectivity tests fail at the end of the Wireguard init process or for an extended period during the container runtime.</p> </li> <li> <p>Enable Unbound by setting to <code>true</code> when VPN is not active.</p> </li> <li> <p>Possible values are <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>8.8.8.8</code> is to use a plain old nameserver. The value <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> </ol> clicompose <pre><code>docker run --rm \\\n    --hostname container-name.internal \\ #(18)\n    -e VPN_ENABLED=\"true\" \\ #(5)\n    -e VPN_CONF=\"wg0\" \\ #(8)\n    -e VPN_PROVIDER=\"pia\" \\ #(4)\n    -e VPN_LAN_NETWORK=\"192.168.1.0/24\" \\ #(1)\n    -e VPN_LAN_LEAK_ENABLED=\"false\" \\ #(10)\n    -e VPN_EXPOSE_PORTS_ON_LAN=\"\" \\ #(2)\n    -e VPN_AUTO_PORT_FORWARD=\"true\" \\ #(6)\n    -e VPN_AUTO_PORT_FORWARD_TO_PORTS=\"\" \\ #(15)\n    -e VPN_FIREWALL_TYPE=\"auto\" \\ #(17)\n    -e VPN_HEALTHCHECK_ENABLED=\"false\" \\ #(20)\n    -e VPN_NAMESERVERS=\"\" \\ #(16)\n    -e VPN_PIA_USER=\"\" \\ #(11)\n    -e VPN_PIA_PASS=\"\" \\ #(11)\n    -e VPN_PIA_PREFERRED_REGION=\"\" \\ #(7)\n    -e VPN_PIA_DIP_TOKEN=\"no\" \\ #(13)\n    -e VPN_PIA_PORT_FORWARD_PERSIST=\"false\" \\ #(14)\n    -e PRIVOXY_ENABLED=\"false\" \\ #(19)\n    -e UNBOUND_ENABLED=\"false\" \\ #(21)\n    -e UNBOUND_NAMESERVERS=\"\" \\ #(22)\n    --cap-add=NET_ADMIN \\\n    --sysctl=\"net.ipv4.conf.all.src_valid_mark=1\" \\ #(12)\n    --sysctl=\"net.ipv6.conf.all.disable_ipv6=1\" \\ #(3)\n    --device /dev/net/tun:/dev/net/tun \\ # OPTIONAL(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui. On MacOS set it to <code>192.168.65.0/24</code> (Verify with your settings [Resources &gt; Network &gt; Docker subnet]).</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>. Affiliate links: Proton VPN Proton Unlimited Private Internet Access</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> (for PIA this is done automatically, see <code>VPN_PROVIDER</code> variable) located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32 in most cases\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>DANGEROUS! Don't enable unless you know what you are doing!</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>Some of the possible values are for example <code>wg</code>, <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>wg</code> will use the nameservers from the <code>wg0.conf</code> file. A value in the format <code>8.8.8.8</code> is to use a plain old nameserver. A value in the format <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>If you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice.</p> </li> <li> <p>This will start Privoxy on the default port 8118 when set to <code>true</code>. By default Privoxy is not exposed on the LAN, so if you need that, you'll have to add <code>VPN_EXPOSE_PORTS_ON_LAN=8118/tcp,8118/udp</code>.</p> </li> <li> <p>Enabling this will bring down the container if the connectivity tests fail at the end of the Wireguard init process or for an extended period during the container runtime.</p> </li> <li> <p>Enable Unbound by setting to <code>true</code> when VPN is not active.</p> </li> <li> <p>Possible values are <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>8.8.8.8</code> is to use a plain old nameserver. The value <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> </ol> <pre><code>services:\n  app:\n    hostname: container-name.internal #(18)\n    environment:\n      - VPN_ENABLED=true #(5)\n      - VPN_CONF=wg0 #(8)\n      - VPN_PROVIDER=pia #(4)\n      - VPN_LAN_NETWORK=192.168.1.0/24 #(1)\n      - VPN_LAN_LEAK_ENABLED=false #(10)\n      - VPN_EXPOSE_PORTS_ON_LAN #(2)\n      - VPN_AUTO_PORT_FORWARD=true #(6)\n      - VPN_AUTO_PORT_FORWARD_TO_PORTS= #(15)\n      - VPN_FIREWALL_TYPE=auto #(17)\n      - VPN_HEALTHCHECK_ENABLED=false #(20)\n      - VPN_NAMESERVERS= #(16)\n      - VPN_PIA_USER #(11)\n      - VPN_PIA_PASS #(11)\n      - VPN_PIA_PREFERRED_REGION #(7)\n      - VPN_PIA_DIP_TOKEN=no #(13)\n      - VPN_PIA_PORT_FORWARD_PERSIST=false #(14)\n      - PRIVOXY_ENABLED=false #(19)\n      - UNBOUND_ENABLED=false #(21)\n      - UNBOUND_NAMESERVERS #(22)\n    cap_add:\n      - NET_ADMIN\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1 #(12)\n      - net.ipv6.conf.all.disable_ipv6=1 #(3)\n    devices:\n      - /dev/net/tun:/dev/net/tun # OPTIONAL(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui. On MacOS set it to <code>192.168.65.0/24</code> (Verify with your settings [Resources &gt; Network &gt; Docker subnet]).</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>. Affiliate links: Proton VPN Proton Unlimited Private Internet Access</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> (for PIA this is done automatically, see <code>VPN_PROVIDER</code> variable) located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32 in most cases\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>DANGEROUS! Don't enable unless you know what you are doing!</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>Some of the possible values are for example <code>wg</code>, <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>wg</code> will use the nameservers from the <code>wg0.conf</code> file. A value in the format <code>8.8.8.8</code> is to use a plain old nameserver. A value in the format <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>If you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice.</p> </li> <li> <p>This will start Privoxy on the default port 8118 when set to <code>true</code>. By default Privoxy is not exposed on the LAN, so if you need that, you'll have to add <code>VPN_EXPOSE_PORTS_ON_LAN=8118/tcp,8118/udp</code>.</p> </li> <li> <p>Enabling this will bring down the container if the connectivity tests fail at the end of the Wireguard init process or for an extended period during the container runtime.</p> </li> <li> <p>Enable Unbound by setting to <code>true</code> when VPN is not active.</p> </li> <li> <p>Possible values are <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>8.8.8.8</code> is to use a plain old nameserver. The value <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> </ol>"},{"location":"containers/plex/","title":"hotio/plex","text":"<p> GitHub ghcr.io</p>"},{"location":"containers/plex/#starting-the-container","title":"Starting the container","text":"clicompose <pre><code>docker run --rm \\\n    --name plex \\\n    -p 32400:32400 \\\n    -e PUID=1000 \\\n    -e PGID=1000 \\\n    -e UMASK=002 \\\n    -e TZ=\"Etc/UTC\" \\\n    -e PLEX_CLAIM_TOKEN=\"\" \\\n    -e PLEX_ADVERTISE_URL=\"\" \\\n    -e PLEX_NO_AUTH_NETWORKS=\"\" \\\n    -e PLEX_BETA_INSTALL=\"false\" \\\n    -e PLEX_PURGE_CODECS=\"false\" \\\n    -v /&lt;host_folder_config&gt;:/config \\\n    -v /&lt;host_folder_transcode&gt;:/transcode \\\n    -v /&lt;host_folder_data&gt;:/data \\\n    ghcr.io/hotio/plex\n</code></pre> <pre><code>services:\n  plex:\n    container_name: plex\n    image: ghcr.io/hotio/plex\n    ports:\n      - \"32400:32400\"\n    environment:\n      - PUID=1000\n      - PGID=1000\n      - UMASK=002\n      - TZ=Etc/UTC\n      - PLEX_CLAIM_TOKEN\n      - PLEX_ADVERTISE_URL\n      - PLEX_NO_AUTH_NETWORKS\n      - PLEX_BETA_INSTALL=false\n      - PLEX_PURGE_CODECS=false\n    volumes:\n      - /&lt;host_folder_config&gt;:/config\n      - /&lt;host_folder_transcode&gt;:/transcode\n      - /&lt;host_folder_data&gt;:/data\n</code></pre>"},{"location":"containers/plex/#tags","title":"Tags","text":"Tags Description Last Updated Age"},{"location":"containers/plex/#volumes","title":"Volumes","text":"<p>By default the container has 2 volumes defined, the volume <code>/config</code> that contains the configuration files and the volume <code>/transcode</code> which is used as the default transcode directory.</p>"},{"location":"containers/plex/#claim-your-server","title":"Claim your server","text":"<p>When running Plex on a docker <code>bridge</code> network, you can't just get to the webui and start configuring it, you'll need to claim it first. Go to plex.tv/claim and login with your account, copy the claim token and add it to the environment variable like this <code>-e PLEX_CLAIM_TOKEN=\"claim-xxxxxxxxxxxxxxxxxxxx\"</code>. When starting the new plex server for the first time, the server will be added to your account.</p>"},{"location":"containers/plex/#plex-beta","title":"Plex Beta","text":"<p>If you are a Plex Pass subscriber, you can enable the install of beta builds with <code>-e PLEX_BETA_INSTALL=\"true\"</code>. When the container starts, a version check is done for the latest beta and installed if a newer version is found.</p>"},{"location":"containers/plex/#environment-variables-plex_advertise_url-and-plex_no_auth_networks","title":"Environment variables PLEX_ADVERTISE_URL and PLEX_NO_AUTH_NETWORKS","text":"<p>The variables correspond to the below plex network settings.</p> <p></p> <p>The variable <code>PLEX_ADVERTISE_URL</code> is useful to aid your local clients in discovering your plex server when running in the <code>bridge</code> network mode. Most likely you would use something like <code>http://192.168.0.10:32400</code>. You could use <code>PLEX_NO_AUTH_NETWORKS</code> when you're locked out and need to regain access without providing credentials.</p>"},{"location":"containers/plex/#getting-a-token","title":"Getting a token","text":"<p>The following command will interactively ask for your credentials and give you a token. If you don't use 2FA, just press enter.</p> <pre><code>docker run --rm -it --entrypoint=\"\" hotio/plex bash /app/get-token.sh\n</code></pre>"},{"location":"containers/plex/#top-secret-stuff","title":"TOP secret stuff","text":"<p>If you do <code>-e PLEX_BETA_INSTALL=\"https://...\"</code>, stuff happens for which no support will be given.</p>"},{"location":"containers/plex/#wireguard","title":"WireGuard","text":"<p>Info</p> <p>This image includes VPN support. The cli/compose examples below are environment variables and settings complementary to the app image examples, this means you'll have to add/merge the stuff below with the stuff above. In case you are still in need of a VPN, consider using my affiliate links for Proton VPN, Proton Unlimited or Private Internet Access.</p> <p> </p> genericprotonpia clicompose <pre><code>docker run --rm \\\n    --hostname container-name.internal \\ #(18)\n    -e VPN_ENABLED=\"true\" \\ #(5)\n    -e VPN_CONF=\"wg0\" \\ #(8)\n    -e VPN_PROVIDER=\"generic\" \\ #(4)\n    -e VPN_LAN_NETWORK=\"192.168.1.0/24\" \\ #(1)\n    -e VPN_LAN_LEAK_ENABLED=\"false\" \\ #(10)\n    -e VPN_EXPOSE_PORTS_ON_LAN=\"\" \\ #(2)\n    -e VPN_AUTO_PORT_FORWARD=\"false\" \\ #(6)\n    -e VPN_AUTO_PORT_FORWARD_TO_PORTS=\"\" \\ #(15)\n    -e VPN_FIREWALL_TYPE=\"auto\" \\ #(17)\n    -e VPN_HEALTHCHECK_ENABLED=\"false\" \\ #(20)\n    -e VPN_NAMESERVERS=\"\" \\ #(16)\n    -e PRIVOXY_ENABLED=\"false\" \\ #(19)\n    -e UNBOUND_ENABLED=\"false\" \\ #(21)\n    -e UNBOUND_NAMESERVERS=\"\" \\ #(22)\n    --cap-add=NET_ADMIN \\\n    --sysctl=\"net.ipv4.conf.all.src_valid_mark=1\" \\ #(12)\n    --sysctl=\"net.ipv6.conf.all.disable_ipv6=1\" \\ #(3)\n    --device /dev/net/tun:/dev/net/tun \\ # OPTIONAL(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui. On MacOS set it to <code>192.168.65.0/24</code> (Verify with your settings [Resources &gt; Network &gt; Docker subnet]).</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>. Affiliate links: Proton VPN Proton Unlimited Private Internet Access</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> (for PIA this is done automatically, see <code>VPN_PROVIDER</code> variable) located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32 in most cases\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>DANGEROUS! Don't enable unless you know what you are doing!</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>Some of the possible values are for example <code>wg</code>, <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>wg</code> will use the nameservers from the <code>wg0.conf</code> file. A value in the format <code>8.8.8.8</code> is to use a plain old nameserver. A value in the format <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>If you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice.</p> </li> <li> <p>This will start Privoxy on the default port 8118 when set to <code>true</code>. By default Privoxy is not exposed on the LAN, so if you need that, you'll have to add <code>VPN_EXPOSE_PORTS_ON_LAN=8118/tcp,8118/udp</code>.</p> </li> <li> <p>Enabling this will bring down the container if the connectivity tests fail at the end of the Wireguard init process or for an extended period during the container runtime.</p> </li> <li> <p>Enable Unbound by setting to <code>true</code> when VPN is not active.</p> </li> <li> <p>Possible values are <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>8.8.8.8</code> is to use a plain old nameserver. The value <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> </ol> <pre><code>services:\n  app:\n    hostname: container-name.internal #(18)\n    environment:\n      - VPN_ENABLED=true #(5)\n      - VPN_CONF=wg0 #(8)\n      - VPN_PROVIDER=generic #(4)\n      - VPN_LAN_NETWORK=192.168.1.0/24 #(1)\n      - VPN_LAN_LEAK_ENABLED=false #(10)\n      - VPN_EXPOSE_PORTS_ON_LAN #(2)\n      - VPN_AUTO_PORT_FORWARD=false #(6)\n      - VPN_AUTO_PORT_FORWARD_TO_PORTS= #(15)\n      - VPN_FIREWALL_TYPE=auto #(17)\n      - VPN_HEALTHCHECK_ENABLED=false #(20)\n      - VPN_NAMESERVERS= #(16)\n      - PRIVOXY_ENABLED=false #(19)\n      - UNBOUND_ENABLED=false #(21)\n      - UNBOUND_NAMESERVERS #(22)\n    cap_add:\n      - NET_ADMIN\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1 #(12)\n      - net.ipv6.conf.all.disable_ipv6=1 #(3)\n    devices:\n      - /dev/net/tun:/dev/net/tun # OPTIONAL(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui. On MacOS set it to <code>192.168.65.0/24</code> (Verify with your settings [Resources &gt; Network &gt; Docker subnet]).</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>. Affiliate links: Proton VPN Proton Unlimited Private Internet Access</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> (for PIA this is done automatically, see <code>VPN_PROVIDER</code> variable) located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32 in most cases\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>DANGEROUS! Don't enable unless you know what you are doing!</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>Some of the possible values are for example <code>wg</code>, <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>wg</code> will use the nameservers from the <code>wg0.conf</code> file. A value in the format <code>8.8.8.8</code> is to use a plain old nameserver. A value in the format <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>If you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice.</p> </li> <li> <p>This will start Privoxy on the default port 8118 when set to <code>true</code>. By default Privoxy is not exposed on the LAN, so if you need that, you'll have to add <code>VPN_EXPOSE_PORTS_ON_LAN=8118/tcp,8118/udp</code>.</p> </li> <li> <p>Enabling this will bring down the container if the connectivity tests fail at the end of the Wireguard init process or for an extended period during the container runtime.</p> </li> <li> <p>Enable Unbound by setting to <code>true</code> when VPN is not active.</p> </li> <li> <p>Possible values are <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>8.8.8.8</code> is to use a plain old nameserver. The value <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> </ol> clicompose <pre><code>docker run --rm \\\n    --hostname container-name.internal \\ #(18)\n    -e VPN_ENABLED=\"true\" \\ #(5)\n    -e VPN_CONF=\"wg0\" \\ #(8)\n    -e VPN_PROVIDER=\"proton\" \\ #(4)\n    -e VPN_LAN_NETWORK=\"192.168.1.0/24\" \\ #(1)\n    -e VPN_LAN_LEAK_ENABLED=\"false\" \\ #(10)\n    -e VPN_EXPOSE_PORTS_ON_LAN=\"\" \\ #(2)\n    -e VPN_AUTO_PORT_FORWARD=\"true\" \\ #(6)\n    -e VPN_AUTO_PORT_FORWARD_TO_PORTS=\"\" \\ #(15)\n    -e VPN_FIREWALL_TYPE=\"auto\" \\ #(17)\n    -e VPN_HEALTHCHECK_ENABLED=\"false\" \\ #(20)\n    -e VPN_NAMESERVERS=\"\" \\ #(16)\n    -e PRIVOXY_ENABLED=\"false\" \\ #(19)\n    -e UNBOUND_ENABLED=\"false\" \\ #(21)\n    -e UNBOUND_NAMESERVERS=\"\" \\ #(22)\n    --cap-add=NET_ADMIN \\\n    --sysctl=\"net.ipv4.conf.all.src_valid_mark=1\" \\ #(12)\n    --sysctl=\"net.ipv6.conf.all.disable_ipv6=1\" \\ #(3)\n    --device /dev/net/tun:/dev/net/tun \\ # OPTIONAL(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui. On MacOS set it to <code>192.168.65.0/24</code> (Verify with your settings [Resources &gt; Network &gt; Docker subnet]).</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>. Affiliate links: Proton VPN Proton Unlimited Private Internet Access</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> (for PIA this is done automatically, see <code>VPN_PROVIDER</code> variable) located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32 in most cases\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>DANGEROUS! Don't enable unless you know what you are doing!</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>Some of the possible values are for example <code>wg</code>, <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>wg</code> will use the nameservers from the <code>wg0.conf</code> file. A value in the format <code>8.8.8.8</code> is to use a plain old nameserver. A value in the format <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>If you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice.</p> </li> <li> <p>This will start Privoxy on the default port 8118 when set to <code>true</code>. By default Privoxy is not exposed on the LAN, so if you need that, you'll have to add <code>VPN_EXPOSE_PORTS_ON_LAN=8118/tcp,8118/udp</code>.</p> </li> <li> <p>Enabling this will bring down the container if the connectivity tests fail at the end of the Wireguard init process or for an extended period during the container runtime.</p> </li> <li> <p>Enable Unbound by setting to <code>true</code> when VPN is not active.</p> </li> <li> <p>Possible values are <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>8.8.8.8</code> is to use a plain old nameserver. The value <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> </ol> <pre><code>services:\n  app:\n    hostname: container-name.internal #(18)\n    environment:\n      - VPN_ENABLED=true #(5)\n      - VPN_CONF=wg0 #(8)\n      - VPN_PROVIDER=proton #(4)\n      - VPN_LAN_NETWORK=192.168.1.0/24 #(1)\n      - VPN_LAN_LEAK_ENABLED=false #(10)\n      - VPN_EXPOSE_PORTS_ON_LAN #(2)\n      - VPN_AUTO_PORT_FORWARD=true #(6)\n      - VPN_AUTO_PORT_FORWARD_TO_PORTS= #(15)\n      - VPN_FIREWALL_TYPE=auto #(17)\n      - VPN_HEALTHCHECK_ENABLED=false #(20)\n      - VPN_NAMESERVERS= #(16)\n      - PRIVOXY_ENABLED=false #(19)\n      - UNBOUND_ENABLED=false #(21)\n      - UNBOUND_NAMESERVERS #(22)\n    cap_add:\n      - NET_ADMIN\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1 #(12)\n      - net.ipv6.conf.all.disable_ipv6=1 #(3)\n    devices:\n      - /dev/net/tun:/dev/net/tun # OPTIONAL(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui. On MacOS set it to <code>192.168.65.0/24</code> (Verify with your settings [Resources &gt; Network &gt; Docker subnet]).</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>. Affiliate links: Proton VPN Proton Unlimited Private Internet Access</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> (for PIA this is done automatically, see <code>VPN_PROVIDER</code> variable) located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32 in most cases\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>DANGEROUS! Don't enable unless you know what you are doing!</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>Some of the possible values are for example <code>wg</code>, <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>wg</code> will use the nameservers from the <code>wg0.conf</code> file. A value in the format <code>8.8.8.8</code> is to use a plain old nameserver. A value in the format <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>If you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice.</p> </li> <li> <p>This will start Privoxy on the default port 8118 when set to <code>true</code>. By default Privoxy is not exposed on the LAN, so if you need that, you'll have to add <code>VPN_EXPOSE_PORTS_ON_LAN=8118/tcp,8118/udp</code>.</p> </li> <li> <p>Enabling this will bring down the container if the connectivity tests fail at the end of the Wireguard init process or for an extended period during the container runtime.</p> </li> <li> <p>Enable Unbound by setting to <code>true</code> when VPN is not active.</p> </li> <li> <p>Possible values are <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>8.8.8.8</code> is to use a plain old nameserver. The value <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> </ol> clicompose <pre><code>docker run --rm \\\n    --hostname container-name.internal \\ #(18)\n    -e VPN_ENABLED=\"true\" \\ #(5)\n    -e VPN_CONF=\"wg0\" \\ #(8)\n    -e VPN_PROVIDER=\"pia\" \\ #(4)\n    -e VPN_LAN_NETWORK=\"192.168.1.0/24\" \\ #(1)\n    -e VPN_LAN_LEAK_ENABLED=\"false\" \\ #(10)\n    -e VPN_EXPOSE_PORTS_ON_LAN=\"\" \\ #(2)\n    -e VPN_AUTO_PORT_FORWARD=\"true\" \\ #(6)\n    -e VPN_AUTO_PORT_FORWARD_TO_PORTS=\"\" \\ #(15)\n    -e VPN_FIREWALL_TYPE=\"auto\" \\ #(17)\n    -e VPN_HEALTHCHECK_ENABLED=\"false\" \\ #(20)\n    -e VPN_NAMESERVERS=\"\" \\ #(16)\n    -e VPN_PIA_USER=\"\" \\ #(11)\n    -e VPN_PIA_PASS=\"\" \\ #(11)\n    -e VPN_PIA_PREFERRED_REGION=\"\" \\ #(7)\n    -e VPN_PIA_DIP_TOKEN=\"no\" \\ #(13)\n    -e VPN_PIA_PORT_FORWARD_PERSIST=\"false\" \\ #(14)\n    -e PRIVOXY_ENABLED=\"false\" \\ #(19)\n    -e UNBOUND_ENABLED=\"false\" \\ #(21)\n    -e UNBOUND_NAMESERVERS=\"\" \\ #(22)\n    --cap-add=NET_ADMIN \\\n    --sysctl=\"net.ipv4.conf.all.src_valid_mark=1\" \\ #(12)\n    --sysctl=\"net.ipv6.conf.all.disable_ipv6=1\" \\ #(3)\n    --device /dev/net/tun:/dev/net/tun \\ # OPTIONAL(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui. On MacOS set it to <code>192.168.65.0/24</code> (Verify with your settings [Resources &gt; Network &gt; Docker subnet]).</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>. Affiliate links: Proton VPN Proton Unlimited Private Internet Access</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> (for PIA this is done automatically, see <code>VPN_PROVIDER</code> variable) located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32 in most cases\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>DANGEROUS! Don't enable unless you know what you are doing!</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>Some of the possible values are for example <code>wg</code>, <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>wg</code> will use the nameservers from the <code>wg0.conf</code> file. A value in the format <code>8.8.8.8</code> is to use a plain old nameserver. A value in the format <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>If you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice.</p> </li> <li> <p>This will start Privoxy on the default port 8118 when set to <code>true</code>. By default Privoxy is not exposed on the LAN, so if you need that, you'll have to add <code>VPN_EXPOSE_PORTS_ON_LAN=8118/tcp,8118/udp</code>.</p> </li> <li> <p>Enabling this will bring down the container if the connectivity tests fail at the end of the Wireguard init process or for an extended period during the container runtime.</p> </li> <li> <p>Enable Unbound by setting to <code>true</code> when VPN is not active.</p> </li> <li> <p>Possible values are <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>8.8.8.8</code> is to use a plain old nameserver. The value <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> </ol> <pre><code>services:\n  app:\n    hostname: container-name.internal #(18)\n    environment:\n      - VPN_ENABLED=true #(5)\n      - VPN_CONF=wg0 #(8)\n      - VPN_PROVIDER=pia #(4)\n      - VPN_LAN_NETWORK=192.168.1.0/24 #(1)\n      - VPN_LAN_LEAK_ENABLED=false #(10)\n      - VPN_EXPOSE_PORTS_ON_LAN #(2)\n      - VPN_AUTO_PORT_FORWARD=true #(6)\n      - VPN_AUTO_PORT_FORWARD_TO_PORTS= #(15)\n      - VPN_FIREWALL_TYPE=auto #(17)\n      - VPN_HEALTHCHECK_ENABLED=false #(20)\n      - VPN_NAMESERVERS= #(16)\n      - VPN_PIA_USER #(11)\n      - VPN_PIA_PASS #(11)\n      - VPN_PIA_PREFERRED_REGION #(7)\n      - VPN_PIA_DIP_TOKEN=no #(13)\n      - VPN_PIA_PORT_FORWARD_PERSIST=false #(14)\n      - PRIVOXY_ENABLED=false #(19)\n      - UNBOUND_ENABLED=false #(21)\n      - UNBOUND_NAMESERVERS #(22)\n    cap_add:\n      - NET_ADMIN\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1 #(12)\n      - net.ipv6.conf.all.disable_ipv6=1 #(3)\n    devices:\n      - /dev/net/tun:/dev/net/tun # OPTIONAL(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui. On MacOS set it to <code>192.168.65.0/24</code> (Verify with your settings [Resources &gt; Network &gt; Docker subnet]).</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>. Affiliate links: Proton VPN Proton Unlimited Private Internet Access</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> (for PIA this is done automatically, see <code>VPN_PROVIDER</code> variable) located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32 in most cases\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>DANGEROUS! Don't enable unless you know what you are doing!</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>Some of the possible values are for example <code>wg</code>, <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>wg</code> will use the nameservers from the <code>wg0.conf</code> file. A value in the format <code>8.8.8.8</code> is to use a plain old nameserver. A value in the format <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>If you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice.</p> </li> <li> <p>This will start Privoxy on the default port 8118 when set to <code>true</code>. By default Privoxy is not exposed on the LAN, so if you need that, you'll have to add <code>VPN_EXPOSE_PORTS_ON_LAN=8118/tcp,8118/udp</code>.</p> </li> <li> <p>Enabling this will bring down the container if the connectivity tests fail at the end of the Wireguard init process or for an extended period during the container runtime.</p> </li> <li> <p>Enable Unbound by setting to <code>true</code> when VPN is not active.</p> </li> <li> <p>Possible values are <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>8.8.8.8</code> is to use a plain old nameserver. The value <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> </ol>"},{"location":"containers/prowlarr/","title":"hotio/prowlarr","text":"<p> GitHub ghcr.io</p>"},{"location":"containers/prowlarr/#starting-the-container","title":"Starting the container","text":"clicompose <pre><code>docker run --rm \\\n    --name prowlarr \\\n    -p 9696:9696 \\\n    -e PUID=1000 \\\n    -e PGID=1000 \\\n    -e UMASK=002 \\\n    -e TZ=\"Etc/UTC\" \\\n    -v /&lt;host_folder_config&gt;:/config \\\n    ghcr.io/hotio/prowlarr\n</code></pre> <pre><code>services:\n  prowlarr:\n    container_name: prowlarr\n    image: ghcr.io/hotio/prowlarr\n    ports:\n      - \"9696:9696\"\n    environment:\n      - PUID=1000\n      - PGID=1000\n      - UMASK=002\n      - TZ=Etc/UTC\n    volumes:\n      - /&lt;host_folder_config&gt;:/config\n</code></pre>"},{"location":"containers/prowlarr/#tags","title":"Tags","text":"Tags Description Last Updated Age"},{"location":"containers/prowlarr/#wireguard","title":"WireGuard","text":"<p>Info</p> <p>This image includes VPN support. The cli/compose examples below are environment variables and settings complementary to the app image examples, this means you'll have to add/merge the stuff below with the stuff above. In case you are still in need of a VPN, consider using my affiliate links for Proton VPN, Proton Unlimited or Private Internet Access.</p> <p> </p> genericprotonpia clicompose <pre><code>docker run --rm \\\n    --hostname container-name.internal \\ #(18)\n    -e VPN_ENABLED=\"true\" \\ #(5)\n    -e VPN_CONF=\"wg0\" \\ #(8)\n    -e VPN_PROVIDER=\"generic\" \\ #(4)\n    -e VPN_LAN_NETWORK=\"192.168.1.0/24\" \\ #(1)\n    -e VPN_LAN_LEAK_ENABLED=\"false\" \\ #(10)\n    -e VPN_EXPOSE_PORTS_ON_LAN=\"\" \\ #(2)\n    -e VPN_AUTO_PORT_FORWARD=\"false\" \\ #(6)\n    -e VPN_AUTO_PORT_FORWARD_TO_PORTS=\"\" \\ #(15)\n    -e VPN_FIREWALL_TYPE=\"auto\" \\ #(17)\n    -e VPN_HEALTHCHECK_ENABLED=\"false\" \\ #(20)\n    -e VPN_NAMESERVERS=\"\" \\ #(16)\n    -e PRIVOXY_ENABLED=\"false\" \\ #(19)\n    -e UNBOUND_ENABLED=\"false\" \\ #(21)\n    -e UNBOUND_NAMESERVERS=\"\" \\ #(22)\n    --cap-add=NET_ADMIN \\\n    --sysctl=\"net.ipv4.conf.all.src_valid_mark=1\" \\ #(12)\n    --sysctl=\"net.ipv6.conf.all.disable_ipv6=1\" \\ #(3)\n    --device /dev/net/tun:/dev/net/tun \\ # OPTIONAL(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui. On MacOS set it to <code>192.168.65.0/24</code> (Verify with your settings [Resources &gt; Network &gt; Docker subnet]).</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>. Affiliate links: Proton VPN Proton Unlimited Private Internet Access</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> (for PIA this is done automatically, see <code>VPN_PROVIDER</code> variable) located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32 in most cases\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>DANGEROUS! Don't enable unless you know what you are doing!</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>Some of the possible values are for example <code>wg</code>, <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>wg</code> will use the nameservers from the <code>wg0.conf</code> file. A value in the format <code>8.8.8.8</code> is to use a plain old nameserver. A value in the format <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>If you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice.</p> </li> <li> <p>This will start Privoxy on the default port 8118 when set to <code>true</code>. By default Privoxy is not exposed on the LAN, so if you need that, you'll have to add <code>VPN_EXPOSE_PORTS_ON_LAN=8118/tcp,8118/udp</code>.</p> </li> <li> <p>Enabling this will bring down the container if the connectivity tests fail at the end of the Wireguard init process or for an extended period during the container runtime.</p> </li> <li> <p>Enable Unbound by setting to <code>true</code> when VPN is not active.</p> </li> <li> <p>Possible values are <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>8.8.8.8</code> is to use a plain old nameserver. The value <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> </ol> <pre><code>services:\n  app:\n    hostname: container-name.internal #(18)\n    environment:\n      - VPN_ENABLED=true #(5)\n      - VPN_CONF=wg0 #(8)\n      - VPN_PROVIDER=generic #(4)\n      - VPN_LAN_NETWORK=192.168.1.0/24 #(1)\n      - VPN_LAN_LEAK_ENABLED=false #(10)\n      - VPN_EXPOSE_PORTS_ON_LAN #(2)\n      - VPN_AUTO_PORT_FORWARD=false #(6)\n      - VPN_AUTO_PORT_FORWARD_TO_PORTS= #(15)\n      - VPN_FIREWALL_TYPE=auto #(17)\n      - VPN_HEALTHCHECK_ENABLED=false #(20)\n      - VPN_NAMESERVERS= #(16)\n      - PRIVOXY_ENABLED=false #(19)\n      - UNBOUND_ENABLED=false #(21)\n      - UNBOUND_NAMESERVERS #(22)\n    cap_add:\n      - NET_ADMIN\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1 #(12)\n      - net.ipv6.conf.all.disable_ipv6=1 #(3)\n    devices:\n      - /dev/net/tun:/dev/net/tun # OPTIONAL(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui. On MacOS set it to <code>192.168.65.0/24</code> (Verify with your settings [Resources &gt; Network &gt; Docker subnet]).</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>. Affiliate links: Proton VPN Proton Unlimited Private Internet Access</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> (for PIA this is done automatically, see <code>VPN_PROVIDER</code> variable) located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32 in most cases\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>DANGEROUS! Don't enable unless you know what you are doing!</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>Some of the possible values are for example <code>wg</code>, <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>wg</code> will use the nameservers from the <code>wg0.conf</code> file. A value in the format <code>8.8.8.8</code> is to use a plain old nameserver. A value in the format <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>If you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice.</p> </li> <li> <p>This will start Privoxy on the default port 8118 when set to <code>true</code>. By default Privoxy is not exposed on the LAN, so if you need that, you'll have to add <code>VPN_EXPOSE_PORTS_ON_LAN=8118/tcp,8118/udp</code>.</p> </li> <li> <p>Enabling this will bring down the container if the connectivity tests fail at the end of the Wireguard init process or for an extended period during the container runtime.</p> </li> <li> <p>Enable Unbound by setting to <code>true</code> when VPN is not active.</p> </li> <li> <p>Possible values are <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>8.8.8.8</code> is to use a plain old nameserver. The value <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> </ol> clicompose <pre><code>docker run --rm \\\n    --hostname container-name.internal \\ #(18)\n    -e VPN_ENABLED=\"true\" \\ #(5)\n    -e VPN_CONF=\"wg0\" \\ #(8)\n    -e VPN_PROVIDER=\"proton\" \\ #(4)\n    -e VPN_LAN_NETWORK=\"192.168.1.0/24\" \\ #(1)\n    -e VPN_LAN_LEAK_ENABLED=\"false\" \\ #(10)\n    -e VPN_EXPOSE_PORTS_ON_LAN=\"\" \\ #(2)\n    -e VPN_AUTO_PORT_FORWARD=\"true\" \\ #(6)\n    -e VPN_AUTO_PORT_FORWARD_TO_PORTS=\"\" \\ #(15)\n    -e VPN_FIREWALL_TYPE=\"auto\" \\ #(17)\n    -e VPN_HEALTHCHECK_ENABLED=\"false\" \\ #(20)\n    -e VPN_NAMESERVERS=\"\" \\ #(16)\n    -e PRIVOXY_ENABLED=\"false\" \\ #(19)\n    -e UNBOUND_ENABLED=\"false\" \\ #(21)\n    -e UNBOUND_NAMESERVERS=\"\" \\ #(22)\n    --cap-add=NET_ADMIN \\\n    --sysctl=\"net.ipv4.conf.all.src_valid_mark=1\" \\ #(12)\n    --sysctl=\"net.ipv6.conf.all.disable_ipv6=1\" \\ #(3)\n    --device /dev/net/tun:/dev/net/tun \\ # OPTIONAL(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui. On MacOS set it to <code>192.168.65.0/24</code> (Verify with your settings [Resources &gt; Network &gt; Docker subnet]).</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>. Affiliate links: Proton VPN Proton Unlimited Private Internet Access</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> (for PIA this is done automatically, see <code>VPN_PROVIDER</code> variable) located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32 in most cases\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>DANGEROUS! Don't enable unless you know what you are doing!</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>Some of the possible values are for example <code>wg</code>, <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>wg</code> will use the nameservers from the <code>wg0.conf</code> file. A value in the format <code>8.8.8.8</code> is to use a plain old nameserver. A value in the format <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>If you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice.</p> </li> <li> <p>This will start Privoxy on the default port 8118 when set to <code>true</code>. By default Privoxy is not exposed on the LAN, so if you need that, you'll have to add <code>VPN_EXPOSE_PORTS_ON_LAN=8118/tcp,8118/udp</code>.</p> </li> <li> <p>Enabling this will bring down the container if the connectivity tests fail at the end of the Wireguard init process or for an extended period during the container runtime.</p> </li> <li> <p>Enable Unbound by setting to <code>true</code> when VPN is not active.</p> </li> <li> <p>Possible values are <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>8.8.8.8</code> is to use a plain old nameserver. The value <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> </ol> <pre><code>services:\n  app:\n    hostname: container-name.internal #(18)\n    environment:\n      - VPN_ENABLED=true #(5)\n      - VPN_CONF=wg0 #(8)\n      - VPN_PROVIDER=proton #(4)\n      - VPN_LAN_NETWORK=192.168.1.0/24 #(1)\n      - VPN_LAN_LEAK_ENABLED=false #(10)\n      - VPN_EXPOSE_PORTS_ON_LAN #(2)\n      - VPN_AUTO_PORT_FORWARD=true #(6)\n      - VPN_AUTO_PORT_FORWARD_TO_PORTS= #(15)\n      - VPN_FIREWALL_TYPE=auto #(17)\n      - VPN_HEALTHCHECK_ENABLED=false #(20)\n      - VPN_NAMESERVERS= #(16)\n      - PRIVOXY_ENABLED=false #(19)\n      - UNBOUND_ENABLED=false #(21)\n      - UNBOUND_NAMESERVERS #(22)\n    cap_add:\n      - NET_ADMIN\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1 #(12)\n      - net.ipv6.conf.all.disable_ipv6=1 #(3)\n    devices:\n      - /dev/net/tun:/dev/net/tun # OPTIONAL(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui. On MacOS set it to <code>192.168.65.0/24</code> (Verify with your settings [Resources &gt; Network &gt; Docker subnet]).</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>. Affiliate links: Proton VPN Proton Unlimited Private Internet Access</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> (for PIA this is done automatically, see <code>VPN_PROVIDER</code> variable) located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32 in most cases\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>DANGEROUS! Don't enable unless you know what you are doing!</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>Some of the possible values are for example <code>wg</code>, <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>wg</code> will use the nameservers from the <code>wg0.conf</code> file. A value in the format <code>8.8.8.8</code> is to use a plain old nameserver. A value in the format <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>If you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice.</p> </li> <li> <p>This will start Privoxy on the default port 8118 when set to <code>true</code>. By default Privoxy is not exposed on the LAN, so if you need that, you'll have to add <code>VPN_EXPOSE_PORTS_ON_LAN=8118/tcp,8118/udp</code>.</p> </li> <li> <p>Enabling this will bring down the container if the connectivity tests fail at the end of the Wireguard init process or for an extended period during the container runtime.</p> </li> <li> <p>Enable Unbound by setting to <code>true</code> when VPN is not active.</p> </li> <li> <p>Possible values are <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>8.8.8.8</code> is to use a plain old nameserver. The value <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> </ol> clicompose <pre><code>docker run --rm \\\n    --hostname container-name.internal \\ #(18)\n    -e VPN_ENABLED=\"true\" \\ #(5)\n    -e VPN_CONF=\"wg0\" \\ #(8)\n    -e VPN_PROVIDER=\"pia\" \\ #(4)\n    -e VPN_LAN_NETWORK=\"192.168.1.0/24\" \\ #(1)\n    -e VPN_LAN_LEAK_ENABLED=\"false\" \\ #(10)\n    -e VPN_EXPOSE_PORTS_ON_LAN=\"\" \\ #(2)\n    -e VPN_AUTO_PORT_FORWARD=\"true\" \\ #(6)\n    -e VPN_AUTO_PORT_FORWARD_TO_PORTS=\"\" \\ #(15)\n    -e VPN_FIREWALL_TYPE=\"auto\" \\ #(17)\n    -e VPN_HEALTHCHECK_ENABLED=\"false\" \\ #(20)\n    -e VPN_NAMESERVERS=\"\" \\ #(16)\n    -e VPN_PIA_USER=\"\" \\ #(11)\n    -e VPN_PIA_PASS=\"\" \\ #(11)\n    -e VPN_PIA_PREFERRED_REGION=\"\" \\ #(7)\n    -e VPN_PIA_DIP_TOKEN=\"no\" \\ #(13)\n    -e VPN_PIA_PORT_FORWARD_PERSIST=\"false\" \\ #(14)\n    -e PRIVOXY_ENABLED=\"false\" \\ #(19)\n    -e UNBOUND_ENABLED=\"false\" \\ #(21)\n    -e UNBOUND_NAMESERVERS=\"\" \\ #(22)\n    --cap-add=NET_ADMIN \\\n    --sysctl=\"net.ipv4.conf.all.src_valid_mark=1\" \\ #(12)\n    --sysctl=\"net.ipv6.conf.all.disable_ipv6=1\" \\ #(3)\n    --device /dev/net/tun:/dev/net/tun \\ # OPTIONAL(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui. On MacOS set it to <code>192.168.65.0/24</code> (Verify with your settings [Resources &gt; Network &gt; Docker subnet]).</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>. Affiliate links: Proton VPN Proton Unlimited Private Internet Access</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> (for PIA this is done automatically, see <code>VPN_PROVIDER</code> variable) located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32 in most cases\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>DANGEROUS! Don't enable unless you know what you are doing!</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>Some of the possible values are for example <code>wg</code>, <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>wg</code> will use the nameservers from the <code>wg0.conf</code> file. A value in the format <code>8.8.8.8</code> is to use a plain old nameserver. A value in the format <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>If you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice.</p> </li> <li> <p>This will start Privoxy on the default port 8118 when set to <code>true</code>. By default Privoxy is not exposed on the LAN, so if you need that, you'll have to add <code>VPN_EXPOSE_PORTS_ON_LAN=8118/tcp,8118/udp</code>.</p> </li> <li> <p>Enabling this will bring down the container if the connectivity tests fail at the end of the Wireguard init process or for an extended period during the container runtime.</p> </li> <li> <p>Enable Unbound by setting to <code>true</code> when VPN is not active.</p> </li> <li> <p>Possible values are <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>8.8.8.8</code> is to use a plain old nameserver. The value <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> </ol> <pre><code>services:\n  app:\n    hostname: container-name.internal #(18)\n    environment:\n      - VPN_ENABLED=true #(5)\n      - VPN_CONF=wg0 #(8)\n      - VPN_PROVIDER=pia #(4)\n      - VPN_LAN_NETWORK=192.168.1.0/24 #(1)\n      - VPN_LAN_LEAK_ENABLED=false #(10)\n      - VPN_EXPOSE_PORTS_ON_LAN #(2)\n      - VPN_AUTO_PORT_FORWARD=true #(6)\n      - VPN_AUTO_PORT_FORWARD_TO_PORTS= #(15)\n      - VPN_FIREWALL_TYPE=auto #(17)\n      - VPN_HEALTHCHECK_ENABLED=false #(20)\n      - VPN_NAMESERVERS= #(16)\n      - VPN_PIA_USER #(11)\n      - VPN_PIA_PASS #(11)\n      - VPN_PIA_PREFERRED_REGION #(7)\n      - VPN_PIA_DIP_TOKEN=no #(13)\n      - VPN_PIA_PORT_FORWARD_PERSIST=false #(14)\n      - PRIVOXY_ENABLED=false #(19)\n      - UNBOUND_ENABLED=false #(21)\n      - UNBOUND_NAMESERVERS #(22)\n    cap_add:\n      - NET_ADMIN\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1 #(12)\n      - net.ipv6.conf.all.disable_ipv6=1 #(3)\n    devices:\n      - /dev/net/tun:/dev/net/tun # OPTIONAL(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui. On MacOS set it to <code>192.168.65.0/24</code> (Verify with your settings [Resources &gt; Network &gt; Docker subnet]).</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>. Affiliate links: Proton VPN Proton Unlimited Private Internet Access</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> (for PIA this is done automatically, see <code>VPN_PROVIDER</code> variable) located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32 in most cases\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>DANGEROUS! Don't enable unless you know what you are doing!</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>Some of the possible values are for example <code>wg</code>, <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>wg</code> will use the nameservers from the <code>wg0.conf</code> file. A value in the format <code>8.8.8.8</code> is to use a plain old nameserver. A value in the format <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>If you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice.</p> </li> <li> <p>This will start Privoxy on the default port 8118 when set to <code>true</code>. By default Privoxy is not exposed on the LAN, so if you need that, you'll have to add <code>VPN_EXPOSE_PORTS_ON_LAN=8118/tcp,8118/udp</code>.</p> </li> <li> <p>Enabling this will bring down the container if the connectivity tests fail at the end of the Wireguard init process or for an extended period during the container runtime.</p> </li> <li> <p>Enable Unbound by setting to <code>true</code> when VPN is not active.</p> </li> <li> <p>Possible values are <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>8.8.8.8</code> is to use a plain old nameserver. The value <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> </ol>"},{"location":"containers/qbitmanage/","title":"hotio/qbitmanage","text":"<p> GitHub ghcr.io</p>"},{"location":"containers/qbitmanage/#starting-the-container","title":"Starting the container","text":"clicompose <pre><code>docker run --rm \\\n    --name qbitmanage \\\n    -e PUID=1000 \\\n    -e PGID=1000 \\\n    -e UMASK=002 \\\n    -e TZ=\"Etc/UTC\" \\\n    -e ARGS=\"\" \\\n    -v /&lt;host_folder_config&gt;:/config \\\n    -v /&lt;host_folder_data&gt;:/data \\\n    ghcr.io/hotio/qbitmanage\n</code></pre> <pre><code>services:\n  qbitmanage:\n    container_name: qbitmanage\n    image: ghcr.io/hotio/qbitmanage\n    environment:\n      - PUID=1000\n      - PGID=1000\n      - UMASK=002\n      - TZ=Etc/UTC\n      - ARGS\n    volumes:\n      - /&lt;host_folder_config&gt;:/config\n      - /&lt;host_folder_data&gt;:/data\n</code></pre>"},{"location":"containers/qbitmanage/#tags","title":"Tags","text":"Tags Description Last Updated Age"},{"location":"containers/qbitmanage/#wireguard","title":"WireGuard","text":"<p>Info</p> <p>This image includes VPN support. The cli/compose examples below are environment variables and settings complementary to the app image examples, this means you'll have to add/merge the stuff below with the stuff above. In case you are still in need of a VPN, consider using my affiliate links for Proton VPN, Proton Unlimited or Private Internet Access.</p> <p> </p> genericprotonpia clicompose <pre><code>docker run --rm \\\n    --hostname container-name.internal \\ #(18)\n    -e VPN_ENABLED=\"true\" \\ #(5)\n    -e VPN_CONF=\"wg0\" \\ #(8)\n    -e VPN_PROVIDER=\"generic\" \\ #(4)\n    -e VPN_LAN_NETWORK=\"192.168.1.0/24\" \\ #(1)\n    -e VPN_LAN_LEAK_ENABLED=\"false\" \\ #(10)\n    -e VPN_EXPOSE_PORTS_ON_LAN=\"\" \\ #(2)\n    -e VPN_AUTO_PORT_FORWARD=\"false\" \\ #(6)\n    -e VPN_AUTO_PORT_FORWARD_TO_PORTS=\"\" \\ #(15)\n    -e VPN_FIREWALL_TYPE=\"auto\" \\ #(17)\n    -e VPN_HEALTHCHECK_ENABLED=\"false\" \\ #(20)\n    -e VPN_NAMESERVERS=\"\" \\ #(16)\n    -e PRIVOXY_ENABLED=\"false\" \\ #(19)\n    -e UNBOUND_ENABLED=\"false\" \\ #(21)\n    -e UNBOUND_NAMESERVERS=\"\" \\ #(22)\n    --cap-add=NET_ADMIN \\\n    --sysctl=\"net.ipv4.conf.all.src_valid_mark=1\" \\ #(12)\n    --sysctl=\"net.ipv6.conf.all.disable_ipv6=1\" \\ #(3)\n    --device /dev/net/tun:/dev/net/tun \\ # OPTIONAL(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui. On MacOS set it to <code>192.168.65.0/24</code> (Verify with your settings [Resources &gt; Network &gt; Docker subnet]).</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>. Affiliate links: Proton VPN Proton Unlimited Private Internet Access</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> (for PIA this is done automatically, see <code>VPN_PROVIDER</code> variable) located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32 in most cases\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>DANGEROUS! Don't enable unless you know what you are doing!</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>Some of the possible values are for example <code>wg</code>, <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>wg</code> will use the nameservers from the <code>wg0.conf</code> file. A value in the format <code>8.8.8.8</code> is to use a plain old nameserver. A value in the format <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>If you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice.</p> </li> <li> <p>This will start Privoxy on the default port 8118 when set to <code>true</code>. By default Privoxy is not exposed on the LAN, so if you need that, you'll have to add <code>VPN_EXPOSE_PORTS_ON_LAN=8118/tcp,8118/udp</code>.</p> </li> <li> <p>Enabling this will bring down the container if the connectivity tests fail at the end of the Wireguard init process or for an extended period during the container runtime.</p> </li> <li> <p>Enable Unbound by setting to <code>true</code> when VPN is not active.</p> </li> <li> <p>Possible values are <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>8.8.8.8</code> is to use a plain old nameserver. The value <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> </ol> <pre><code>services:\n  app:\n    hostname: container-name.internal #(18)\n    environment:\n      - VPN_ENABLED=true #(5)\n      - VPN_CONF=wg0 #(8)\n      - VPN_PROVIDER=generic #(4)\n      - VPN_LAN_NETWORK=192.168.1.0/24 #(1)\n      - VPN_LAN_LEAK_ENABLED=false #(10)\n      - VPN_EXPOSE_PORTS_ON_LAN #(2)\n      - VPN_AUTO_PORT_FORWARD=false #(6)\n      - VPN_AUTO_PORT_FORWARD_TO_PORTS= #(15)\n      - VPN_FIREWALL_TYPE=auto #(17)\n      - VPN_HEALTHCHECK_ENABLED=false #(20)\n      - VPN_NAMESERVERS= #(16)\n      - PRIVOXY_ENABLED=false #(19)\n      - UNBOUND_ENABLED=false #(21)\n      - UNBOUND_NAMESERVERS #(22)\n    cap_add:\n      - NET_ADMIN\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1 #(12)\n      - net.ipv6.conf.all.disable_ipv6=1 #(3)\n    devices:\n      - /dev/net/tun:/dev/net/tun # OPTIONAL(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui. On MacOS set it to <code>192.168.65.0/24</code> (Verify with your settings [Resources &gt; Network &gt; Docker subnet]).</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>. Affiliate links: Proton VPN Proton Unlimited Private Internet Access</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> (for PIA this is done automatically, see <code>VPN_PROVIDER</code> variable) located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32 in most cases\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>DANGEROUS! Don't enable unless you know what you are doing!</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>Some of the possible values are for example <code>wg</code>, <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>wg</code> will use the nameservers from the <code>wg0.conf</code> file. A value in the format <code>8.8.8.8</code> is to use a plain old nameserver. A value in the format <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>If you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice.</p> </li> <li> <p>This will start Privoxy on the default port 8118 when set to <code>true</code>. By default Privoxy is not exposed on the LAN, so if you need that, you'll have to add <code>VPN_EXPOSE_PORTS_ON_LAN=8118/tcp,8118/udp</code>.</p> </li> <li> <p>Enabling this will bring down the container if the connectivity tests fail at the end of the Wireguard init process or for an extended period during the container runtime.</p> </li> <li> <p>Enable Unbound by setting to <code>true</code> when VPN is not active.</p> </li> <li> <p>Possible values are <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>8.8.8.8</code> is to use a plain old nameserver. The value <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> </ol> clicompose <pre><code>docker run --rm \\\n    --hostname container-name.internal \\ #(18)\n    -e VPN_ENABLED=\"true\" \\ #(5)\n    -e VPN_CONF=\"wg0\" \\ #(8)\n    -e VPN_PROVIDER=\"proton\" \\ #(4)\n    -e VPN_LAN_NETWORK=\"192.168.1.0/24\" \\ #(1)\n    -e VPN_LAN_LEAK_ENABLED=\"false\" \\ #(10)\n    -e VPN_EXPOSE_PORTS_ON_LAN=\"\" \\ #(2)\n    -e VPN_AUTO_PORT_FORWARD=\"true\" \\ #(6)\n    -e VPN_AUTO_PORT_FORWARD_TO_PORTS=\"\" \\ #(15)\n    -e VPN_FIREWALL_TYPE=\"auto\" \\ #(17)\n    -e VPN_HEALTHCHECK_ENABLED=\"false\" \\ #(20)\n    -e VPN_NAMESERVERS=\"\" \\ #(16)\n    -e PRIVOXY_ENABLED=\"false\" \\ #(19)\n    -e UNBOUND_ENABLED=\"false\" \\ #(21)\n    -e UNBOUND_NAMESERVERS=\"\" \\ #(22)\n    --cap-add=NET_ADMIN \\\n    --sysctl=\"net.ipv4.conf.all.src_valid_mark=1\" \\ #(12)\n    --sysctl=\"net.ipv6.conf.all.disable_ipv6=1\" \\ #(3)\n    --device /dev/net/tun:/dev/net/tun \\ # OPTIONAL(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui. On MacOS set it to <code>192.168.65.0/24</code> (Verify with your settings [Resources &gt; Network &gt; Docker subnet]).</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>. Affiliate links: Proton VPN Proton Unlimited Private Internet Access</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> (for PIA this is done automatically, see <code>VPN_PROVIDER</code> variable) located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32 in most cases\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>DANGEROUS! Don't enable unless you know what you are doing!</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>Some of the possible values are for example <code>wg</code>, <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>wg</code> will use the nameservers from the <code>wg0.conf</code> file. A value in the format <code>8.8.8.8</code> is to use a plain old nameserver. A value in the format <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>If you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice.</p> </li> <li> <p>This will start Privoxy on the default port 8118 when set to <code>true</code>. By default Privoxy is not exposed on the LAN, so if you need that, you'll have to add <code>VPN_EXPOSE_PORTS_ON_LAN=8118/tcp,8118/udp</code>.</p> </li> <li> <p>Enabling this will bring down the container if the connectivity tests fail at the end of the Wireguard init process or for an extended period during the container runtime.</p> </li> <li> <p>Enable Unbound by setting to <code>true</code> when VPN is not active.</p> </li> <li> <p>Possible values are <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>8.8.8.8</code> is to use a plain old nameserver. The value <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> </ol> <pre><code>services:\n  app:\n    hostname: container-name.internal #(18)\n    environment:\n      - VPN_ENABLED=true #(5)\n      - VPN_CONF=wg0 #(8)\n      - VPN_PROVIDER=proton #(4)\n      - VPN_LAN_NETWORK=192.168.1.0/24 #(1)\n      - VPN_LAN_LEAK_ENABLED=false #(10)\n      - VPN_EXPOSE_PORTS_ON_LAN #(2)\n      - VPN_AUTO_PORT_FORWARD=true #(6)\n      - VPN_AUTO_PORT_FORWARD_TO_PORTS= #(15)\n      - VPN_FIREWALL_TYPE=auto #(17)\n      - VPN_HEALTHCHECK_ENABLED=false #(20)\n      - VPN_NAMESERVERS= #(16)\n      - PRIVOXY_ENABLED=false #(19)\n      - UNBOUND_ENABLED=false #(21)\n      - UNBOUND_NAMESERVERS #(22)\n    cap_add:\n      - NET_ADMIN\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1 #(12)\n      - net.ipv6.conf.all.disable_ipv6=1 #(3)\n    devices:\n      - /dev/net/tun:/dev/net/tun # OPTIONAL(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui. On MacOS set it to <code>192.168.65.0/24</code> (Verify with your settings [Resources &gt; Network &gt; Docker subnet]).</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>. Affiliate links: Proton VPN Proton Unlimited Private Internet Access</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> (for PIA this is done automatically, see <code>VPN_PROVIDER</code> variable) located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32 in most cases\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>DANGEROUS! Don't enable unless you know what you are doing!</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>Some of the possible values are for example <code>wg</code>, <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>wg</code> will use the nameservers from the <code>wg0.conf</code> file. A value in the format <code>8.8.8.8</code> is to use a plain old nameserver. A value in the format <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>If you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice.</p> </li> <li> <p>This will start Privoxy on the default port 8118 when set to <code>true</code>. By default Privoxy is not exposed on the LAN, so if you need that, you'll have to add <code>VPN_EXPOSE_PORTS_ON_LAN=8118/tcp,8118/udp</code>.</p> </li> <li> <p>Enabling this will bring down the container if the connectivity tests fail at the end of the Wireguard init process or for an extended period during the container runtime.</p> </li> <li> <p>Enable Unbound by setting to <code>true</code> when VPN is not active.</p> </li> <li> <p>Possible values are <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>8.8.8.8</code> is to use a plain old nameserver. The value <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> </ol> clicompose <pre><code>docker run --rm \\\n    --hostname container-name.internal \\ #(18)\n    -e VPN_ENABLED=\"true\" \\ #(5)\n    -e VPN_CONF=\"wg0\" \\ #(8)\n    -e VPN_PROVIDER=\"pia\" \\ #(4)\n    -e VPN_LAN_NETWORK=\"192.168.1.0/24\" \\ #(1)\n    -e VPN_LAN_LEAK_ENABLED=\"false\" \\ #(10)\n    -e VPN_EXPOSE_PORTS_ON_LAN=\"\" \\ #(2)\n    -e VPN_AUTO_PORT_FORWARD=\"true\" \\ #(6)\n    -e VPN_AUTO_PORT_FORWARD_TO_PORTS=\"\" \\ #(15)\n    -e VPN_FIREWALL_TYPE=\"auto\" \\ #(17)\n    -e VPN_HEALTHCHECK_ENABLED=\"false\" \\ #(20)\n    -e VPN_NAMESERVERS=\"\" \\ #(16)\n    -e VPN_PIA_USER=\"\" \\ #(11)\n    -e VPN_PIA_PASS=\"\" \\ #(11)\n    -e VPN_PIA_PREFERRED_REGION=\"\" \\ #(7)\n    -e VPN_PIA_DIP_TOKEN=\"no\" \\ #(13)\n    -e VPN_PIA_PORT_FORWARD_PERSIST=\"false\" \\ #(14)\n    -e PRIVOXY_ENABLED=\"false\" \\ #(19)\n    -e UNBOUND_ENABLED=\"false\" \\ #(21)\n    -e UNBOUND_NAMESERVERS=\"\" \\ #(22)\n    --cap-add=NET_ADMIN \\\n    --sysctl=\"net.ipv4.conf.all.src_valid_mark=1\" \\ #(12)\n    --sysctl=\"net.ipv6.conf.all.disable_ipv6=1\" \\ #(3)\n    --device /dev/net/tun:/dev/net/tun \\ # OPTIONAL(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui. On MacOS set it to <code>192.168.65.0/24</code> (Verify with your settings [Resources &gt; Network &gt; Docker subnet]).</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>. Affiliate links: Proton VPN Proton Unlimited Private Internet Access</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> (for PIA this is done automatically, see <code>VPN_PROVIDER</code> variable) located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32 in most cases\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>DANGEROUS! Don't enable unless you know what you are doing!</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>Some of the possible values are for example <code>wg</code>, <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>wg</code> will use the nameservers from the <code>wg0.conf</code> file. A value in the format <code>8.8.8.8</code> is to use a plain old nameserver. A value in the format <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>If you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice.</p> </li> <li> <p>This will start Privoxy on the default port 8118 when set to <code>true</code>. By default Privoxy is not exposed on the LAN, so if you need that, you'll have to add <code>VPN_EXPOSE_PORTS_ON_LAN=8118/tcp,8118/udp</code>.</p> </li> <li> <p>Enabling this will bring down the container if the connectivity tests fail at the end of the Wireguard init process or for an extended period during the container runtime.</p> </li> <li> <p>Enable Unbound by setting to <code>true</code> when VPN is not active.</p> </li> <li> <p>Possible values are <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>8.8.8.8</code> is to use a plain old nameserver. The value <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> </ol> <pre><code>services:\n  app:\n    hostname: container-name.internal #(18)\n    environment:\n      - VPN_ENABLED=true #(5)\n      - VPN_CONF=wg0 #(8)\n      - VPN_PROVIDER=pia #(4)\n      - VPN_LAN_NETWORK=192.168.1.0/24 #(1)\n      - VPN_LAN_LEAK_ENABLED=false #(10)\n      - VPN_EXPOSE_PORTS_ON_LAN #(2)\n      - VPN_AUTO_PORT_FORWARD=true #(6)\n      - VPN_AUTO_PORT_FORWARD_TO_PORTS= #(15)\n      - VPN_FIREWALL_TYPE=auto #(17)\n      - VPN_HEALTHCHECK_ENABLED=false #(20)\n      - VPN_NAMESERVERS= #(16)\n      - VPN_PIA_USER #(11)\n      - VPN_PIA_PASS #(11)\n      - VPN_PIA_PREFERRED_REGION #(7)\n      - VPN_PIA_DIP_TOKEN=no #(13)\n      - VPN_PIA_PORT_FORWARD_PERSIST=false #(14)\n      - PRIVOXY_ENABLED=false #(19)\n      - UNBOUND_ENABLED=false #(21)\n      - UNBOUND_NAMESERVERS #(22)\n    cap_add:\n      - NET_ADMIN\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1 #(12)\n      - net.ipv6.conf.all.disable_ipv6=1 #(3)\n    devices:\n      - /dev/net/tun:/dev/net/tun # OPTIONAL(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui. On MacOS set it to <code>192.168.65.0/24</code> (Verify with your settings [Resources &gt; Network &gt; Docker subnet]).</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>. Affiliate links: Proton VPN Proton Unlimited Private Internet Access</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> (for PIA this is done automatically, see <code>VPN_PROVIDER</code> variable) located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32 in most cases\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>DANGEROUS! Don't enable unless you know what you are doing!</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>Some of the possible values are for example <code>wg</code>, <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>wg</code> will use the nameservers from the <code>wg0.conf</code> file. A value in the format <code>8.8.8.8</code> is to use a plain old nameserver. A value in the format <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>If you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice.</p> </li> <li> <p>This will start Privoxy on the default port 8118 when set to <code>true</code>. By default Privoxy is not exposed on the LAN, so if you need that, you'll have to add <code>VPN_EXPOSE_PORTS_ON_LAN=8118/tcp,8118/udp</code>.</p> </li> <li> <p>Enabling this will bring down the container if the connectivity tests fail at the end of the Wireguard init process or for an extended period during the container runtime.</p> </li> <li> <p>Enable Unbound by setting to <code>true</code> when VPN is not active.</p> </li> <li> <p>Possible values are <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>8.8.8.8</code> is to use a plain old nameserver. The value <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> </ol>"},{"location":"containers/qbittorrent/","title":"hotio/qbittorrent","text":"<p> GitHub ghcr.io</p> <p>Don't be stupid!</p> <p>Don't be stupid like this guy from apogliaghi.com! I'm not bundling a cryptominer. If you want to play sysadmin, know what you are doing! It's fairly well known that if you expose qBittorrent (or other software) to the world, that there's a chance you're gonna get pwned. Certainly if you keep running old versions (I'm not gonna bother checking how old his digest sha actually is, EDIT: sha is recent, but in his article no mention about how long or what version he had running in the past). All sourcecode is visible on GitHub and verifiable by anyone. The screenshotted oneliner from discord without any context can also be searched for in my discord server if you wanna read the context. The sad part here is that the incompetent person throwing false accusations around is probably seen by his family as the smart nephew that knows everything about computers. RIP The Family! See this article on torrentfreak.com for more info on how you could get pwned. He's not the first one and sadly he's not going to be the last victim, but atleast man up and own your mistake!</p>"},{"location":"containers/qbittorrent/#starting-the-container","title":"Starting the container","text":"clicompose <pre><code>docker run --rm \\\n    --name qbittorrent \\\n    -p 8080:8080 \\\n    -e PUID=1000 \\\n    -e PGID=1000 \\\n    -e UMASK=002 \\\n    -e TZ=\"Etc/UTC\" \\\n    -e WEBUI_PORTS=\"8080/tcp,8080/udp\" \\\n    -e LIBTORRENT=\"v1\" \\\n    -v /&lt;host_folder_config&gt;:/config \\\n    -v /&lt;host_folder_data&gt;:/data \\\n    ghcr.io/hotio/qbittorrent\n</code></pre> <pre><code>services:\n  qbittorrent:\n    container_name: qbittorrent\n    image: ghcr.io/hotio/qbittorrent\n    ports:\n      - \"8080:8080\"\n    environment:\n      - PUID=1000\n      - PGID=1000\n      - UMASK=002\n      - TZ=Etc/UTC\n      - WEBUI_PORTS=8080/tcp,8080/udp\n      - LIBTORRENT=v1\n    volumes:\n      - /&lt;host_folder_config&gt;:/config\n      - /&lt;host_folder_data&gt;:/data\n</code></pre>"},{"location":"containers/qbittorrent/#tags","title":"Tags","text":"Tags Description Last Updated Age"},{"location":"containers/qbittorrent/#wireguard","title":"WireGuard","text":"<p>Info</p> <p>This image includes VPN support. The cli/compose examples below are environment variables and settings complementary to the app image examples, this means you'll have to add/merge the stuff below with the stuff above. In case you are still in need of a VPN, consider using my affiliate links for Proton VPN, Proton Unlimited or Private Internet Access.</p> <p> </p> genericprotonpia clicompose <pre><code>docker run --rm \\\n    --hostname container-name.internal \\ #(18)\n    -e VPN_ENABLED=\"true\" \\ #(5)\n    -e VPN_CONF=\"wg0\" \\ #(8)\n    -e VPN_PROVIDER=\"generic\" \\ #(4)\n    -e VPN_LAN_NETWORK=\"192.168.1.0/24\" \\ #(1)\n    -e VPN_LAN_LEAK_ENABLED=\"false\" \\ #(10)\n    -e VPN_EXPOSE_PORTS_ON_LAN=\"\" \\ #(2)\n    -e VPN_AUTO_PORT_FORWARD=\"false\" \\ #(6)\n    -e VPN_AUTO_PORT_FORWARD_TO_PORTS=\"\" \\ #(15)\n    -e VPN_FIREWALL_TYPE=\"auto\" \\ #(17)\n    -e VPN_HEALTHCHECK_ENABLED=\"false\" \\ #(20)\n    -e VPN_NAMESERVERS=\"\" \\ #(16)\n    -e PRIVOXY_ENABLED=\"false\" \\ #(19)\n    -e UNBOUND_ENABLED=\"false\" \\ #(21)\n    -e UNBOUND_NAMESERVERS=\"\" \\ #(22)\n    --cap-add=NET_ADMIN \\\n    --sysctl=\"net.ipv4.conf.all.src_valid_mark=1\" \\ #(12)\n    --sysctl=\"net.ipv6.conf.all.disable_ipv6=1\" \\ #(3)\n    --device /dev/net/tun:/dev/net/tun \\ # OPTIONAL(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui. On MacOS set it to <code>192.168.65.0/24</code> (Verify with your settings [Resources &gt; Network &gt; Docker subnet]).</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>. Affiliate links: Proton VPN Proton Unlimited Private Internet Access</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> (for PIA this is done automatically, see <code>VPN_PROVIDER</code> variable) located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32 in most cases\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>DANGEROUS! Don't enable unless you know what you are doing!</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>Some of the possible values are for example <code>wg</code>, <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>wg</code> will use the nameservers from the <code>wg0.conf</code> file. A value in the format <code>8.8.8.8</code> is to use a plain old nameserver. A value in the format <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>If you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice.</p> </li> <li> <p>This will start Privoxy on the default port 8118 when set to <code>true</code>. By default Privoxy is not exposed on the LAN, so if you need that, you'll have to add <code>VPN_EXPOSE_PORTS_ON_LAN=8118/tcp,8118/udp</code>.</p> </li> <li> <p>Enabling this will bring down the container if the connectivity tests fail at the end of the Wireguard init process or for an extended period during the container runtime.</p> </li> <li> <p>Enable Unbound by setting to <code>true</code> when VPN is not active.</p> </li> <li> <p>Possible values are <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>8.8.8.8</code> is to use a plain old nameserver. The value <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> </ol> <pre><code>services:\n  app:\n    hostname: container-name.internal #(18)\n    environment:\n      - VPN_ENABLED=true #(5)\n      - VPN_CONF=wg0 #(8)\n      - VPN_PROVIDER=generic #(4)\n      - VPN_LAN_NETWORK=192.168.1.0/24 #(1)\n      - VPN_LAN_LEAK_ENABLED=false #(10)\n      - VPN_EXPOSE_PORTS_ON_LAN #(2)\n      - VPN_AUTO_PORT_FORWARD=false #(6)\n      - VPN_AUTO_PORT_FORWARD_TO_PORTS= #(15)\n      - VPN_FIREWALL_TYPE=auto #(17)\n      - VPN_HEALTHCHECK_ENABLED=false #(20)\n      - VPN_NAMESERVERS= #(16)\n      - PRIVOXY_ENABLED=false #(19)\n      - UNBOUND_ENABLED=false #(21)\n      - UNBOUND_NAMESERVERS #(22)\n    cap_add:\n      - NET_ADMIN\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1 #(12)\n      - net.ipv6.conf.all.disable_ipv6=1 #(3)\n    devices:\n      - /dev/net/tun:/dev/net/tun # OPTIONAL(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui. On MacOS set it to <code>192.168.65.0/24</code> (Verify with your settings [Resources &gt; Network &gt; Docker subnet]).</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>. Affiliate links: Proton VPN Proton Unlimited Private Internet Access</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> (for PIA this is done automatically, see <code>VPN_PROVIDER</code> variable) located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32 in most cases\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>DANGEROUS! Don't enable unless you know what you are doing!</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>Some of the possible values are for example <code>wg</code>, <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>wg</code> will use the nameservers from the <code>wg0.conf</code> file. A value in the format <code>8.8.8.8</code> is to use a plain old nameserver. A value in the format <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>If you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice.</p> </li> <li> <p>This will start Privoxy on the default port 8118 when set to <code>true</code>. By default Privoxy is not exposed on the LAN, so if you need that, you'll have to add <code>VPN_EXPOSE_PORTS_ON_LAN=8118/tcp,8118/udp</code>.</p> </li> <li> <p>Enabling this will bring down the container if the connectivity tests fail at the end of the Wireguard init process or for an extended period during the container runtime.</p> </li> <li> <p>Enable Unbound by setting to <code>true</code> when VPN is not active.</p> </li> <li> <p>Possible values are <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>8.8.8.8</code> is to use a plain old nameserver. The value <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> </ol> clicompose <pre><code>docker run --rm \\\n    --hostname container-name.internal \\ #(18)\n    -e VPN_ENABLED=\"true\" \\ #(5)\n    -e VPN_CONF=\"wg0\" \\ #(8)\n    -e VPN_PROVIDER=\"proton\" \\ #(4)\n    -e VPN_LAN_NETWORK=\"192.168.1.0/24\" \\ #(1)\n    -e VPN_LAN_LEAK_ENABLED=\"false\" \\ #(10)\n    -e VPN_EXPOSE_PORTS_ON_LAN=\"\" \\ #(2)\n    -e VPN_AUTO_PORT_FORWARD=\"true\" \\ #(6)\n    -e VPN_AUTO_PORT_FORWARD_TO_PORTS=\"\" \\ #(15)\n    -e VPN_FIREWALL_TYPE=\"auto\" \\ #(17)\n    -e VPN_HEALTHCHECK_ENABLED=\"false\" \\ #(20)\n    -e VPN_NAMESERVERS=\"\" \\ #(16)\n    -e PRIVOXY_ENABLED=\"false\" \\ #(19)\n    -e UNBOUND_ENABLED=\"false\" \\ #(21)\n    -e UNBOUND_NAMESERVERS=\"\" \\ #(22)\n    --cap-add=NET_ADMIN \\\n    --sysctl=\"net.ipv4.conf.all.src_valid_mark=1\" \\ #(12)\n    --sysctl=\"net.ipv6.conf.all.disable_ipv6=1\" \\ #(3)\n    --device /dev/net/tun:/dev/net/tun \\ # OPTIONAL(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui. On MacOS set it to <code>192.168.65.0/24</code> (Verify with your settings [Resources &gt; Network &gt; Docker subnet]).</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>. Affiliate links: Proton VPN Proton Unlimited Private Internet Access</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> (for PIA this is done automatically, see <code>VPN_PROVIDER</code> variable) located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32 in most cases\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>DANGEROUS! Don't enable unless you know what you are doing!</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>Some of the possible values are for example <code>wg</code>, <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>wg</code> will use the nameservers from the <code>wg0.conf</code> file. A value in the format <code>8.8.8.8</code> is to use a plain old nameserver. A value in the format <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>If you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice.</p> </li> <li> <p>This will start Privoxy on the default port 8118 when set to <code>true</code>. By default Privoxy is not exposed on the LAN, so if you need that, you'll have to add <code>VPN_EXPOSE_PORTS_ON_LAN=8118/tcp,8118/udp</code>.</p> </li> <li> <p>Enabling this will bring down the container if the connectivity tests fail at the end of the Wireguard init process or for an extended period during the container runtime.</p> </li> <li> <p>Enable Unbound by setting to <code>true</code> when VPN is not active.</p> </li> <li> <p>Possible values are <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>8.8.8.8</code> is to use a plain old nameserver. The value <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> </ol> <pre><code>services:\n  app:\n    hostname: container-name.internal #(18)\n    environment:\n      - VPN_ENABLED=true #(5)\n      - VPN_CONF=wg0 #(8)\n      - VPN_PROVIDER=proton #(4)\n      - VPN_LAN_NETWORK=192.168.1.0/24 #(1)\n      - VPN_LAN_LEAK_ENABLED=false #(10)\n      - VPN_EXPOSE_PORTS_ON_LAN #(2)\n      - VPN_AUTO_PORT_FORWARD=true #(6)\n      - VPN_AUTO_PORT_FORWARD_TO_PORTS= #(15)\n      - VPN_FIREWALL_TYPE=auto #(17)\n      - VPN_HEALTHCHECK_ENABLED=false #(20)\n      - VPN_NAMESERVERS= #(16)\n      - PRIVOXY_ENABLED=false #(19)\n      - UNBOUND_ENABLED=false #(21)\n      - UNBOUND_NAMESERVERS #(22)\n    cap_add:\n      - NET_ADMIN\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1 #(12)\n      - net.ipv6.conf.all.disable_ipv6=1 #(3)\n    devices:\n      - /dev/net/tun:/dev/net/tun # OPTIONAL(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui. On MacOS set it to <code>192.168.65.0/24</code> (Verify with your settings [Resources &gt; Network &gt; Docker subnet]).</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>. Affiliate links: Proton VPN Proton Unlimited Private Internet Access</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> (for PIA this is done automatically, see <code>VPN_PROVIDER</code> variable) located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32 in most cases\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>DANGEROUS! Don't enable unless you know what you are doing!</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>Some of the possible values are for example <code>wg</code>, <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>wg</code> will use the nameservers from the <code>wg0.conf</code> file. A value in the format <code>8.8.8.8</code> is to use a plain old nameserver. A value in the format <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>If you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice.</p> </li> <li> <p>This will start Privoxy on the default port 8118 when set to <code>true</code>. By default Privoxy is not exposed on the LAN, so if you need that, you'll have to add <code>VPN_EXPOSE_PORTS_ON_LAN=8118/tcp,8118/udp</code>.</p> </li> <li> <p>Enabling this will bring down the container if the connectivity tests fail at the end of the Wireguard init process or for an extended period during the container runtime.</p> </li> <li> <p>Enable Unbound by setting to <code>true</code> when VPN is not active.</p> </li> <li> <p>Possible values are <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>8.8.8.8</code> is to use a plain old nameserver. The value <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> </ol> clicompose <pre><code>docker run --rm \\\n    --hostname container-name.internal \\ #(18)\n    -e VPN_ENABLED=\"true\" \\ #(5)\n    -e VPN_CONF=\"wg0\" \\ #(8)\n    -e VPN_PROVIDER=\"pia\" \\ #(4)\n    -e VPN_LAN_NETWORK=\"192.168.1.0/24\" \\ #(1)\n    -e VPN_LAN_LEAK_ENABLED=\"false\" \\ #(10)\n    -e VPN_EXPOSE_PORTS_ON_LAN=\"\" \\ #(2)\n    -e VPN_AUTO_PORT_FORWARD=\"true\" \\ #(6)\n    -e VPN_AUTO_PORT_FORWARD_TO_PORTS=\"\" \\ #(15)\n    -e VPN_FIREWALL_TYPE=\"auto\" \\ #(17)\n    -e VPN_HEALTHCHECK_ENABLED=\"false\" \\ #(20)\n    -e VPN_NAMESERVERS=\"\" \\ #(16)\n    -e VPN_PIA_USER=\"\" \\ #(11)\n    -e VPN_PIA_PASS=\"\" \\ #(11)\n    -e VPN_PIA_PREFERRED_REGION=\"\" \\ #(7)\n    -e VPN_PIA_DIP_TOKEN=\"no\" \\ #(13)\n    -e VPN_PIA_PORT_FORWARD_PERSIST=\"false\" \\ #(14)\n    -e PRIVOXY_ENABLED=\"false\" \\ #(19)\n    -e UNBOUND_ENABLED=\"false\" \\ #(21)\n    -e UNBOUND_NAMESERVERS=\"\" \\ #(22)\n    --cap-add=NET_ADMIN \\\n    --sysctl=\"net.ipv4.conf.all.src_valid_mark=1\" \\ #(12)\n    --sysctl=\"net.ipv6.conf.all.disable_ipv6=1\" \\ #(3)\n    --device /dev/net/tun:/dev/net/tun \\ # OPTIONAL(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui. On MacOS set it to <code>192.168.65.0/24</code> (Verify with your settings [Resources &gt; Network &gt; Docker subnet]).</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>. Affiliate links: Proton VPN Proton Unlimited Private Internet Access</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> (for PIA this is done automatically, see <code>VPN_PROVIDER</code> variable) located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32 in most cases\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>DANGEROUS! Don't enable unless you know what you are doing!</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>Some of the possible values are for example <code>wg</code>, <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>wg</code> will use the nameservers from the <code>wg0.conf</code> file. A value in the format <code>8.8.8.8</code> is to use a plain old nameserver. A value in the format <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>If you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice.</p> </li> <li> <p>This will start Privoxy on the default port 8118 when set to <code>true</code>. By default Privoxy is not exposed on the LAN, so if you need that, you'll have to add <code>VPN_EXPOSE_PORTS_ON_LAN=8118/tcp,8118/udp</code>.</p> </li> <li> <p>Enabling this will bring down the container if the connectivity tests fail at the end of the Wireguard init process or for an extended period during the container runtime.</p> </li> <li> <p>Enable Unbound by setting to <code>true</code> when VPN is not active.</p> </li> <li> <p>Possible values are <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>8.8.8.8</code> is to use a plain old nameserver. The value <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> </ol> <pre><code>services:\n  app:\n    hostname: container-name.internal #(18)\n    environment:\n      - VPN_ENABLED=true #(5)\n      - VPN_CONF=wg0 #(8)\n      - VPN_PROVIDER=pia #(4)\n      - VPN_LAN_NETWORK=192.168.1.0/24 #(1)\n      - VPN_LAN_LEAK_ENABLED=false #(10)\n      - VPN_EXPOSE_PORTS_ON_LAN #(2)\n      - VPN_AUTO_PORT_FORWARD=true #(6)\n      - VPN_AUTO_PORT_FORWARD_TO_PORTS= #(15)\n      - VPN_FIREWALL_TYPE=auto #(17)\n      - VPN_HEALTHCHECK_ENABLED=false #(20)\n      - VPN_NAMESERVERS= #(16)\n      - VPN_PIA_USER #(11)\n      - VPN_PIA_PASS #(11)\n      - VPN_PIA_PREFERRED_REGION #(7)\n      - VPN_PIA_DIP_TOKEN=no #(13)\n      - VPN_PIA_PORT_FORWARD_PERSIST=false #(14)\n      - PRIVOXY_ENABLED=false #(19)\n      - UNBOUND_ENABLED=false #(21)\n      - UNBOUND_NAMESERVERS #(22)\n    cap_add:\n      - NET_ADMIN\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1 #(12)\n      - net.ipv6.conf.all.disable_ipv6=1 #(3)\n    devices:\n      - /dev/net/tun:/dev/net/tun # OPTIONAL(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui. On MacOS set it to <code>192.168.65.0/24</code> (Verify with your settings [Resources &gt; Network &gt; Docker subnet]).</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>. Affiliate links: Proton VPN Proton Unlimited Private Internet Access</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> (for PIA this is done automatically, see <code>VPN_PROVIDER</code> variable) located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32 in most cases\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>DANGEROUS! Don't enable unless you know what you are doing!</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>Some of the possible values are for example <code>wg</code>, <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>wg</code> will use the nameservers from the <code>wg0.conf</code> file. A value in the format <code>8.8.8.8</code> is to use a plain old nameserver. A value in the format <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>If you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice.</p> </li> <li> <p>This will start Privoxy on the default port 8118 when set to <code>true</code>. By default Privoxy is not exposed on the LAN, so if you need that, you'll have to add <code>VPN_EXPOSE_PORTS_ON_LAN=8118/tcp,8118/udp</code>.</p> </li> <li> <p>Enabling this will bring down the container if the connectivity tests fail at the end of the Wireguard init process or for an extended period during the container runtime.</p> </li> <li> <p>Enable Unbound by setting to <code>true</code> when VPN is not active.</p> </li> <li> <p>Possible values are <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>8.8.8.8</code> is to use a plain old nameserver. The value <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> </ol>"},{"location":"containers/qui/","title":"hotio/qui","text":"<p> GitHub ghcr.io</p>"},{"location":"containers/qui/#starting-the-container","title":"Starting the container","text":"clicompose <pre><code>docker run --rm \\\n    --name qui \\\n    -p 7476:7476 \\\n    -e PUID=1000 \\\n    -e PGID=1000 \\\n    -e UMASK=002 \\\n    -e TZ=\"Etc/UTC\" \\\n    -v /&lt;host_folder_config&gt;:/config \\\n    ghcr.io/hotio/qui\n</code></pre> <pre><code>services:\n  qui:\n    container_name: qui\n    image: ghcr.io/hotio/qui\n    ports:\n      - \"7476:7476\"\n    environment:\n      - PUID=1000\n      - PGID=1000\n      - UMASK=002\n      - TZ=Etc/UTC\n    volumes:\n      - /&lt;host_folder_config&gt;:/config\n</code></pre>"},{"location":"containers/qui/#tags","title":"Tags","text":"Tags Description Last Updated Age"},{"location":"containers/qui/#wireguard","title":"WireGuard","text":"<p>Info</p> <p>This image includes VPN support. The cli/compose examples below are environment variables and settings complementary to the app image examples, this means you'll have to add/merge the stuff below with the stuff above. In case you are still in need of a VPN, consider using my affiliate links for Proton VPN, Proton Unlimited or Private Internet Access.</p> <p> </p> genericprotonpia clicompose <pre><code>docker run --rm \\\n    --hostname container-name.internal \\ #(18)\n    -e VPN_ENABLED=\"true\" \\ #(5)\n    -e VPN_CONF=\"wg0\" \\ #(8)\n    -e VPN_PROVIDER=\"generic\" \\ #(4)\n    -e VPN_LAN_NETWORK=\"192.168.1.0/24\" \\ #(1)\n    -e VPN_LAN_LEAK_ENABLED=\"false\" \\ #(10)\n    -e VPN_EXPOSE_PORTS_ON_LAN=\"\" \\ #(2)\n    -e VPN_AUTO_PORT_FORWARD=\"false\" \\ #(6)\n    -e VPN_AUTO_PORT_FORWARD_TO_PORTS=\"\" \\ #(15)\n    -e VPN_FIREWALL_TYPE=\"auto\" \\ #(17)\n    -e VPN_HEALTHCHECK_ENABLED=\"false\" \\ #(20)\n    -e VPN_NAMESERVERS=\"\" \\ #(16)\n    -e PRIVOXY_ENABLED=\"false\" \\ #(19)\n    -e UNBOUND_ENABLED=\"false\" \\ #(21)\n    -e UNBOUND_NAMESERVERS=\"\" \\ #(22)\n    --cap-add=NET_ADMIN \\\n    --sysctl=\"net.ipv4.conf.all.src_valid_mark=1\" \\ #(12)\n    --sysctl=\"net.ipv6.conf.all.disable_ipv6=1\" \\ #(3)\n    --device /dev/net/tun:/dev/net/tun \\ # OPTIONAL(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui. On MacOS set it to <code>192.168.65.0/24</code> (Verify with your settings [Resources &gt; Network &gt; Docker subnet]).</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>. Affiliate links: Proton VPN Proton Unlimited Private Internet Access</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> (for PIA this is done automatically, see <code>VPN_PROVIDER</code> variable) located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32 in most cases\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>DANGEROUS! Don't enable unless you know what you are doing!</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>Some of the possible values are for example <code>wg</code>, <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>wg</code> will use the nameservers from the <code>wg0.conf</code> file. A value in the format <code>8.8.8.8</code> is to use a plain old nameserver. A value in the format <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>If you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice.</p> </li> <li> <p>This will start Privoxy on the default port 8118 when set to <code>true</code>. By default Privoxy is not exposed on the LAN, so if you need that, you'll have to add <code>VPN_EXPOSE_PORTS_ON_LAN=8118/tcp,8118/udp</code>.</p> </li> <li> <p>Enabling this will bring down the container if the connectivity tests fail at the end of the Wireguard init process or for an extended period during the container runtime.</p> </li> <li> <p>Enable Unbound by setting to <code>true</code> when VPN is not active.</p> </li> <li> <p>Possible values are <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>8.8.8.8</code> is to use a plain old nameserver. The value <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> </ol> <pre><code>services:\n  app:\n    hostname: container-name.internal #(18)\n    environment:\n      - VPN_ENABLED=true #(5)\n      - VPN_CONF=wg0 #(8)\n      - VPN_PROVIDER=generic #(4)\n      - VPN_LAN_NETWORK=192.168.1.0/24 #(1)\n      - VPN_LAN_LEAK_ENABLED=false #(10)\n      - VPN_EXPOSE_PORTS_ON_LAN #(2)\n      - VPN_AUTO_PORT_FORWARD=false #(6)\n      - VPN_AUTO_PORT_FORWARD_TO_PORTS= #(15)\n      - VPN_FIREWALL_TYPE=auto #(17)\n      - VPN_HEALTHCHECK_ENABLED=false #(20)\n      - VPN_NAMESERVERS= #(16)\n      - PRIVOXY_ENABLED=false #(19)\n      - UNBOUND_ENABLED=false #(21)\n      - UNBOUND_NAMESERVERS #(22)\n    cap_add:\n      - NET_ADMIN\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1 #(12)\n      - net.ipv6.conf.all.disable_ipv6=1 #(3)\n    devices:\n      - /dev/net/tun:/dev/net/tun # OPTIONAL(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui. On MacOS set it to <code>192.168.65.0/24</code> (Verify with your settings [Resources &gt; Network &gt; Docker subnet]).</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>. Affiliate links: Proton VPN Proton Unlimited Private Internet Access</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> (for PIA this is done automatically, see <code>VPN_PROVIDER</code> variable) located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32 in most cases\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>DANGEROUS! Don't enable unless you know what you are doing!</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>Some of the possible values are for example <code>wg</code>, <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>wg</code> will use the nameservers from the <code>wg0.conf</code> file. A value in the format <code>8.8.8.8</code> is to use a plain old nameserver. A value in the format <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>If you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice.</p> </li> <li> <p>This will start Privoxy on the default port 8118 when set to <code>true</code>. By default Privoxy is not exposed on the LAN, so if you need that, you'll have to add <code>VPN_EXPOSE_PORTS_ON_LAN=8118/tcp,8118/udp</code>.</p> </li> <li> <p>Enabling this will bring down the container if the connectivity tests fail at the end of the Wireguard init process or for an extended period during the container runtime.</p> </li> <li> <p>Enable Unbound by setting to <code>true</code> when VPN is not active.</p> </li> <li> <p>Possible values are <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>8.8.8.8</code> is to use a plain old nameserver. The value <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> </ol> clicompose <pre><code>docker run --rm \\\n    --hostname container-name.internal \\ #(18)\n    -e VPN_ENABLED=\"true\" \\ #(5)\n    -e VPN_CONF=\"wg0\" \\ #(8)\n    -e VPN_PROVIDER=\"proton\" \\ #(4)\n    -e VPN_LAN_NETWORK=\"192.168.1.0/24\" \\ #(1)\n    -e VPN_LAN_LEAK_ENABLED=\"false\" \\ #(10)\n    -e VPN_EXPOSE_PORTS_ON_LAN=\"\" \\ #(2)\n    -e VPN_AUTO_PORT_FORWARD=\"true\" \\ #(6)\n    -e VPN_AUTO_PORT_FORWARD_TO_PORTS=\"\" \\ #(15)\n    -e VPN_FIREWALL_TYPE=\"auto\" \\ #(17)\n    -e VPN_HEALTHCHECK_ENABLED=\"false\" \\ #(20)\n    -e VPN_NAMESERVERS=\"\" \\ #(16)\n    -e PRIVOXY_ENABLED=\"false\" \\ #(19)\n    -e UNBOUND_ENABLED=\"false\" \\ #(21)\n    -e UNBOUND_NAMESERVERS=\"\" \\ #(22)\n    --cap-add=NET_ADMIN \\\n    --sysctl=\"net.ipv4.conf.all.src_valid_mark=1\" \\ #(12)\n    --sysctl=\"net.ipv6.conf.all.disable_ipv6=1\" \\ #(3)\n    --device /dev/net/tun:/dev/net/tun \\ # OPTIONAL(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui. On MacOS set it to <code>192.168.65.0/24</code> (Verify with your settings [Resources &gt; Network &gt; Docker subnet]).</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>. Affiliate links: Proton VPN Proton Unlimited Private Internet Access</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> (for PIA this is done automatically, see <code>VPN_PROVIDER</code> variable) located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32 in most cases\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>DANGEROUS! Don't enable unless you know what you are doing!</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>Some of the possible values are for example <code>wg</code>, <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>wg</code> will use the nameservers from the <code>wg0.conf</code> file. A value in the format <code>8.8.8.8</code> is to use a plain old nameserver. A value in the format <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>If you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice.</p> </li> <li> <p>This will start Privoxy on the default port 8118 when set to <code>true</code>. By default Privoxy is not exposed on the LAN, so if you need that, you'll have to add <code>VPN_EXPOSE_PORTS_ON_LAN=8118/tcp,8118/udp</code>.</p> </li> <li> <p>Enabling this will bring down the container if the connectivity tests fail at the end of the Wireguard init process or for an extended period during the container runtime.</p> </li> <li> <p>Enable Unbound by setting to <code>true</code> when VPN is not active.</p> </li> <li> <p>Possible values are <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>8.8.8.8</code> is to use a plain old nameserver. The value <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> </ol> <pre><code>services:\n  app:\n    hostname: container-name.internal #(18)\n    environment:\n      - VPN_ENABLED=true #(5)\n      - VPN_CONF=wg0 #(8)\n      - VPN_PROVIDER=proton #(4)\n      - VPN_LAN_NETWORK=192.168.1.0/24 #(1)\n      - VPN_LAN_LEAK_ENABLED=false #(10)\n      - VPN_EXPOSE_PORTS_ON_LAN #(2)\n      - VPN_AUTO_PORT_FORWARD=true #(6)\n      - VPN_AUTO_PORT_FORWARD_TO_PORTS= #(15)\n      - VPN_FIREWALL_TYPE=auto #(17)\n      - VPN_HEALTHCHECK_ENABLED=false #(20)\n      - VPN_NAMESERVERS= #(16)\n      - PRIVOXY_ENABLED=false #(19)\n      - UNBOUND_ENABLED=false #(21)\n      - UNBOUND_NAMESERVERS #(22)\n    cap_add:\n      - NET_ADMIN\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1 #(12)\n      - net.ipv6.conf.all.disable_ipv6=1 #(3)\n    devices:\n      - /dev/net/tun:/dev/net/tun # OPTIONAL(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui. On MacOS set it to <code>192.168.65.0/24</code> (Verify with your settings [Resources &gt; Network &gt; Docker subnet]).</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>. Affiliate links: Proton VPN Proton Unlimited Private Internet Access</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> (for PIA this is done automatically, see <code>VPN_PROVIDER</code> variable) located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32 in most cases\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>DANGEROUS! Don't enable unless you know what you are doing!</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>Some of the possible values are for example <code>wg</code>, <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>wg</code> will use the nameservers from the <code>wg0.conf</code> file. A value in the format <code>8.8.8.8</code> is to use a plain old nameserver. A value in the format <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>If you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice.</p> </li> <li> <p>This will start Privoxy on the default port 8118 when set to <code>true</code>. By default Privoxy is not exposed on the LAN, so if you need that, you'll have to add <code>VPN_EXPOSE_PORTS_ON_LAN=8118/tcp,8118/udp</code>.</p> </li> <li> <p>Enabling this will bring down the container if the connectivity tests fail at the end of the Wireguard init process or for an extended period during the container runtime.</p> </li> <li> <p>Enable Unbound by setting to <code>true</code> when VPN is not active.</p> </li> <li> <p>Possible values are <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>8.8.8.8</code> is to use a plain old nameserver. The value <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> </ol> clicompose <pre><code>docker run --rm \\\n    --hostname container-name.internal \\ #(18)\n    -e VPN_ENABLED=\"true\" \\ #(5)\n    -e VPN_CONF=\"wg0\" \\ #(8)\n    -e VPN_PROVIDER=\"pia\" \\ #(4)\n    -e VPN_LAN_NETWORK=\"192.168.1.0/24\" \\ #(1)\n    -e VPN_LAN_LEAK_ENABLED=\"false\" \\ #(10)\n    -e VPN_EXPOSE_PORTS_ON_LAN=\"\" \\ #(2)\n    -e VPN_AUTO_PORT_FORWARD=\"true\" \\ #(6)\n    -e VPN_AUTO_PORT_FORWARD_TO_PORTS=\"\" \\ #(15)\n    -e VPN_FIREWALL_TYPE=\"auto\" \\ #(17)\n    -e VPN_HEALTHCHECK_ENABLED=\"false\" \\ #(20)\n    -e VPN_NAMESERVERS=\"\" \\ #(16)\n    -e VPN_PIA_USER=\"\" \\ #(11)\n    -e VPN_PIA_PASS=\"\" \\ #(11)\n    -e VPN_PIA_PREFERRED_REGION=\"\" \\ #(7)\n    -e VPN_PIA_DIP_TOKEN=\"no\" \\ #(13)\n    -e VPN_PIA_PORT_FORWARD_PERSIST=\"false\" \\ #(14)\n    -e PRIVOXY_ENABLED=\"false\" \\ #(19)\n    -e UNBOUND_ENABLED=\"false\" \\ #(21)\n    -e UNBOUND_NAMESERVERS=\"\" \\ #(22)\n    --cap-add=NET_ADMIN \\\n    --sysctl=\"net.ipv4.conf.all.src_valid_mark=1\" \\ #(12)\n    --sysctl=\"net.ipv6.conf.all.disable_ipv6=1\" \\ #(3)\n    --device /dev/net/tun:/dev/net/tun \\ # OPTIONAL(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui. On MacOS set it to <code>192.168.65.0/24</code> (Verify with your settings [Resources &gt; Network &gt; Docker subnet]).</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>. Affiliate links: Proton VPN Proton Unlimited Private Internet Access</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> (for PIA this is done automatically, see <code>VPN_PROVIDER</code> variable) located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32 in most cases\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>DANGEROUS! Don't enable unless you know what you are doing!</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>Some of the possible values are for example <code>wg</code>, <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>wg</code> will use the nameservers from the <code>wg0.conf</code> file. A value in the format <code>8.8.8.8</code> is to use a plain old nameserver. A value in the format <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>If you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice.</p> </li> <li> <p>This will start Privoxy on the default port 8118 when set to <code>true</code>. By default Privoxy is not exposed on the LAN, so if you need that, you'll have to add <code>VPN_EXPOSE_PORTS_ON_LAN=8118/tcp,8118/udp</code>.</p> </li> <li> <p>Enabling this will bring down the container if the connectivity tests fail at the end of the Wireguard init process or for an extended period during the container runtime.</p> </li> <li> <p>Enable Unbound by setting to <code>true</code> when VPN is not active.</p> </li> <li> <p>Possible values are <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>8.8.8.8</code> is to use a plain old nameserver. The value <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> </ol> <pre><code>services:\n  app:\n    hostname: container-name.internal #(18)\n    environment:\n      - VPN_ENABLED=true #(5)\n      - VPN_CONF=wg0 #(8)\n      - VPN_PROVIDER=pia #(4)\n      - VPN_LAN_NETWORK=192.168.1.0/24 #(1)\n      - VPN_LAN_LEAK_ENABLED=false #(10)\n      - VPN_EXPOSE_PORTS_ON_LAN #(2)\n      - VPN_AUTO_PORT_FORWARD=true #(6)\n      - VPN_AUTO_PORT_FORWARD_TO_PORTS= #(15)\n      - VPN_FIREWALL_TYPE=auto #(17)\n      - VPN_HEALTHCHECK_ENABLED=false #(20)\n      - VPN_NAMESERVERS= #(16)\n      - VPN_PIA_USER #(11)\n      - VPN_PIA_PASS #(11)\n      - VPN_PIA_PREFERRED_REGION #(7)\n      - VPN_PIA_DIP_TOKEN=no #(13)\n      - VPN_PIA_PORT_FORWARD_PERSIST=false #(14)\n      - PRIVOXY_ENABLED=false #(19)\n      - UNBOUND_ENABLED=false #(21)\n      - UNBOUND_NAMESERVERS #(22)\n    cap_add:\n      - NET_ADMIN\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1 #(12)\n      - net.ipv6.conf.all.disable_ipv6=1 #(3)\n    devices:\n      - /dev/net/tun:/dev/net/tun # OPTIONAL(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui. On MacOS set it to <code>192.168.65.0/24</code> (Verify with your settings [Resources &gt; Network &gt; Docker subnet]).</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>. Affiliate links: Proton VPN Proton Unlimited Private Internet Access</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> (for PIA this is done automatically, see <code>VPN_PROVIDER</code> variable) located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32 in most cases\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>DANGEROUS! Don't enable unless you know what you are doing!</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>Some of the possible values are for example <code>wg</code>, <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>wg</code> will use the nameservers from the <code>wg0.conf</code> file. A value in the format <code>8.8.8.8</code> is to use a plain old nameserver. A value in the format <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>If you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice.</p> </li> <li> <p>This will start Privoxy on the default port 8118 when set to <code>true</code>. By default Privoxy is not exposed on the LAN, so if you need that, you'll have to add <code>VPN_EXPOSE_PORTS_ON_LAN=8118/tcp,8118/udp</code>.</p> </li> <li> <p>Enabling this will bring down the container if the connectivity tests fail at the end of the Wireguard init process or for an extended period during the container runtime.</p> </li> <li> <p>Enable Unbound by setting to <code>true</code> when VPN is not active.</p> </li> <li> <p>Possible values are <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>8.8.8.8</code> is to use a plain old nameserver. The value <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> </ol>"},{"location":"containers/radarr/","title":"hotio/radarr","text":"<p> GitHub ghcr.io</p>"},{"location":"containers/radarr/#starting-the-container","title":"Starting the container","text":"clicompose <pre><code>docker run --rm \\\n    --name radarr \\\n    -p 7878:7878 \\\n    -e PUID=1000 \\\n    -e PGID=1000 \\\n    -e UMASK=002 \\\n    -e TZ=\"Etc/UTC\" \\\n    -v /&lt;host_folder_config&gt;:/config \\\n    -v /&lt;host_folder_data&gt;:/data \\\n    ghcr.io/hotio/radarr\n</code></pre> <pre><code>services:\n  radarr:\n    container_name: radarr\n    image: ghcr.io/hotio/radarr\n    ports:\n      - \"7878:7878\"\n    environment:\n      - PUID=1000\n      - PGID=1000\n      - UMASK=002\n      - TZ=Etc/UTC\n    volumes:\n      - /&lt;host_folder_config&gt;:/config\n      - /&lt;host_folder_data&gt;:/data\n</code></pre>"},{"location":"containers/radarr/#tags","title":"Tags","text":"Tags Description Last Updated Age"},{"location":"containers/radarr/#wireguard","title":"WireGuard","text":"<p>Info</p> <p>This image includes VPN support. The cli/compose examples below are environment variables and settings complementary to the app image examples, this means you'll have to add/merge the stuff below with the stuff above. In case you are still in need of a VPN, consider using my affiliate links for Proton VPN, Proton Unlimited or Private Internet Access.</p> <p> </p> genericprotonpia clicompose <pre><code>docker run --rm \\\n    --hostname container-name.internal \\ #(18)\n    -e VPN_ENABLED=\"true\" \\ #(5)\n    -e VPN_CONF=\"wg0\" \\ #(8)\n    -e VPN_PROVIDER=\"generic\" \\ #(4)\n    -e VPN_LAN_NETWORK=\"192.168.1.0/24\" \\ #(1)\n    -e VPN_LAN_LEAK_ENABLED=\"false\" \\ #(10)\n    -e VPN_EXPOSE_PORTS_ON_LAN=\"\" \\ #(2)\n    -e VPN_AUTO_PORT_FORWARD=\"false\" \\ #(6)\n    -e VPN_AUTO_PORT_FORWARD_TO_PORTS=\"\" \\ #(15)\n    -e VPN_FIREWALL_TYPE=\"auto\" \\ #(17)\n    -e VPN_HEALTHCHECK_ENABLED=\"false\" \\ #(20)\n    -e VPN_NAMESERVERS=\"\" \\ #(16)\n    -e PRIVOXY_ENABLED=\"false\" \\ #(19)\n    -e UNBOUND_ENABLED=\"false\" \\ #(21)\n    -e UNBOUND_NAMESERVERS=\"\" \\ #(22)\n    --cap-add=NET_ADMIN \\\n    --sysctl=\"net.ipv4.conf.all.src_valid_mark=1\" \\ #(12)\n    --sysctl=\"net.ipv6.conf.all.disable_ipv6=1\" \\ #(3)\n    --device /dev/net/tun:/dev/net/tun \\ # OPTIONAL(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui. On MacOS set it to <code>192.168.65.0/24</code> (Verify with your settings [Resources &gt; Network &gt; Docker subnet]).</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>. Affiliate links: Proton VPN Proton Unlimited Private Internet Access</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> (for PIA this is done automatically, see <code>VPN_PROVIDER</code> variable) located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32 in most cases\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>DANGEROUS! Don't enable unless you know what you are doing!</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>Some of the possible values are for example <code>wg</code>, <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>wg</code> will use the nameservers from the <code>wg0.conf</code> file. A value in the format <code>8.8.8.8</code> is to use a plain old nameserver. A value in the format <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>If you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice.</p> </li> <li> <p>This will start Privoxy on the default port 8118 when set to <code>true</code>. By default Privoxy is not exposed on the LAN, so if you need that, you'll have to add <code>VPN_EXPOSE_PORTS_ON_LAN=8118/tcp,8118/udp</code>.</p> </li> <li> <p>Enabling this will bring down the container if the connectivity tests fail at the end of the Wireguard init process or for an extended period during the container runtime.</p> </li> <li> <p>Enable Unbound by setting to <code>true</code> when VPN is not active.</p> </li> <li> <p>Possible values are <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>8.8.8.8</code> is to use a plain old nameserver. The value <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> </ol> <pre><code>services:\n  app:\n    hostname: container-name.internal #(18)\n    environment:\n      - VPN_ENABLED=true #(5)\n      - VPN_CONF=wg0 #(8)\n      - VPN_PROVIDER=generic #(4)\n      - VPN_LAN_NETWORK=192.168.1.0/24 #(1)\n      - VPN_LAN_LEAK_ENABLED=false #(10)\n      - VPN_EXPOSE_PORTS_ON_LAN #(2)\n      - VPN_AUTO_PORT_FORWARD=false #(6)\n      - VPN_AUTO_PORT_FORWARD_TO_PORTS= #(15)\n      - VPN_FIREWALL_TYPE=auto #(17)\n      - VPN_HEALTHCHECK_ENABLED=false #(20)\n      - VPN_NAMESERVERS= #(16)\n      - PRIVOXY_ENABLED=false #(19)\n      - UNBOUND_ENABLED=false #(21)\n      - UNBOUND_NAMESERVERS #(22)\n    cap_add:\n      - NET_ADMIN\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1 #(12)\n      - net.ipv6.conf.all.disable_ipv6=1 #(3)\n    devices:\n      - /dev/net/tun:/dev/net/tun # OPTIONAL(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui. On MacOS set it to <code>192.168.65.0/24</code> (Verify with your settings [Resources &gt; Network &gt; Docker subnet]).</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>. Affiliate links: Proton VPN Proton Unlimited Private Internet Access</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> (for PIA this is done automatically, see <code>VPN_PROVIDER</code> variable) located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32 in most cases\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>DANGEROUS! Don't enable unless you know what you are doing!</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>Some of the possible values are for example <code>wg</code>, <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>wg</code> will use the nameservers from the <code>wg0.conf</code> file. A value in the format <code>8.8.8.8</code> is to use a plain old nameserver. A value in the format <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>If you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice.</p> </li> <li> <p>This will start Privoxy on the default port 8118 when set to <code>true</code>. By default Privoxy is not exposed on the LAN, so if you need that, you'll have to add <code>VPN_EXPOSE_PORTS_ON_LAN=8118/tcp,8118/udp</code>.</p> </li> <li> <p>Enabling this will bring down the container if the connectivity tests fail at the end of the Wireguard init process or for an extended period during the container runtime.</p> </li> <li> <p>Enable Unbound by setting to <code>true</code> when VPN is not active.</p> </li> <li> <p>Possible values are <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>8.8.8.8</code> is to use a plain old nameserver. The value <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> </ol> clicompose <pre><code>docker run --rm \\\n    --hostname container-name.internal \\ #(18)\n    -e VPN_ENABLED=\"true\" \\ #(5)\n    -e VPN_CONF=\"wg0\" \\ #(8)\n    -e VPN_PROVIDER=\"proton\" \\ #(4)\n    -e VPN_LAN_NETWORK=\"192.168.1.0/24\" \\ #(1)\n    -e VPN_LAN_LEAK_ENABLED=\"false\" \\ #(10)\n    -e VPN_EXPOSE_PORTS_ON_LAN=\"\" \\ #(2)\n    -e VPN_AUTO_PORT_FORWARD=\"true\" \\ #(6)\n    -e VPN_AUTO_PORT_FORWARD_TO_PORTS=\"\" \\ #(15)\n    -e VPN_FIREWALL_TYPE=\"auto\" \\ #(17)\n    -e VPN_HEALTHCHECK_ENABLED=\"false\" \\ #(20)\n    -e VPN_NAMESERVERS=\"\" \\ #(16)\n    -e PRIVOXY_ENABLED=\"false\" \\ #(19)\n    -e UNBOUND_ENABLED=\"false\" \\ #(21)\n    -e UNBOUND_NAMESERVERS=\"\" \\ #(22)\n    --cap-add=NET_ADMIN \\\n    --sysctl=\"net.ipv4.conf.all.src_valid_mark=1\" \\ #(12)\n    --sysctl=\"net.ipv6.conf.all.disable_ipv6=1\" \\ #(3)\n    --device /dev/net/tun:/dev/net/tun \\ # OPTIONAL(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui. On MacOS set it to <code>192.168.65.0/24</code> (Verify with your settings [Resources &gt; Network &gt; Docker subnet]).</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>. Affiliate links: Proton VPN Proton Unlimited Private Internet Access</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> (for PIA this is done automatically, see <code>VPN_PROVIDER</code> variable) located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32 in most cases\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>DANGEROUS! Don't enable unless you know what you are doing!</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>Some of the possible values are for example <code>wg</code>, <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>wg</code> will use the nameservers from the <code>wg0.conf</code> file. A value in the format <code>8.8.8.8</code> is to use a plain old nameserver. A value in the format <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>If you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice.</p> </li> <li> <p>This will start Privoxy on the default port 8118 when set to <code>true</code>. By default Privoxy is not exposed on the LAN, so if you need that, you'll have to add <code>VPN_EXPOSE_PORTS_ON_LAN=8118/tcp,8118/udp</code>.</p> </li> <li> <p>Enabling this will bring down the container if the connectivity tests fail at the end of the Wireguard init process or for an extended period during the container runtime.</p> </li> <li> <p>Enable Unbound by setting to <code>true</code> when VPN is not active.</p> </li> <li> <p>Possible values are <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>8.8.8.8</code> is to use a plain old nameserver. The value <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> </ol> <pre><code>services:\n  app:\n    hostname: container-name.internal #(18)\n    environment:\n      - VPN_ENABLED=true #(5)\n      - VPN_CONF=wg0 #(8)\n      - VPN_PROVIDER=proton #(4)\n      - VPN_LAN_NETWORK=192.168.1.0/24 #(1)\n      - VPN_LAN_LEAK_ENABLED=false #(10)\n      - VPN_EXPOSE_PORTS_ON_LAN #(2)\n      - VPN_AUTO_PORT_FORWARD=true #(6)\n      - VPN_AUTO_PORT_FORWARD_TO_PORTS= #(15)\n      - VPN_FIREWALL_TYPE=auto #(17)\n      - VPN_HEALTHCHECK_ENABLED=false #(20)\n      - VPN_NAMESERVERS= #(16)\n      - PRIVOXY_ENABLED=false #(19)\n      - UNBOUND_ENABLED=false #(21)\n      - UNBOUND_NAMESERVERS #(22)\n    cap_add:\n      - NET_ADMIN\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1 #(12)\n      - net.ipv6.conf.all.disable_ipv6=1 #(3)\n    devices:\n      - /dev/net/tun:/dev/net/tun # OPTIONAL(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui. On MacOS set it to <code>192.168.65.0/24</code> (Verify with your settings [Resources &gt; Network &gt; Docker subnet]).</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>. Affiliate links: Proton VPN Proton Unlimited Private Internet Access</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> (for PIA this is done automatically, see <code>VPN_PROVIDER</code> variable) located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32 in most cases\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>DANGEROUS! Don't enable unless you know what you are doing!</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>Some of the possible values are for example <code>wg</code>, <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>wg</code> will use the nameservers from the <code>wg0.conf</code> file. A value in the format <code>8.8.8.8</code> is to use a plain old nameserver. A value in the format <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>If you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice.</p> </li> <li> <p>This will start Privoxy on the default port 8118 when set to <code>true</code>. By default Privoxy is not exposed on the LAN, so if you need that, you'll have to add <code>VPN_EXPOSE_PORTS_ON_LAN=8118/tcp,8118/udp</code>.</p> </li> <li> <p>Enabling this will bring down the container if the connectivity tests fail at the end of the Wireguard init process or for an extended period during the container runtime.</p> </li> <li> <p>Enable Unbound by setting to <code>true</code> when VPN is not active.</p> </li> <li> <p>Possible values are <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>8.8.8.8</code> is to use a plain old nameserver. The value <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> </ol> clicompose <pre><code>docker run --rm \\\n    --hostname container-name.internal \\ #(18)\n    -e VPN_ENABLED=\"true\" \\ #(5)\n    -e VPN_CONF=\"wg0\" \\ #(8)\n    -e VPN_PROVIDER=\"pia\" \\ #(4)\n    -e VPN_LAN_NETWORK=\"192.168.1.0/24\" \\ #(1)\n    -e VPN_LAN_LEAK_ENABLED=\"false\" \\ #(10)\n    -e VPN_EXPOSE_PORTS_ON_LAN=\"\" \\ #(2)\n    -e VPN_AUTO_PORT_FORWARD=\"true\" \\ #(6)\n    -e VPN_AUTO_PORT_FORWARD_TO_PORTS=\"\" \\ #(15)\n    -e VPN_FIREWALL_TYPE=\"auto\" \\ #(17)\n    -e VPN_HEALTHCHECK_ENABLED=\"false\" \\ #(20)\n    -e VPN_NAMESERVERS=\"\" \\ #(16)\n    -e VPN_PIA_USER=\"\" \\ #(11)\n    -e VPN_PIA_PASS=\"\" \\ #(11)\n    -e VPN_PIA_PREFERRED_REGION=\"\" \\ #(7)\n    -e VPN_PIA_DIP_TOKEN=\"no\" \\ #(13)\n    -e VPN_PIA_PORT_FORWARD_PERSIST=\"false\" \\ #(14)\n    -e PRIVOXY_ENABLED=\"false\" \\ #(19)\n    -e UNBOUND_ENABLED=\"false\" \\ #(21)\n    -e UNBOUND_NAMESERVERS=\"\" \\ #(22)\n    --cap-add=NET_ADMIN \\\n    --sysctl=\"net.ipv4.conf.all.src_valid_mark=1\" \\ #(12)\n    --sysctl=\"net.ipv6.conf.all.disable_ipv6=1\" \\ #(3)\n    --device /dev/net/tun:/dev/net/tun \\ # OPTIONAL(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui. On MacOS set it to <code>192.168.65.0/24</code> (Verify with your settings [Resources &gt; Network &gt; Docker subnet]).</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>. Affiliate links: Proton VPN Proton Unlimited Private Internet Access</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> (for PIA this is done automatically, see <code>VPN_PROVIDER</code> variable) located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32 in most cases\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>DANGEROUS! Don't enable unless you know what you are doing!</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>Some of the possible values are for example <code>wg</code>, <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>wg</code> will use the nameservers from the <code>wg0.conf</code> file. A value in the format <code>8.8.8.8</code> is to use a plain old nameserver. A value in the format <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>If you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice.</p> </li> <li> <p>This will start Privoxy on the default port 8118 when set to <code>true</code>. By default Privoxy is not exposed on the LAN, so if you need that, you'll have to add <code>VPN_EXPOSE_PORTS_ON_LAN=8118/tcp,8118/udp</code>.</p> </li> <li> <p>Enabling this will bring down the container if the connectivity tests fail at the end of the Wireguard init process or for an extended period during the container runtime.</p> </li> <li> <p>Enable Unbound by setting to <code>true</code> when VPN is not active.</p> </li> <li> <p>Possible values are <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>8.8.8.8</code> is to use a plain old nameserver. The value <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> </ol> <pre><code>services:\n  app:\n    hostname: container-name.internal #(18)\n    environment:\n      - VPN_ENABLED=true #(5)\n      - VPN_CONF=wg0 #(8)\n      - VPN_PROVIDER=pia #(4)\n      - VPN_LAN_NETWORK=192.168.1.0/24 #(1)\n      - VPN_LAN_LEAK_ENABLED=false #(10)\n      - VPN_EXPOSE_PORTS_ON_LAN #(2)\n      - VPN_AUTO_PORT_FORWARD=true #(6)\n      - VPN_AUTO_PORT_FORWARD_TO_PORTS= #(15)\n      - VPN_FIREWALL_TYPE=auto #(17)\n      - VPN_HEALTHCHECK_ENABLED=false #(20)\n      - VPN_NAMESERVERS= #(16)\n      - VPN_PIA_USER #(11)\n      - VPN_PIA_PASS #(11)\n      - VPN_PIA_PREFERRED_REGION #(7)\n      - VPN_PIA_DIP_TOKEN=no #(13)\n      - VPN_PIA_PORT_FORWARD_PERSIST=false #(14)\n      - PRIVOXY_ENABLED=false #(19)\n      - UNBOUND_ENABLED=false #(21)\n      - UNBOUND_NAMESERVERS #(22)\n    cap_add:\n      - NET_ADMIN\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1 #(12)\n      - net.ipv6.conf.all.disable_ipv6=1 #(3)\n    devices:\n      - /dev/net/tun:/dev/net/tun # OPTIONAL(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui. On MacOS set it to <code>192.168.65.0/24</code> (Verify with your settings [Resources &gt; Network &gt; Docker subnet]).</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>. Affiliate links: Proton VPN Proton Unlimited Private Internet Access</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> (for PIA this is done automatically, see <code>VPN_PROVIDER</code> variable) located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32 in most cases\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>DANGEROUS! Don't enable unless you know what you are doing!</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>Some of the possible values are for example <code>wg</code>, <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>wg</code> will use the nameservers from the <code>wg0.conf</code> file. A value in the format <code>8.8.8.8</code> is to use a plain old nameserver. A value in the format <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>If you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice.</p> </li> <li> <p>This will start Privoxy on the default port 8118 when set to <code>true</code>. By default Privoxy is not exposed on the LAN, so if you need that, you'll have to add <code>VPN_EXPOSE_PORTS_ON_LAN=8118/tcp,8118/udp</code>.</p> </li> <li> <p>Enabling this will bring down the container if the connectivity tests fail at the end of the Wireguard init process or for an extended period during the container runtime.</p> </li> <li> <p>Enable Unbound by setting to <code>true</code> when VPN is not active.</p> </li> <li> <p>Possible values are <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>8.8.8.8</code> is to use a plain old nameserver. The value <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> </ol>"},{"location":"containers/readarr/","title":"Readarr","text":"<p> GitHub ghcr.io</p>"},{"location":"containers/readarr/#starting-the-container","title":"Starting the container","text":"clicompose <pre><code>docker run --rm \\\n    --name readarr \\\n    -p 8787:8787 \\\n    -e PUID=1000 \\\n    -e PGID=1000 \\\n    -e UMASK=002 \\\n    -e TZ=\"Etc/UTC\" \\\n    -v /&lt;host_folder_config&gt;:/config \\\n    -v /&lt;host_folder_data&gt;:/data \\\n    ghcr.io/hotio/readarr\n</code></pre> <pre><code>services:\n  readarr:\n    container_name: readarr\n    image: ghcr.io/hotio/readarr\n    ports:\n      - \"8787:8787\"\n    environment:\n      - PUID=1000\n      - PGID=1000\n      - UMASK=002\n      - TZ=Etc/UTC\n    volumes:\n      - /&lt;host_folder_config&gt;:/config\n      - /&lt;host_folder_data&gt;:/data\n</code></pre>"},{"location":"containers/readarr/#tags","title":"Tags","text":"Tags Description Last Updated Age"},{"location":"containers/readarr/#wireguard","title":"WireGuard","text":"<p>Info</p> <p>This image includes VPN support. The cli/compose examples below are environment variables and settings complementary to the app image examples, this means you'll have to add/merge the stuff below with the stuff above. In case you are still in need of a VPN, consider using my affiliate links for Proton VPN, Proton Unlimited or Private Internet Access.</p> <p> </p> genericprotonpia clicompose <pre><code>docker run --rm \\\n    --hostname container-name.internal \\ #(18)\n    -e VPN_ENABLED=\"true\" \\ #(5)\n    -e VPN_CONF=\"wg0\" \\ #(8)\n    -e VPN_PROVIDER=\"generic\" \\ #(4)\n    -e VPN_LAN_NETWORK=\"192.168.1.0/24\" \\ #(1)\n    -e VPN_LAN_LEAK_ENABLED=\"false\" \\ #(10)\n    -e VPN_EXPOSE_PORTS_ON_LAN=\"\" \\ #(2)\n    -e VPN_AUTO_PORT_FORWARD=\"false\" \\ #(6)\n    -e VPN_AUTO_PORT_FORWARD_TO_PORTS=\"\" \\ #(15)\n    -e VPN_FIREWALL_TYPE=\"auto\" \\ #(17)\n    -e VPN_HEALTHCHECK_ENABLED=\"false\" \\ #(20)\n    -e VPN_NAMESERVERS=\"\" \\ #(16)\n    -e PRIVOXY_ENABLED=\"false\" \\ #(19)\n    -e UNBOUND_ENABLED=\"false\" \\ #(21)\n    -e UNBOUND_NAMESERVERS=\"\" \\ #(22)\n    --cap-add=NET_ADMIN \\\n    --sysctl=\"net.ipv4.conf.all.src_valid_mark=1\" \\ #(12)\n    --sysctl=\"net.ipv6.conf.all.disable_ipv6=1\" \\ #(3)\n    --device /dev/net/tun:/dev/net/tun \\ # OPTIONAL(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui. On MacOS set it to <code>192.168.65.0/24</code> (Verify with your settings [Resources &gt; Network &gt; Docker subnet]).</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>. Affiliate links: Proton VPN Proton Unlimited Private Internet Access</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> (for PIA this is done automatically, see <code>VPN_PROVIDER</code> variable) located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32 in most cases\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>DANGEROUS! Don't enable unless you know what you are doing!</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>Some of the possible values are for example <code>wg</code>, <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>wg</code> will use the nameservers from the <code>wg0.conf</code> file. A value in the format <code>8.8.8.8</code> is to use a plain old nameserver. A value in the format <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>If you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice.</p> </li> <li> <p>This will start Privoxy on the default port 8118 when set to <code>true</code>. By default Privoxy is not exposed on the LAN, so if you need that, you'll have to add <code>VPN_EXPOSE_PORTS_ON_LAN=8118/tcp,8118/udp</code>.</p> </li> <li> <p>Enabling this will bring down the container if the connectivity tests fail at the end of the Wireguard init process or for an extended period during the container runtime.</p> </li> <li> <p>Enable Unbound by setting to <code>true</code> when VPN is not active.</p> </li> <li> <p>Possible values are <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>8.8.8.8</code> is to use a plain old nameserver. The value <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> </ol> <pre><code>services:\n  app:\n    hostname: container-name.internal #(18)\n    environment:\n      - VPN_ENABLED=true #(5)\n      - VPN_CONF=wg0 #(8)\n      - VPN_PROVIDER=generic #(4)\n      - VPN_LAN_NETWORK=192.168.1.0/24 #(1)\n      - VPN_LAN_LEAK_ENABLED=false #(10)\n      - VPN_EXPOSE_PORTS_ON_LAN #(2)\n      - VPN_AUTO_PORT_FORWARD=false #(6)\n      - VPN_AUTO_PORT_FORWARD_TO_PORTS= #(15)\n      - VPN_FIREWALL_TYPE=auto #(17)\n      - VPN_HEALTHCHECK_ENABLED=false #(20)\n      - VPN_NAMESERVERS= #(16)\n      - PRIVOXY_ENABLED=false #(19)\n      - UNBOUND_ENABLED=false #(21)\n      - UNBOUND_NAMESERVERS #(22)\n    cap_add:\n      - NET_ADMIN\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1 #(12)\n      - net.ipv6.conf.all.disable_ipv6=1 #(3)\n    devices:\n      - /dev/net/tun:/dev/net/tun # OPTIONAL(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui. On MacOS set it to <code>192.168.65.0/24</code> (Verify with your settings [Resources &gt; Network &gt; Docker subnet]).</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>. Affiliate links: Proton VPN Proton Unlimited Private Internet Access</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> (for PIA this is done automatically, see <code>VPN_PROVIDER</code> variable) located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32 in most cases\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>DANGEROUS! Don't enable unless you know what you are doing!</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>Some of the possible values are for example <code>wg</code>, <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>wg</code> will use the nameservers from the <code>wg0.conf</code> file. A value in the format <code>8.8.8.8</code> is to use a plain old nameserver. A value in the format <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>If you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice.</p> </li> <li> <p>This will start Privoxy on the default port 8118 when set to <code>true</code>. By default Privoxy is not exposed on the LAN, so if you need that, you'll have to add <code>VPN_EXPOSE_PORTS_ON_LAN=8118/tcp,8118/udp</code>.</p> </li> <li> <p>Enabling this will bring down the container if the connectivity tests fail at the end of the Wireguard init process or for an extended period during the container runtime.</p> </li> <li> <p>Enable Unbound by setting to <code>true</code> when VPN is not active.</p> </li> <li> <p>Possible values are <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>8.8.8.8</code> is to use a plain old nameserver. The value <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> </ol> clicompose <pre><code>docker run --rm \\\n    --hostname container-name.internal \\ #(18)\n    -e VPN_ENABLED=\"true\" \\ #(5)\n    -e VPN_CONF=\"wg0\" \\ #(8)\n    -e VPN_PROVIDER=\"proton\" \\ #(4)\n    -e VPN_LAN_NETWORK=\"192.168.1.0/24\" \\ #(1)\n    -e VPN_LAN_LEAK_ENABLED=\"false\" \\ #(10)\n    -e VPN_EXPOSE_PORTS_ON_LAN=\"\" \\ #(2)\n    -e VPN_AUTO_PORT_FORWARD=\"true\" \\ #(6)\n    -e VPN_AUTO_PORT_FORWARD_TO_PORTS=\"\" \\ #(15)\n    -e VPN_FIREWALL_TYPE=\"auto\" \\ #(17)\n    -e VPN_HEALTHCHECK_ENABLED=\"false\" \\ #(20)\n    -e VPN_NAMESERVERS=\"\" \\ #(16)\n    -e PRIVOXY_ENABLED=\"false\" \\ #(19)\n    -e UNBOUND_ENABLED=\"false\" \\ #(21)\n    -e UNBOUND_NAMESERVERS=\"\" \\ #(22)\n    --cap-add=NET_ADMIN \\\n    --sysctl=\"net.ipv4.conf.all.src_valid_mark=1\" \\ #(12)\n    --sysctl=\"net.ipv6.conf.all.disable_ipv6=1\" \\ #(3)\n    --device /dev/net/tun:/dev/net/tun \\ # OPTIONAL(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui. On MacOS set it to <code>192.168.65.0/24</code> (Verify with your settings [Resources &gt; Network &gt; Docker subnet]).</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>. Affiliate links: Proton VPN Proton Unlimited Private Internet Access</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> (for PIA this is done automatically, see <code>VPN_PROVIDER</code> variable) located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32 in most cases\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>DANGEROUS! Don't enable unless you know what you are doing!</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>Some of the possible values are for example <code>wg</code>, <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>wg</code> will use the nameservers from the <code>wg0.conf</code> file. A value in the format <code>8.8.8.8</code> is to use a plain old nameserver. A value in the format <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>If you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice.</p> </li> <li> <p>This will start Privoxy on the default port 8118 when set to <code>true</code>. By default Privoxy is not exposed on the LAN, so if you need that, you'll have to add <code>VPN_EXPOSE_PORTS_ON_LAN=8118/tcp,8118/udp</code>.</p> </li> <li> <p>Enabling this will bring down the container if the connectivity tests fail at the end of the Wireguard init process or for an extended period during the container runtime.</p> </li> <li> <p>Enable Unbound by setting to <code>true</code> when VPN is not active.</p> </li> <li> <p>Possible values are <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>8.8.8.8</code> is to use a plain old nameserver. The value <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> </ol> <pre><code>services:\n  app:\n    hostname: container-name.internal #(18)\n    environment:\n      - VPN_ENABLED=true #(5)\n      - VPN_CONF=wg0 #(8)\n      - VPN_PROVIDER=proton #(4)\n      - VPN_LAN_NETWORK=192.168.1.0/24 #(1)\n      - VPN_LAN_LEAK_ENABLED=false #(10)\n      - VPN_EXPOSE_PORTS_ON_LAN #(2)\n      - VPN_AUTO_PORT_FORWARD=true #(6)\n      - VPN_AUTO_PORT_FORWARD_TO_PORTS= #(15)\n      - VPN_FIREWALL_TYPE=auto #(17)\n      - VPN_HEALTHCHECK_ENABLED=false #(20)\n      - VPN_NAMESERVERS= #(16)\n      - PRIVOXY_ENABLED=false #(19)\n      - UNBOUND_ENABLED=false #(21)\n      - UNBOUND_NAMESERVERS #(22)\n    cap_add:\n      - NET_ADMIN\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1 #(12)\n      - net.ipv6.conf.all.disable_ipv6=1 #(3)\n    devices:\n      - /dev/net/tun:/dev/net/tun # OPTIONAL(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui. On MacOS set it to <code>192.168.65.0/24</code> (Verify with your settings [Resources &gt; Network &gt; Docker subnet]).</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>. Affiliate links: Proton VPN Proton Unlimited Private Internet Access</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> (for PIA this is done automatically, see <code>VPN_PROVIDER</code> variable) located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32 in most cases\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>DANGEROUS! Don't enable unless you know what you are doing!</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>Some of the possible values are for example <code>wg</code>, <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>wg</code> will use the nameservers from the <code>wg0.conf</code> file. A value in the format <code>8.8.8.8</code> is to use a plain old nameserver. A value in the format <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>If you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice.</p> </li> <li> <p>This will start Privoxy on the default port 8118 when set to <code>true</code>. By default Privoxy is not exposed on the LAN, so if you need that, you'll have to add <code>VPN_EXPOSE_PORTS_ON_LAN=8118/tcp,8118/udp</code>.</p> </li> <li> <p>Enabling this will bring down the container if the connectivity tests fail at the end of the Wireguard init process or for an extended period during the container runtime.</p> </li> <li> <p>Enable Unbound by setting to <code>true</code> when VPN is not active.</p> </li> <li> <p>Possible values are <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>8.8.8.8</code> is to use a plain old nameserver. The value <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> </ol> clicompose <pre><code>docker run --rm \\\n    --hostname container-name.internal \\ #(18)\n    -e VPN_ENABLED=\"true\" \\ #(5)\n    -e VPN_CONF=\"wg0\" \\ #(8)\n    -e VPN_PROVIDER=\"pia\" \\ #(4)\n    -e VPN_LAN_NETWORK=\"192.168.1.0/24\" \\ #(1)\n    -e VPN_LAN_LEAK_ENABLED=\"false\" \\ #(10)\n    -e VPN_EXPOSE_PORTS_ON_LAN=\"\" \\ #(2)\n    -e VPN_AUTO_PORT_FORWARD=\"true\" \\ #(6)\n    -e VPN_AUTO_PORT_FORWARD_TO_PORTS=\"\" \\ #(15)\n    -e VPN_FIREWALL_TYPE=\"auto\" \\ #(17)\n    -e VPN_HEALTHCHECK_ENABLED=\"false\" \\ #(20)\n    -e VPN_NAMESERVERS=\"\" \\ #(16)\n    -e VPN_PIA_USER=\"\" \\ #(11)\n    -e VPN_PIA_PASS=\"\" \\ #(11)\n    -e VPN_PIA_PREFERRED_REGION=\"\" \\ #(7)\n    -e VPN_PIA_DIP_TOKEN=\"no\" \\ #(13)\n    -e VPN_PIA_PORT_FORWARD_PERSIST=\"false\" \\ #(14)\n    -e PRIVOXY_ENABLED=\"false\" \\ #(19)\n    -e UNBOUND_ENABLED=\"false\" \\ #(21)\n    -e UNBOUND_NAMESERVERS=\"\" \\ #(22)\n    --cap-add=NET_ADMIN \\\n    --sysctl=\"net.ipv4.conf.all.src_valid_mark=1\" \\ #(12)\n    --sysctl=\"net.ipv6.conf.all.disable_ipv6=1\" \\ #(3)\n    --device /dev/net/tun:/dev/net/tun \\ # OPTIONAL(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui. On MacOS set it to <code>192.168.65.0/24</code> (Verify with your settings [Resources &gt; Network &gt; Docker subnet]).</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>. Affiliate links: Proton VPN Proton Unlimited Private Internet Access</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> (for PIA this is done automatically, see <code>VPN_PROVIDER</code> variable) located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32 in most cases\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>DANGEROUS! Don't enable unless you know what you are doing!</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>Some of the possible values are for example <code>wg</code>, <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>wg</code> will use the nameservers from the <code>wg0.conf</code> file. A value in the format <code>8.8.8.8</code> is to use a plain old nameserver. A value in the format <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>If you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice.</p> </li> <li> <p>This will start Privoxy on the default port 8118 when set to <code>true</code>. By default Privoxy is not exposed on the LAN, so if you need that, you'll have to add <code>VPN_EXPOSE_PORTS_ON_LAN=8118/tcp,8118/udp</code>.</p> </li> <li> <p>Enabling this will bring down the container if the connectivity tests fail at the end of the Wireguard init process or for an extended period during the container runtime.</p> </li> <li> <p>Enable Unbound by setting to <code>true</code> when VPN is not active.</p> </li> <li> <p>Possible values are <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>8.8.8.8</code> is to use a plain old nameserver. The value <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> </ol> <pre><code>services:\n  app:\n    hostname: container-name.internal #(18)\n    environment:\n      - VPN_ENABLED=true #(5)\n      - VPN_CONF=wg0 #(8)\n      - VPN_PROVIDER=pia #(4)\n      - VPN_LAN_NETWORK=192.168.1.0/24 #(1)\n      - VPN_LAN_LEAK_ENABLED=false #(10)\n      - VPN_EXPOSE_PORTS_ON_LAN #(2)\n      - VPN_AUTO_PORT_FORWARD=true #(6)\n      - VPN_AUTO_PORT_FORWARD_TO_PORTS= #(15)\n      - VPN_FIREWALL_TYPE=auto #(17)\n      - VPN_HEALTHCHECK_ENABLED=false #(20)\n      - VPN_NAMESERVERS= #(16)\n      - VPN_PIA_USER #(11)\n      - VPN_PIA_PASS #(11)\n      - VPN_PIA_PREFERRED_REGION #(7)\n      - VPN_PIA_DIP_TOKEN=no #(13)\n      - VPN_PIA_PORT_FORWARD_PERSIST=false #(14)\n      - PRIVOXY_ENABLED=false #(19)\n      - UNBOUND_ENABLED=false #(21)\n      - UNBOUND_NAMESERVERS #(22)\n    cap_add:\n      - NET_ADMIN\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1 #(12)\n      - net.ipv6.conf.all.disable_ipv6=1 #(3)\n    devices:\n      - /dev/net/tun:/dev/net/tun # OPTIONAL(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui. On MacOS set it to <code>192.168.65.0/24</code> (Verify with your settings [Resources &gt; Network &gt; Docker subnet]).</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>. Affiliate links: Proton VPN Proton Unlimited Private Internet Access</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> (for PIA this is done automatically, see <code>VPN_PROVIDER</code> variable) located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32 in most cases\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>DANGEROUS! Don't enable unless you know what you are doing!</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>Some of the possible values are for example <code>wg</code>, <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>wg</code> will use the nameservers from the <code>wg0.conf</code> file. A value in the format <code>8.8.8.8</code> is to use a plain old nameserver. A value in the format <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>If you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice.</p> </li> <li> <p>This will start Privoxy on the default port 8118 when set to <code>true</code>. By default Privoxy is not exposed on the LAN, so if you need that, you'll have to add <code>VPN_EXPOSE_PORTS_ON_LAN=8118/tcp,8118/udp</code>.</p> </li> <li> <p>Enabling this will bring down the container if the connectivity tests fail at the end of the Wireguard init process or for an extended period during the container runtime.</p> </li> <li> <p>Enable Unbound by setting to <code>true</code> when VPN is not active.</p> </li> <li> <p>Possible values are <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>8.8.8.8</code> is to use a plain old nameserver. The value <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> </ol>"},{"location":"containers/requestrr/","title":"hotio/requestrr","text":"<p> GitHub ghcr.io</p>"},{"location":"containers/requestrr/#starting-the-container","title":"Starting the container","text":"clicompose <pre><code>docker run --rm \\\n    --name requestrr \\\n    -p 4545:4545 \\\n    -e PUID=1000 \\\n    -e PGID=1000 \\\n    -e UMASK=002 \\\n    -e TZ=\"Etc/UTC\" \\\n    -v /&lt;host_folder_config&gt;:/config \\\n    ghcr.io/hotio/requestrr\n</code></pre> <pre><code>services:\n  requestrr:\n    container_name: requestrr\n    image: ghcr.io/hotio/requestrr\n    ports:\n      - \"4545:4545\"\n    environment:\n      - PUID=1000\n      - PGID=1000\n      - UMASK=002\n      - TZ=Etc/UTC\n    volumes:\n      - /&lt;host_folder_config&gt;:/config\n</code></pre>"},{"location":"containers/requestrr/#tags","title":"Tags","text":"Tags Description Last Updated Age"},{"location":"containers/requestrr/#wireguard","title":"WireGuard","text":"<p>Info</p> <p>This image includes VPN support. The cli/compose examples below are environment variables and settings complementary to the app image examples, this means you'll have to add/merge the stuff below with the stuff above. In case you are still in need of a VPN, consider using my affiliate links for Proton VPN, Proton Unlimited or Private Internet Access.</p> <p> </p> genericprotonpia clicompose <pre><code>docker run --rm \\\n    --hostname container-name.internal \\ #(18)\n    -e VPN_ENABLED=\"true\" \\ #(5)\n    -e VPN_CONF=\"wg0\" \\ #(8)\n    -e VPN_PROVIDER=\"generic\" \\ #(4)\n    -e VPN_LAN_NETWORK=\"192.168.1.0/24\" \\ #(1)\n    -e VPN_LAN_LEAK_ENABLED=\"false\" \\ #(10)\n    -e VPN_EXPOSE_PORTS_ON_LAN=\"\" \\ #(2)\n    -e VPN_AUTO_PORT_FORWARD=\"false\" \\ #(6)\n    -e VPN_AUTO_PORT_FORWARD_TO_PORTS=\"\" \\ #(15)\n    -e VPN_FIREWALL_TYPE=\"auto\" \\ #(17)\n    -e VPN_HEALTHCHECK_ENABLED=\"false\" \\ #(20)\n    -e VPN_NAMESERVERS=\"\" \\ #(16)\n    -e PRIVOXY_ENABLED=\"false\" \\ #(19)\n    -e UNBOUND_ENABLED=\"false\" \\ #(21)\n    -e UNBOUND_NAMESERVERS=\"\" \\ #(22)\n    --cap-add=NET_ADMIN \\\n    --sysctl=\"net.ipv4.conf.all.src_valid_mark=1\" \\ #(12)\n    --sysctl=\"net.ipv6.conf.all.disable_ipv6=1\" \\ #(3)\n    --device /dev/net/tun:/dev/net/tun \\ # OPTIONAL(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui. On MacOS set it to <code>192.168.65.0/24</code> (Verify with your settings [Resources &gt; Network &gt; Docker subnet]).</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>. Affiliate links: Proton VPN Proton Unlimited Private Internet Access</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> (for PIA this is done automatically, see <code>VPN_PROVIDER</code> variable) located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32 in most cases\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>DANGEROUS! Don't enable unless you know what you are doing!</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>Some of the possible values are for example <code>wg</code>, <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>wg</code> will use the nameservers from the <code>wg0.conf</code> file. A value in the format <code>8.8.8.8</code> is to use a plain old nameserver. A value in the format <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>If you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice.</p> </li> <li> <p>This will start Privoxy on the default port 8118 when set to <code>true</code>. By default Privoxy is not exposed on the LAN, so if you need that, you'll have to add <code>VPN_EXPOSE_PORTS_ON_LAN=8118/tcp,8118/udp</code>.</p> </li> <li> <p>Enabling this will bring down the container if the connectivity tests fail at the end of the Wireguard init process or for an extended period during the container runtime.</p> </li> <li> <p>Enable Unbound by setting to <code>true</code> when VPN is not active.</p> </li> <li> <p>Possible values are <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>8.8.8.8</code> is to use a plain old nameserver. The value <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> </ol> <pre><code>services:\n  app:\n    hostname: container-name.internal #(18)\n    environment:\n      - VPN_ENABLED=true #(5)\n      - VPN_CONF=wg0 #(8)\n      - VPN_PROVIDER=generic #(4)\n      - VPN_LAN_NETWORK=192.168.1.0/24 #(1)\n      - VPN_LAN_LEAK_ENABLED=false #(10)\n      - VPN_EXPOSE_PORTS_ON_LAN #(2)\n      - VPN_AUTO_PORT_FORWARD=false #(6)\n      - VPN_AUTO_PORT_FORWARD_TO_PORTS= #(15)\n      - VPN_FIREWALL_TYPE=auto #(17)\n      - VPN_HEALTHCHECK_ENABLED=false #(20)\n      - VPN_NAMESERVERS= #(16)\n      - PRIVOXY_ENABLED=false #(19)\n      - UNBOUND_ENABLED=false #(21)\n      - UNBOUND_NAMESERVERS #(22)\n    cap_add:\n      - NET_ADMIN\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1 #(12)\n      - net.ipv6.conf.all.disable_ipv6=1 #(3)\n    devices:\n      - /dev/net/tun:/dev/net/tun # OPTIONAL(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui. On MacOS set it to <code>192.168.65.0/24</code> (Verify with your settings [Resources &gt; Network &gt; Docker subnet]).</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>. Affiliate links: Proton VPN Proton Unlimited Private Internet Access</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> (for PIA this is done automatically, see <code>VPN_PROVIDER</code> variable) located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32 in most cases\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>DANGEROUS! Don't enable unless you know what you are doing!</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>Some of the possible values are for example <code>wg</code>, <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>wg</code> will use the nameservers from the <code>wg0.conf</code> file. A value in the format <code>8.8.8.8</code> is to use a plain old nameserver. A value in the format <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>If you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice.</p> </li> <li> <p>This will start Privoxy on the default port 8118 when set to <code>true</code>. By default Privoxy is not exposed on the LAN, so if you need that, you'll have to add <code>VPN_EXPOSE_PORTS_ON_LAN=8118/tcp,8118/udp</code>.</p> </li> <li> <p>Enabling this will bring down the container if the connectivity tests fail at the end of the Wireguard init process or for an extended period during the container runtime.</p> </li> <li> <p>Enable Unbound by setting to <code>true</code> when VPN is not active.</p> </li> <li> <p>Possible values are <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>8.8.8.8</code> is to use a plain old nameserver. The value <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> </ol> clicompose <pre><code>docker run --rm \\\n    --hostname container-name.internal \\ #(18)\n    -e VPN_ENABLED=\"true\" \\ #(5)\n    -e VPN_CONF=\"wg0\" \\ #(8)\n    -e VPN_PROVIDER=\"proton\" \\ #(4)\n    -e VPN_LAN_NETWORK=\"192.168.1.0/24\" \\ #(1)\n    -e VPN_LAN_LEAK_ENABLED=\"false\" \\ #(10)\n    -e VPN_EXPOSE_PORTS_ON_LAN=\"\" \\ #(2)\n    -e VPN_AUTO_PORT_FORWARD=\"true\" \\ #(6)\n    -e VPN_AUTO_PORT_FORWARD_TO_PORTS=\"\" \\ #(15)\n    -e VPN_FIREWALL_TYPE=\"auto\" \\ #(17)\n    -e VPN_HEALTHCHECK_ENABLED=\"false\" \\ #(20)\n    -e VPN_NAMESERVERS=\"\" \\ #(16)\n    -e PRIVOXY_ENABLED=\"false\" \\ #(19)\n    -e UNBOUND_ENABLED=\"false\" \\ #(21)\n    -e UNBOUND_NAMESERVERS=\"\" \\ #(22)\n    --cap-add=NET_ADMIN \\\n    --sysctl=\"net.ipv4.conf.all.src_valid_mark=1\" \\ #(12)\n    --sysctl=\"net.ipv6.conf.all.disable_ipv6=1\" \\ #(3)\n    --device /dev/net/tun:/dev/net/tun \\ # OPTIONAL(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui. On MacOS set it to <code>192.168.65.0/24</code> (Verify with your settings [Resources &gt; Network &gt; Docker subnet]).</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>. Affiliate links: Proton VPN Proton Unlimited Private Internet Access</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> (for PIA this is done automatically, see <code>VPN_PROVIDER</code> variable) located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32 in most cases\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>DANGEROUS! Don't enable unless you know what you are doing!</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>Some of the possible values are for example <code>wg</code>, <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>wg</code> will use the nameservers from the <code>wg0.conf</code> file. A value in the format <code>8.8.8.8</code> is to use a plain old nameserver. A value in the format <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>If you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice.</p> </li> <li> <p>This will start Privoxy on the default port 8118 when set to <code>true</code>. By default Privoxy is not exposed on the LAN, so if you need that, you'll have to add <code>VPN_EXPOSE_PORTS_ON_LAN=8118/tcp,8118/udp</code>.</p> </li> <li> <p>Enabling this will bring down the container if the connectivity tests fail at the end of the Wireguard init process or for an extended period during the container runtime.</p> </li> <li> <p>Enable Unbound by setting to <code>true</code> when VPN is not active.</p> </li> <li> <p>Possible values are <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>8.8.8.8</code> is to use a plain old nameserver. The value <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> </ol> <pre><code>services:\n  app:\n    hostname: container-name.internal #(18)\n    environment:\n      - VPN_ENABLED=true #(5)\n      - VPN_CONF=wg0 #(8)\n      - VPN_PROVIDER=proton #(4)\n      - VPN_LAN_NETWORK=192.168.1.0/24 #(1)\n      - VPN_LAN_LEAK_ENABLED=false #(10)\n      - VPN_EXPOSE_PORTS_ON_LAN #(2)\n      - VPN_AUTO_PORT_FORWARD=true #(6)\n      - VPN_AUTO_PORT_FORWARD_TO_PORTS= #(15)\n      - VPN_FIREWALL_TYPE=auto #(17)\n      - VPN_HEALTHCHECK_ENABLED=false #(20)\n      - VPN_NAMESERVERS= #(16)\n      - PRIVOXY_ENABLED=false #(19)\n      - UNBOUND_ENABLED=false #(21)\n      - UNBOUND_NAMESERVERS #(22)\n    cap_add:\n      - NET_ADMIN\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1 #(12)\n      - net.ipv6.conf.all.disable_ipv6=1 #(3)\n    devices:\n      - /dev/net/tun:/dev/net/tun # OPTIONAL(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui. On MacOS set it to <code>192.168.65.0/24</code> (Verify with your settings [Resources &gt; Network &gt; Docker subnet]).</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>. Affiliate links: Proton VPN Proton Unlimited Private Internet Access</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> (for PIA this is done automatically, see <code>VPN_PROVIDER</code> variable) located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32 in most cases\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>DANGEROUS! Don't enable unless you know what you are doing!</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>Some of the possible values are for example <code>wg</code>, <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>wg</code> will use the nameservers from the <code>wg0.conf</code> file. A value in the format <code>8.8.8.8</code> is to use a plain old nameserver. A value in the format <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>If you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice.</p> </li> <li> <p>This will start Privoxy on the default port 8118 when set to <code>true</code>. By default Privoxy is not exposed on the LAN, so if you need that, you'll have to add <code>VPN_EXPOSE_PORTS_ON_LAN=8118/tcp,8118/udp</code>.</p> </li> <li> <p>Enabling this will bring down the container if the connectivity tests fail at the end of the Wireguard init process or for an extended period during the container runtime.</p> </li> <li> <p>Enable Unbound by setting to <code>true</code> when VPN is not active.</p> </li> <li> <p>Possible values are <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>8.8.8.8</code> is to use a plain old nameserver. The value <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> </ol> clicompose <pre><code>docker run --rm \\\n    --hostname container-name.internal \\ #(18)\n    -e VPN_ENABLED=\"true\" \\ #(5)\n    -e VPN_CONF=\"wg0\" \\ #(8)\n    -e VPN_PROVIDER=\"pia\" \\ #(4)\n    -e VPN_LAN_NETWORK=\"192.168.1.0/24\" \\ #(1)\n    -e VPN_LAN_LEAK_ENABLED=\"false\" \\ #(10)\n    -e VPN_EXPOSE_PORTS_ON_LAN=\"\" \\ #(2)\n    -e VPN_AUTO_PORT_FORWARD=\"true\" \\ #(6)\n    -e VPN_AUTO_PORT_FORWARD_TO_PORTS=\"\" \\ #(15)\n    -e VPN_FIREWALL_TYPE=\"auto\" \\ #(17)\n    -e VPN_HEALTHCHECK_ENABLED=\"false\" \\ #(20)\n    -e VPN_NAMESERVERS=\"\" \\ #(16)\n    -e VPN_PIA_USER=\"\" \\ #(11)\n    -e VPN_PIA_PASS=\"\" \\ #(11)\n    -e VPN_PIA_PREFERRED_REGION=\"\" \\ #(7)\n    -e VPN_PIA_DIP_TOKEN=\"no\" \\ #(13)\n    -e VPN_PIA_PORT_FORWARD_PERSIST=\"false\" \\ #(14)\n    -e PRIVOXY_ENABLED=\"false\" \\ #(19)\n    -e UNBOUND_ENABLED=\"false\" \\ #(21)\n    -e UNBOUND_NAMESERVERS=\"\" \\ #(22)\n    --cap-add=NET_ADMIN \\\n    --sysctl=\"net.ipv4.conf.all.src_valid_mark=1\" \\ #(12)\n    --sysctl=\"net.ipv6.conf.all.disable_ipv6=1\" \\ #(3)\n    --device /dev/net/tun:/dev/net/tun \\ # OPTIONAL(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui. On MacOS set it to <code>192.168.65.0/24</code> (Verify with your settings [Resources &gt; Network &gt; Docker subnet]).</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>. Affiliate links: Proton VPN Proton Unlimited Private Internet Access</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> (for PIA this is done automatically, see <code>VPN_PROVIDER</code> variable) located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32 in most cases\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>DANGEROUS! Don't enable unless you know what you are doing!</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>Some of the possible values are for example <code>wg</code>, <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>wg</code> will use the nameservers from the <code>wg0.conf</code> file. A value in the format <code>8.8.8.8</code> is to use a plain old nameserver. A value in the format <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>If you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice.</p> </li> <li> <p>This will start Privoxy on the default port 8118 when set to <code>true</code>. By default Privoxy is not exposed on the LAN, so if you need that, you'll have to add <code>VPN_EXPOSE_PORTS_ON_LAN=8118/tcp,8118/udp</code>.</p> </li> <li> <p>Enabling this will bring down the container if the connectivity tests fail at the end of the Wireguard init process or for an extended period during the container runtime.</p> </li> <li> <p>Enable Unbound by setting to <code>true</code> when VPN is not active.</p> </li> <li> <p>Possible values are <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>8.8.8.8</code> is to use a plain old nameserver. The value <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> </ol> <pre><code>services:\n  app:\n    hostname: container-name.internal #(18)\n    environment:\n      - VPN_ENABLED=true #(5)\n      - VPN_CONF=wg0 #(8)\n      - VPN_PROVIDER=pia #(4)\n      - VPN_LAN_NETWORK=192.168.1.0/24 #(1)\n      - VPN_LAN_LEAK_ENABLED=false #(10)\n      - VPN_EXPOSE_PORTS_ON_LAN #(2)\n      - VPN_AUTO_PORT_FORWARD=true #(6)\n      - VPN_AUTO_PORT_FORWARD_TO_PORTS= #(15)\n      - VPN_FIREWALL_TYPE=auto #(17)\n      - VPN_HEALTHCHECK_ENABLED=false #(20)\n      - VPN_NAMESERVERS= #(16)\n      - VPN_PIA_USER #(11)\n      - VPN_PIA_PASS #(11)\n      - VPN_PIA_PREFERRED_REGION #(7)\n      - VPN_PIA_DIP_TOKEN=no #(13)\n      - VPN_PIA_PORT_FORWARD_PERSIST=false #(14)\n      - PRIVOXY_ENABLED=false #(19)\n      - UNBOUND_ENABLED=false #(21)\n      - UNBOUND_NAMESERVERS #(22)\n    cap_add:\n      - NET_ADMIN\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1 #(12)\n      - net.ipv6.conf.all.disable_ipv6=1 #(3)\n    devices:\n      - /dev/net/tun:/dev/net/tun # OPTIONAL(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui. On MacOS set it to <code>192.168.65.0/24</code> (Verify with your settings [Resources &gt; Network &gt; Docker subnet]).</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>. Affiliate links: Proton VPN Proton Unlimited Private Internet Access</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> (for PIA this is done automatically, see <code>VPN_PROVIDER</code> variable) located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32 in most cases\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>DANGEROUS! Don't enable unless you know what you are doing!</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>Some of the possible values are for example <code>wg</code>, <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>wg</code> will use the nameservers from the <code>wg0.conf</code> file. A value in the format <code>8.8.8.8</code> is to use a plain old nameserver. A value in the format <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>If you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice.</p> </li> <li> <p>This will start Privoxy on the default port 8118 when set to <code>true</code>. By default Privoxy is not exposed on the LAN, so if you need that, you'll have to add <code>VPN_EXPOSE_PORTS_ON_LAN=8118/tcp,8118/udp</code>.</p> </li> <li> <p>Enabling this will bring down the container if the connectivity tests fail at the end of the Wireguard init process or for an extended period during the container runtime.</p> </li> <li> <p>Enable Unbound by setting to <code>true</code> when VPN is not active.</p> </li> <li> <p>Possible values are <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>8.8.8.8</code> is to use a plain old nameserver. The value <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> </ol>"},{"location":"containers/rflood/","title":"hotio/rflood","text":"<p> GitHub ghcr.io</p> <p>What is this?</p> <p>A docker image with rTorrent and the Flood UI, also optional WireGuard VPN support.</p>"},{"location":"containers/rflood/#starting-the-container","title":"Starting the container","text":"clicompose <pre><code>docker run --rm \\\n    --name rflood \\\n    -p 3000:3000 \\\n    -p 5000:5000 \\\n    -e PUID=1000 \\\n    -e PGID=1000 \\\n    -e UMASK=002 \\\n    -e TZ=\"Etc/UTC\" \\\n    -e FLOOD_AUTH=\"false\" \\\n    -e ARGS=\"\" \\\n    -e FLOOD_ARGS=\"\" \\\n    -v /&lt;host_folder_config&gt;:/config \\\n    -v /&lt;host_folder_data&gt;:/data \\\n    ghcr.io/hotio/rflood\n</code></pre> <pre><code>services:\n  rflood:\n    container_name: rflood\n    image: ghcr.io/hotio/rflood\n    ports:\n      - \"3000:3000\"\n      - \"5000:5000\"\n    environment:\n      - PUID=1000\n      - PGID=1000\n      - UMASK=002\n      - TZ=Etc/UTC\n      - FLOOD_AUTH=false\n      - ARGS\n      - FLOOD_ARGS\n    volumes:\n      - /&lt;host_folder_config&gt;:/config\n      - /&lt;host_folder_data&gt;:/data\n</code></pre>"},{"location":"containers/rflood/#tags","title":"Tags","text":"Tags Description Last Updated Age"},{"location":"containers/rflood/#changing-the-webui-port","title":"Changing the WebUI port","text":"<p>Under certain circumstances it's required to run the WebUI on a different internal port, you can do that by modifying the environment variable <code>WEBUI_PORTS</code> accordingly. It should be in the format <code>xxxx/tcp,xxxx/udp</code>, take a look at the default with <code>docker logs</code> (variable is printed at container start) or <code>docker inspect</code>.</p>"},{"location":"containers/rflood/#xml-rpc-json-rpc","title":"XML-RPC / JSON-RPC","text":"<p>On port <code>5000</code> runs Nginx exposing the <code>/RPC2</code>, <code>/JSONRPC</code> and <code>/RPC</code> endpoints. Default credentials are shown on first start in the log output, <code>localhost</code> doesn't need credentials (xmlrpc tool is included). To reset the password, remove or modify <code>/config/rpc2/basic_auth_credentials</code>.</p> <pre><code>/RPC2    &gt;&gt; header 'Content-Type' forced to 'text/xml'\n/JSONRPC &gt;&gt; header 'Content-Type' forced to 'application/json-rpc'\n/RPC     &gt;&gt; header 'Content-Type' not modified\n</code></pre>"},{"location":"containers/rflood/#wireguard","title":"WireGuard","text":"<p>Info</p> <p>This image includes VPN support. The cli/compose examples below are environment variables and settings complementary to the app image examples, this means you'll have to add/merge the stuff below with the stuff above. In case you are still in need of a VPN, consider using my affiliate links for Proton VPN, Proton Unlimited or Private Internet Access.</p> <p> </p> genericprotonpia clicompose <pre><code>docker run --rm \\\n    --hostname container-name.internal \\ #(18)\n    -e VPN_ENABLED=\"true\" \\ #(5)\n    -e VPN_CONF=\"wg0\" \\ #(8)\n    -e VPN_PROVIDER=\"generic\" \\ #(4)\n    -e VPN_LAN_NETWORK=\"192.168.1.0/24\" \\ #(1)\n    -e VPN_LAN_LEAK_ENABLED=\"false\" \\ #(10)\n    -e VPN_EXPOSE_PORTS_ON_LAN=\"\" \\ #(2)\n    -e VPN_AUTO_PORT_FORWARD=\"false\" \\ #(6)\n    -e VPN_AUTO_PORT_FORWARD_TO_PORTS=\"\" \\ #(15)\n    -e VPN_FIREWALL_TYPE=\"auto\" \\ #(17)\n    -e VPN_HEALTHCHECK_ENABLED=\"false\" \\ #(20)\n    -e VPN_NAMESERVERS=\"\" \\ #(16)\n    -e PRIVOXY_ENABLED=\"false\" \\ #(19)\n    -e UNBOUND_ENABLED=\"false\" \\ #(21)\n    -e UNBOUND_NAMESERVERS=\"\" \\ #(22)\n    --cap-add=NET_ADMIN \\\n    --sysctl=\"net.ipv4.conf.all.src_valid_mark=1\" \\ #(12)\n    --sysctl=\"net.ipv6.conf.all.disable_ipv6=1\" \\ #(3)\n    --device /dev/net/tun:/dev/net/tun \\ # OPTIONAL(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui. On MacOS set it to <code>192.168.65.0/24</code> (Verify with your settings [Resources &gt; Network &gt; Docker subnet]).</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>. Affiliate links: Proton VPN Proton Unlimited Private Internet Access</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> (for PIA this is done automatically, see <code>VPN_PROVIDER</code> variable) located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32 in most cases\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>DANGEROUS! Don't enable unless you know what you are doing!</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>Some of the possible values are for example <code>wg</code>, <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>wg</code> will use the nameservers from the <code>wg0.conf</code> file. A value in the format <code>8.8.8.8</code> is to use a plain old nameserver. A value in the format <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>If you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice.</p> </li> <li> <p>This will start Privoxy on the default port 8118 when set to <code>true</code>. By default Privoxy is not exposed on the LAN, so if you need that, you'll have to add <code>VPN_EXPOSE_PORTS_ON_LAN=8118/tcp,8118/udp</code>.</p> </li> <li> <p>Enabling this will bring down the container if the connectivity tests fail at the end of the Wireguard init process or for an extended period during the container runtime.</p> </li> <li> <p>Enable Unbound by setting to <code>true</code> when VPN is not active.</p> </li> <li> <p>Possible values are <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>8.8.8.8</code> is to use a plain old nameserver. The value <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> </ol> <pre><code>services:\n  app:\n    hostname: container-name.internal #(18)\n    environment:\n      - VPN_ENABLED=true #(5)\n      - VPN_CONF=wg0 #(8)\n      - VPN_PROVIDER=generic #(4)\n      - VPN_LAN_NETWORK=192.168.1.0/24 #(1)\n      - VPN_LAN_LEAK_ENABLED=false #(10)\n      - VPN_EXPOSE_PORTS_ON_LAN #(2)\n      - VPN_AUTO_PORT_FORWARD=false #(6)\n      - VPN_AUTO_PORT_FORWARD_TO_PORTS= #(15)\n      - VPN_FIREWALL_TYPE=auto #(17)\n      - VPN_HEALTHCHECK_ENABLED=false #(20)\n      - VPN_NAMESERVERS= #(16)\n      - PRIVOXY_ENABLED=false #(19)\n      - UNBOUND_ENABLED=false #(21)\n      - UNBOUND_NAMESERVERS #(22)\n    cap_add:\n      - NET_ADMIN\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1 #(12)\n      - net.ipv6.conf.all.disable_ipv6=1 #(3)\n    devices:\n      - /dev/net/tun:/dev/net/tun # OPTIONAL(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui. On MacOS set it to <code>192.168.65.0/24</code> (Verify with your settings [Resources &gt; Network &gt; Docker subnet]).</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>. Affiliate links: Proton VPN Proton Unlimited Private Internet Access</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> (for PIA this is done automatically, see <code>VPN_PROVIDER</code> variable) located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32 in most cases\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>DANGEROUS! Don't enable unless you know what you are doing!</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>Some of the possible values are for example <code>wg</code>, <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>wg</code> will use the nameservers from the <code>wg0.conf</code> file. A value in the format <code>8.8.8.8</code> is to use a plain old nameserver. A value in the format <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>If you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice.</p> </li> <li> <p>This will start Privoxy on the default port 8118 when set to <code>true</code>. By default Privoxy is not exposed on the LAN, so if you need that, you'll have to add <code>VPN_EXPOSE_PORTS_ON_LAN=8118/tcp,8118/udp</code>.</p> </li> <li> <p>Enabling this will bring down the container if the connectivity tests fail at the end of the Wireguard init process or for an extended period during the container runtime.</p> </li> <li> <p>Enable Unbound by setting to <code>true</code> when VPN is not active.</p> </li> <li> <p>Possible values are <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>8.8.8.8</code> is to use a plain old nameserver. The value <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> </ol> clicompose <pre><code>docker run --rm \\\n    --hostname container-name.internal \\ #(18)\n    -e VPN_ENABLED=\"true\" \\ #(5)\n    -e VPN_CONF=\"wg0\" \\ #(8)\n    -e VPN_PROVIDER=\"proton\" \\ #(4)\n    -e VPN_LAN_NETWORK=\"192.168.1.0/24\" \\ #(1)\n    -e VPN_LAN_LEAK_ENABLED=\"false\" \\ #(10)\n    -e VPN_EXPOSE_PORTS_ON_LAN=\"\" \\ #(2)\n    -e VPN_AUTO_PORT_FORWARD=\"true\" \\ #(6)\n    -e VPN_AUTO_PORT_FORWARD_TO_PORTS=\"\" \\ #(15)\n    -e VPN_FIREWALL_TYPE=\"auto\" \\ #(17)\n    -e VPN_HEALTHCHECK_ENABLED=\"false\" \\ #(20)\n    -e VPN_NAMESERVERS=\"\" \\ #(16)\n    -e PRIVOXY_ENABLED=\"false\" \\ #(19)\n    -e UNBOUND_ENABLED=\"false\" \\ #(21)\n    -e UNBOUND_NAMESERVERS=\"\" \\ #(22)\n    --cap-add=NET_ADMIN \\\n    --sysctl=\"net.ipv4.conf.all.src_valid_mark=1\" \\ #(12)\n    --sysctl=\"net.ipv6.conf.all.disable_ipv6=1\" \\ #(3)\n    --device /dev/net/tun:/dev/net/tun \\ # OPTIONAL(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui. On MacOS set it to <code>192.168.65.0/24</code> (Verify with your settings [Resources &gt; Network &gt; Docker subnet]).</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>. Affiliate links: Proton VPN Proton Unlimited Private Internet Access</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> (for PIA this is done automatically, see <code>VPN_PROVIDER</code> variable) located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32 in most cases\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>DANGEROUS! Don't enable unless you know what you are doing!</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>Some of the possible values are for example <code>wg</code>, <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>wg</code> will use the nameservers from the <code>wg0.conf</code> file. A value in the format <code>8.8.8.8</code> is to use a plain old nameserver. A value in the format <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>If you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice.</p> </li> <li> <p>This will start Privoxy on the default port 8118 when set to <code>true</code>. By default Privoxy is not exposed on the LAN, so if you need that, you'll have to add <code>VPN_EXPOSE_PORTS_ON_LAN=8118/tcp,8118/udp</code>.</p> </li> <li> <p>Enabling this will bring down the container if the connectivity tests fail at the end of the Wireguard init process or for an extended period during the container runtime.</p> </li> <li> <p>Enable Unbound by setting to <code>true</code> when VPN is not active.</p> </li> <li> <p>Possible values are <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>8.8.8.8</code> is to use a plain old nameserver. The value <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> </ol> <pre><code>services:\n  app:\n    hostname: container-name.internal #(18)\n    environment:\n      - VPN_ENABLED=true #(5)\n      - VPN_CONF=wg0 #(8)\n      - VPN_PROVIDER=proton #(4)\n      - VPN_LAN_NETWORK=192.168.1.0/24 #(1)\n      - VPN_LAN_LEAK_ENABLED=false #(10)\n      - VPN_EXPOSE_PORTS_ON_LAN #(2)\n      - VPN_AUTO_PORT_FORWARD=true #(6)\n      - VPN_AUTO_PORT_FORWARD_TO_PORTS= #(15)\n      - VPN_FIREWALL_TYPE=auto #(17)\n      - VPN_HEALTHCHECK_ENABLED=false #(20)\n      - VPN_NAMESERVERS= #(16)\n      - PRIVOXY_ENABLED=false #(19)\n      - UNBOUND_ENABLED=false #(21)\n      - UNBOUND_NAMESERVERS #(22)\n    cap_add:\n      - NET_ADMIN\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1 #(12)\n      - net.ipv6.conf.all.disable_ipv6=1 #(3)\n    devices:\n      - /dev/net/tun:/dev/net/tun # OPTIONAL(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui. On MacOS set it to <code>192.168.65.0/24</code> (Verify with your settings [Resources &gt; Network &gt; Docker subnet]).</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>. Affiliate links: Proton VPN Proton Unlimited Private Internet Access</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> (for PIA this is done automatically, see <code>VPN_PROVIDER</code> variable) located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32 in most cases\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>DANGEROUS! Don't enable unless you know what you are doing!</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>Some of the possible values are for example <code>wg</code>, <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>wg</code> will use the nameservers from the <code>wg0.conf</code> file. A value in the format <code>8.8.8.8</code> is to use a plain old nameserver. A value in the format <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>If you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice.</p> </li> <li> <p>This will start Privoxy on the default port 8118 when set to <code>true</code>. By default Privoxy is not exposed on the LAN, so if you need that, you'll have to add <code>VPN_EXPOSE_PORTS_ON_LAN=8118/tcp,8118/udp</code>.</p> </li> <li> <p>Enabling this will bring down the container if the connectivity tests fail at the end of the Wireguard init process or for an extended period during the container runtime.</p> </li> <li> <p>Enable Unbound by setting to <code>true</code> when VPN is not active.</p> </li> <li> <p>Possible values are <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>8.8.8.8</code> is to use a plain old nameserver. The value <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> </ol> clicompose <pre><code>docker run --rm \\\n    --hostname container-name.internal \\ #(18)\n    -e VPN_ENABLED=\"true\" \\ #(5)\n    -e VPN_CONF=\"wg0\" \\ #(8)\n    -e VPN_PROVIDER=\"pia\" \\ #(4)\n    -e VPN_LAN_NETWORK=\"192.168.1.0/24\" \\ #(1)\n    -e VPN_LAN_LEAK_ENABLED=\"false\" \\ #(10)\n    -e VPN_EXPOSE_PORTS_ON_LAN=\"\" \\ #(2)\n    -e VPN_AUTO_PORT_FORWARD=\"true\" \\ #(6)\n    -e VPN_AUTO_PORT_FORWARD_TO_PORTS=\"\" \\ #(15)\n    -e VPN_FIREWALL_TYPE=\"auto\" \\ #(17)\n    -e VPN_HEALTHCHECK_ENABLED=\"false\" \\ #(20)\n    -e VPN_NAMESERVERS=\"\" \\ #(16)\n    -e VPN_PIA_USER=\"\" \\ #(11)\n    -e VPN_PIA_PASS=\"\" \\ #(11)\n    -e VPN_PIA_PREFERRED_REGION=\"\" \\ #(7)\n    -e VPN_PIA_DIP_TOKEN=\"no\" \\ #(13)\n    -e VPN_PIA_PORT_FORWARD_PERSIST=\"false\" \\ #(14)\n    -e PRIVOXY_ENABLED=\"false\" \\ #(19)\n    -e UNBOUND_ENABLED=\"false\" \\ #(21)\n    -e UNBOUND_NAMESERVERS=\"\" \\ #(22)\n    --cap-add=NET_ADMIN \\\n    --sysctl=\"net.ipv4.conf.all.src_valid_mark=1\" \\ #(12)\n    --sysctl=\"net.ipv6.conf.all.disable_ipv6=1\" \\ #(3)\n    --device /dev/net/tun:/dev/net/tun \\ # OPTIONAL(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui. On MacOS set it to <code>192.168.65.0/24</code> (Verify with your settings [Resources &gt; Network &gt; Docker subnet]).</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>. Affiliate links: Proton VPN Proton Unlimited Private Internet Access</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> (for PIA this is done automatically, see <code>VPN_PROVIDER</code> variable) located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32 in most cases\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>DANGEROUS! Don't enable unless you know what you are doing!</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>Some of the possible values are for example <code>wg</code>, <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>wg</code> will use the nameservers from the <code>wg0.conf</code> file. A value in the format <code>8.8.8.8</code> is to use a plain old nameserver. A value in the format <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>If you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice.</p> </li> <li> <p>This will start Privoxy on the default port 8118 when set to <code>true</code>. By default Privoxy is not exposed on the LAN, so if you need that, you'll have to add <code>VPN_EXPOSE_PORTS_ON_LAN=8118/tcp,8118/udp</code>.</p> </li> <li> <p>Enabling this will bring down the container if the connectivity tests fail at the end of the Wireguard init process or for an extended period during the container runtime.</p> </li> <li> <p>Enable Unbound by setting to <code>true</code> when VPN is not active.</p> </li> <li> <p>Possible values are <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>8.8.8.8</code> is to use a plain old nameserver. The value <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> </ol> <pre><code>services:\n  app:\n    hostname: container-name.internal #(18)\n    environment:\n      - VPN_ENABLED=true #(5)\n      - VPN_CONF=wg0 #(8)\n      - VPN_PROVIDER=pia #(4)\n      - VPN_LAN_NETWORK=192.168.1.0/24 #(1)\n      - VPN_LAN_LEAK_ENABLED=false #(10)\n      - VPN_EXPOSE_PORTS_ON_LAN #(2)\n      - VPN_AUTO_PORT_FORWARD=true #(6)\n      - VPN_AUTO_PORT_FORWARD_TO_PORTS= #(15)\n      - VPN_FIREWALL_TYPE=auto #(17)\n      - VPN_HEALTHCHECK_ENABLED=false #(20)\n      - VPN_NAMESERVERS= #(16)\n      - VPN_PIA_USER #(11)\n      - VPN_PIA_PASS #(11)\n      - VPN_PIA_PREFERRED_REGION #(7)\n      - VPN_PIA_DIP_TOKEN=no #(13)\n      - VPN_PIA_PORT_FORWARD_PERSIST=false #(14)\n      - PRIVOXY_ENABLED=false #(19)\n      - UNBOUND_ENABLED=false #(21)\n      - UNBOUND_NAMESERVERS #(22)\n    cap_add:\n      - NET_ADMIN\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1 #(12)\n      - net.ipv6.conf.all.disable_ipv6=1 #(3)\n    devices:\n      - /dev/net/tun:/dev/net/tun # OPTIONAL(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui. On MacOS set it to <code>192.168.65.0/24</code> (Verify with your settings [Resources &gt; Network &gt; Docker subnet]).</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>. Affiliate links: Proton VPN Proton Unlimited Private Internet Access</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> (for PIA this is done automatically, see <code>VPN_PROVIDER</code> variable) located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32 in most cases\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>DANGEROUS! Don't enable unless you know what you are doing!</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>Some of the possible values are for example <code>wg</code>, <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>wg</code> will use the nameservers from the <code>wg0.conf</code> file. A value in the format <code>8.8.8.8</code> is to use a plain old nameserver. A value in the format <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>If you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice.</p> </li> <li> <p>This will start Privoxy on the default port 8118 when set to <code>true</code>. By default Privoxy is not exposed on the LAN, so if you need that, you'll have to add <code>VPN_EXPOSE_PORTS_ON_LAN=8118/tcp,8118/udp</code>.</p> </li> <li> <p>Enabling this will bring down the container if the connectivity tests fail at the end of the Wireguard init process or for an extended period during the container runtime.</p> </li> <li> <p>Enable Unbound by setting to <code>true</code> when VPN is not active.</p> </li> <li> <p>Possible values are <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>8.8.8.8</code> is to use a plain old nameserver. The value <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> </ol>"},{"location":"containers/sabnzbd/","title":"hotio/sabnzbd","text":"<p> GitHub ghcr.io</p>"},{"location":"containers/sabnzbd/#starting-the-container","title":"Starting the container","text":"clicompose <pre><code>docker run --rm \\\n    --name sabnzbd \\\n    -p 8080:8080 \\\n    -e PUID=1000 \\\n    -e PGID=1000 \\\n    -e UMASK=002 \\\n    -e WEBUI_PORTS=\"8080/tcp,8080/udp\" \\\n    -e ARGS=\"\" \\\n    -e TZ=\"Etc/UTC\" \\\n    -v /&lt;host_folder_config&gt;:/config \\\n    -v /&lt;host_folder_data&gt;:/data \\\n    ghcr.io/hotio/sabnzbd\n</code></pre> <pre><code>services:\n  sabnzbd:\n    container_name: sabnzbd\n    image: ghcr.io/hotio/sabnzbd\n    ports:\n      - \"8080:8080\"\n    environment:\n      - PUID=1000\n      - PGID=1000\n      - UMASK=002\n      - TZ=Etc/UTC\n      - WEBUI_PORTS=8080/tcp,8080/udp\n      - ARGS\n    volumes:\n      - /&lt;host_folder_config&gt;:/config\n      - /&lt;host_folder_data&gt;:/data\n</code></pre>"},{"location":"containers/sabnzbd/#tags","title":"Tags","text":"Tags Description Last Updated Age"},{"location":"containers/sabnzbd/#wireguard","title":"WireGuard","text":"<p>Info</p> <p>This image includes VPN support. The cli/compose examples below are environment variables and settings complementary to the app image examples, this means you'll have to add/merge the stuff below with the stuff above. In case you are still in need of a VPN, consider using my affiliate links for Proton VPN, Proton Unlimited or Private Internet Access.</p> <p> </p> genericprotonpia clicompose <pre><code>docker run --rm \\\n    --hostname container-name.internal \\ #(18)\n    -e VPN_ENABLED=\"true\" \\ #(5)\n    -e VPN_CONF=\"wg0\" \\ #(8)\n    -e VPN_PROVIDER=\"generic\" \\ #(4)\n    -e VPN_LAN_NETWORK=\"192.168.1.0/24\" \\ #(1)\n    -e VPN_LAN_LEAK_ENABLED=\"false\" \\ #(10)\n    -e VPN_EXPOSE_PORTS_ON_LAN=\"\" \\ #(2)\n    -e VPN_AUTO_PORT_FORWARD=\"false\" \\ #(6)\n    -e VPN_AUTO_PORT_FORWARD_TO_PORTS=\"\" \\ #(15)\n    -e VPN_FIREWALL_TYPE=\"auto\" \\ #(17)\n    -e VPN_HEALTHCHECK_ENABLED=\"false\" \\ #(20)\n    -e VPN_NAMESERVERS=\"\" \\ #(16)\n    -e PRIVOXY_ENABLED=\"false\" \\ #(19)\n    -e UNBOUND_ENABLED=\"false\" \\ #(21)\n    -e UNBOUND_NAMESERVERS=\"\" \\ #(22)\n    --cap-add=NET_ADMIN \\\n    --sysctl=\"net.ipv4.conf.all.src_valid_mark=1\" \\ #(12)\n    --sysctl=\"net.ipv6.conf.all.disable_ipv6=1\" \\ #(3)\n    --device /dev/net/tun:/dev/net/tun \\ # OPTIONAL(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui. On MacOS set it to <code>192.168.65.0/24</code> (Verify with your settings [Resources &gt; Network &gt; Docker subnet]).</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>. Affiliate links: Proton VPN Proton Unlimited Private Internet Access</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> (for PIA this is done automatically, see <code>VPN_PROVIDER</code> variable) located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32 in most cases\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>DANGEROUS! Don't enable unless you know what you are doing!</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>Some of the possible values are for example <code>wg</code>, <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>wg</code> will use the nameservers from the <code>wg0.conf</code> file. A value in the format <code>8.8.8.8</code> is to use a plain old nameserver. A value in the format <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>If you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice.</p> </li> <li> <p>This will start Privoxy on the default port 8118 when set to <code>true</code>. By default Privoxy is not exposed on the LAN, so if you need that, you'll have to add <code>VPN_EXPOSE_PORTS_ON_LAN=8118/tcp,8118/udp</code>.</p> </li> <li> <p>Enabling this will bring down the container if the connectivity tests fail at the end of the Wireguard init process or for an extended period during the container runtime.</p> </li> <li> <p>Enable Unbound by setting to <code>true</code> when VPN is not active.</p> </li> <li> <p>Possible values are <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>8.8.8.8</code> is to use a plain old nameserver. The value <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> </ol> <pre><code>services:\n  app:\n    hostname: container-name.internal #(18)\n    environment:\n      - VPN_ENABLED=true #(5)\n      - VPN_CONF=wg0 #(8)\n      - VPN_PROVIDER=generic #(4)\n      - VPN_LAN_NETWORK=192.168.1.0/24 #(1)\n      - VPN_LAN_LEAK_ENABLED=false #(10)\n      - VPN_EXPOSE_PORTS_ON_LAN #(2)\n      - VPN_AUTO_PORT_FORWARD=false #(6)\n      - VPN_AUTO_PORT_FORWARD_TO_PORTS= #(15)\n      - VPN_FIREWALL_TYPE=auto #(17)\n      - VPN_HEALTHCHECK_ENABLED=false #(20)\n      - VPN_NAMESERVERS= #(16)\n      - PRIVOXY_ENABLED=false #(19)\n      - UNBOUND_ENABLED=false #(21)\n      - UNBOUND_NAMESERVERS #(22)\n    cap_add:\n      - NET_ADMIN\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1 #(12)\n      - net.ipv6.conf.all.disable_ipv6=1 #(3)\n    devices:\n      - /dev/net/tun:/dev/net/tun # OPTIONAL(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui. On MacOS set it to <code>192.168.65.0/24</code> (Verify with your settings [Resources &gt; Network &gt; Docker subnet]).</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>. Affiliate links: Proton VPN Proton Unlimited Private Internet Access</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> (for PIA this is done automatically, see <code>VPN_PROVIDER</code> variable) located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32 in most cases\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>DANGEROUS! Don't enable unless you know what you are doing!</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>Some of the possible values are for example <code>wg</code>, <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>wg</code> will use the nameservers from the <code>wg0.conf</code> file. A value in the format <code>8.8.8.8</code> is to use a plain old nameserver. A value in the format <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>If you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice.</p> </li> <li> <p>This will start Privoxy on the default port 8118 when set to <code>true</code>. By default Privoxy is not exposed on the LAN, so if you need that, you'll have to add <code>VPN_EXPOSE_PORTS_ON_LAN=8118/tcp,8118/udp</code>.</p> </li> <li> <p>Enabling this will bring down the container if the connectivity tests fail at the end of the Wireguard init process or for an extended period during the container runtime.</p> </li> <li> <p>Enable Unbound by setting to <code>true</code> when VPN is not active.</p> </li> <li> <p>Possible values are <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>8.8.8.8</code> is to use a plain old nameserver. The value <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> </ol> clicompose <pre><code>docker run --rm \\\n    --hostname container-name.internal \\ #(18)\n    -e VPN_ENABLED=\"true\" \\ #(5)\n    -e VPN_CONF=\"wg0\" \\ #(8)\n    -e VPN_PROVIDER=\"proton\" \\ #(4)\n    -e VPN_LAN_NETWORK=\"192.168.1.0/24\" \\ #(1)\n    -e VPN_LAN_LEAK_ENABLED=\"false\" \\ #(10)\n    -e VPN_EXPOSE_PORTS_ON_LAN=\"\" \\ #(2)\n    -e VPN_AUTO_PORT_FORWARD=\"true\" \\ #(6)\n    -e VPN_AUTO_PORT_FORWARD_TO_PORTS=\"\" \\ #(15)\n    -e VPN_FIREWALL_TYPE=\"auto\" \\ #(17)\n    -e VPN_HEALTHCHECK_ENABLED=\"false\" \\ #(20)\n    -e VPN_NAMESERVERS=\"\" \\ #(16)\n    -e PRIVOXY_ENABLED=\"false\" \\ #(19)\n    -e UNBOUND_ENABLED=\"false\" \\ #(21)\n    -e UNBOUND_NAMESERVERS=\"\" \\ #(22)\n    --cap-add=NET_ADMIN \\\n    --sysctl=\"net.ipv4.conf.all.src_valid_mark=1\" \\ #(12)\n    --sysctl=\"net.ipv6.conf.all.disable_ipv6=1\" \\ #(3)\n    --device /dev/net/tun:/dev/net/tun \\ # OPTIONAL(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui. On MacOS set it to <code>192.168.65.0/24</code> (Verify with your settings [Resources &gt; Network &gt; Docker subnet]).</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>. Affiliate links: Proton VPN Proton Unlimited Private Internet Access</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> (for PIA this is done automatically, see <code>VPN_PROVIDER</code> variable) located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32 in most cases\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>DANGEROUS! Don't enable unless you know what you are doing!</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>Some of the possible values are for example <code>wg</code>, <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>wg</code> will use the nameservers from the <code>wg0.conf</code> file. A value in the format <code>8.8.8.8</code> is to use a plain old nameserver. A value in the format <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>If you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice.</p> </li> <li> <p>This will start Privoxy on the default port 8118 when set to <code>true</code>. By default Privoxy is not exposed on the LAN, so if you need that, you'll have to add <code>VPN_EXPOSE_PORTS_ON_LAN=8118/tcp,8118/udp</code>.</p> </li> <li> <p>Enabling this will bring down the container if the connectivity tests fail at the end of the Wireguard init process or for an extended period during the container runtime.</p> </li> <li> <p>Enable Unbound by setting to <code>true</code> when VPN is not active.</p> </li> <li> <p>Possible values are <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>8.8.8.8</code> is to use a plain old nameserver. The value <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> </ol> <pre><code>services:\n  app:\n    hostname: container-name.internal #(18)\n    environment:\n      - VPN_ENABLED=true #(5)\n      - VPN_CONF=wg0 #(8)\n      - VPN_PROVIDER=proton #(4)\n      - VPN_LAN_NETWORK=192.168.1.0/24 #(1)\n      - VPN_LAN_LEAK_ENABLED=false #(10)\n      - VPN_EXPOSE_PORTS_ON_LAN #(2)\n      - VPN_AUTO_PORT_FORWARD=true #(6)\n      - VPN_AUTO_PORT_FORWARD_TO_PORTS= #(15)\n      - VPN_FIREWALL_TYPE=auto #(17)\n      - VPN_HEALTHCHECK_ENABLED=false #(20)\n      - VPN_NAMESERVERS= #(16)\n      - PRIVOXY_ENABLED=false #(19)\n      - UNBOUND_ENABLED=false #(21)\n      - UNBOUND_NAMESERVERS #(22)\n    cap_add:\n      - NET_ADMIN\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1 #(12)\n      - net.ipv6.conf.all.disable_ipv6=1 #(3)\n    devices:\n      - /dev/net/tun:/dev/net/tun # OPTIONAL(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui. On MacOS set it to <code>192.168.65.0/24</code> (Verify with your settings [Resources &gt; Network &gt; Docker subnet]).</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>. Affiliate links: Proton VPN Proton Unlimited Private Internet Access</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> (for PIA this is done automatically, see <code>VPN_PROVIDER</code> variable) located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32 in most cases\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>DANGEROUS! Don't enable unless you know what you are doing!</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>Some of the possible values are for example <code>wg</code>, <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>wg</code> will use the nameservers from the <code>wg0.conf</code> file. A value in the format <code>8.8.8.8</code> is to use a plain old nameserver. A value in the format <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>If you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice.</p> </li> <li> <p>This will start Privoxy on the default port 8118 when set to <code>true</code>. By default Privoxy is not exposed on the LAN, so if you need that, you'll have to add <code>VPN_EXPOSE_PORTS_ON_LAN=8118/tcp,8118/udp</code>.</p> </li> <li> <p>Enabling this will bring down the container if the connectivity tests fail at the end of the Wireguard init process or for an extended period during the container runtime.</p> </li> <li> <p>Enable Unbound by setting to <code>true</code> when VPN is not active.</p> </li> <li> <p>Possible values are <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>8.8.8.8</code> is to use a plain old nameserver. The value <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> </ol> clicompose <pre><code>docker run --rm \\\n    --hostname container-name.internal \\ #(18)\n    -e VPN_ENABLED=\"true\" \\ #(5)\n    -e VPN_CONF=\"wg0\" \\ #(8)\n    -e VPN_PROVIDER=\"pia\" \\ #(4)\n    -e VPN_LAN_NETWORK=\"192.168.1.0/24\" \\ #(1)\n    -e VPN_LAN_LEAK_ENABLED=\"false\" \\ #(10)\n    -e VPN_EXPOSE_PORTS_ON_LAN=\"\" \\ #(2)\n    -e VPN_AUTO_PORT_FORWARD=\"true\" \\ #(6)\n    -e VPN_AUTO_PORT_FORWARD_TO_PORTS=\"\" \\ #(15)\n    -e VPN_FIREWALL_TYPE=\"auto\" \\ #(17)\n    -e VPN_HEALTHCHECK_ENABLED=\"false\" \\ #(20)\n    -e VPN_NAMESERVERS=\"\" \\ #(16)\n    -e VPN_PIA_USER=\"\" \\ #(11)\n    -e VPN_PIA_PASS=\"\" \\ #(11)\n    -e VPN_PIA_PREFERRED_REGION=\"\" \\ #(7)\n    -e VPN_PIA_DIP_TOKEN=\"no\" \\ #(13)\n    -e VPN_PIA_PORT_FORWARD_PERSIST=\"false\" \\ #(14)\n    -e PRIVOXY_ENABLED=\"false\" \\ #(19)\n    -e UNBOUND_ENABLED=\"false\" \\ #(21)\n    -e UNBOUND_NAMESERVERS=\"\" \\ #(22)\n    --cap-add=NET_ADMIN \\\n    --sysctl=\"net.ipv4.conf.all.src_valid_mark=1\" \\ #(12)\n    --sysctl=\"net.ipv6.conf.all.disable_ipv6=1\" \\ #(3)\n    --device /dev/net/tun:/dev/net/tun \\ # OPTIONAL(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui. On MacOS set it to <code>192.168.65.0/24</code> (Verify with your settings [Resources &gt; Network &gt; Docker subnet]).</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>. Affiliate links: Proton VPN Proton Unlimited Private Internet Access</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> (for PIA this is done automatically, see <code>VPN_PROVIDER</code> variable) located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32 in most cases\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>DANGEROUS! Don't enable unless you know what you are doing!</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>Some of the possible values are for example <code>wg</code>, <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>wg</code> will use the nameservers from the <code>wg0.conf</code> file. A value in the format <code>8.8.8.8</code> is to use a plain old nameserver. A value in the format <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>If you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice.</p> </li> <li> <p>This will start Privoxy on the default port 8118 when set to <code>true</code>. By default Privoxy is not exposed on the LAN, so if you need that, you'll have to add <code>VPN_EXPOSE_PORTS_ON_LAN=8118/tcp,8118/udp</code>.</p> </li> <li> <p>Enabling this will bring down the container if the connectivity tests fail at the end of the Wireguard init process or for an extended period during the container runtime.</p> </li> <li> <p>Enable Unbound by setting to <code>true</code> when VPN is not active.</p> </li> <li> <p>Possible values are <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>8.8.8.8</code> is to use a plain old nameserver. The value <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> </ol> <pre><code>services:\n  app:\n    hostname: container-name.internal #(18)\n    environment:\n      - VPN_ENABLED=true #(5)\n      - VPN_CONF=wg0 #(8)\n      - VPN_PROVIDER=pia #(4)\n      - VPN_LAN_NETWORK=192.168.1.0/24 #(1)\n      - VPN_LAN_LEAK_ENABLED=false #(10)\n      - VPN_EXPOSE_PORTS_ON_LAN #(2)\n      - VPN_AUTO_PORT_FORWARD=true #(6)\n      - VPN_AUTO_PORT_FORWARD_TO_PORTS= #(15)\n      - VPN_FIREWALL_TYPE=auto #(17)\n      - VPN_HEALTHCHECK_ENABLED=false #(20)\n      - VPN_NAMESERVERS= #(16)\n      - VPN_PIA_USER #(11)\n      - VPN_PIA_PASS #(11)\n      - VPN_PIA_PREFERRED_REGION #(7)\n      - VPN_PIA_DIP_TOKEN=no #(13)\n      - VPN_PIA_PORT_FORWARD_PERSIST=false #(14)\n      - PRIVOXY_ENABLED=false #(19)\n      - UNBOUND_ENABLED=false #(21)\n      - UNBOUND_NAMESERVERS #(22)\n    cap_add:\n      - NET_ADMIN\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1 #(12)\n      - net.ipv6.conf.all.disable_ipv6=1 #(3)\n    devices:\n      - /dev/net/tun:/dev/net/tun # OPTIONAL(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui. On MacOS set it to <code>192.168.65.0/24</code> (Verify with your settings [Resources &gt; Network &gt; Docker subnet]).</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>. Affiliate links: Proton VPN Proton Unlimited Private Internet Access</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> (for PIA this is done automatically, see <code>VPN_PROVIDER</code> variable) located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32 in most cases\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>DANGEROUS! Don't enable unless you know what you are doing!</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>Some of the possible values are for example <code>wg</code>, <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>wg</code> will use the nameservers from the <code>wg0.conf</code> file. A value in the format <code>8.8.8.8</code> is to use a plain old nameserver. A value in the format <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>If you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice.</p> </li> <li> <p>This will start Privoxy on the default port 8118 when set to <code>true</code>. By default Privoxy is not exposed on the LAN, so if you need that, you'll have to add <code>VPN_EXPOSE_PORTS_ON_LAN=8118/tcp,8118/udp</code>.</p> </li> <li> <p>Enabling this will bring down the container if the connectivity tests fail at the end of the Wireguard init process or for an extended period during the container runtime.</p> </li> <li> <p>Enable Unbound by setting to <code>true</code> when VPN is not active.</p> </li> <li> <p>Possible values are <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>8.8.8.8</code> is to use a plain old nameserver. The value <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> </ol>"},{"location":"containers/sonarr/","title":"hotio/sonarr","text":"<p> GitHub ghcr.io</p>"},{"location":"containers/sonarr/#starting-the-container","title":"Starting the container","text":"clicompose <pre><code>docker run --rm \\\n    --name sonarr \\\n    -p 8989:8989 \\\n    -e PUID=1000 \\\n    -e PGID=1000 \\\n    -e UMASK=002 \\\n    -e TZ=\"Etc/UTC\" \\\n    -v /&lt;host_folder_config&gt;:/config \\\n    -v /&lt;host_folder_data&gt;:/data \\\n    ghcr.io/hotio/sonarr\n</code></pre> <pre><code>services:\n  sonarr:\n    container_name: sonarr\n    image: ghcr.io/hotio/sonarr\n    ports:\n      - \"8989:8989\"\n    environment:\n      - PUID=1000\n      - PGID=1000\n      - UMASK=002\n      - TZ=Etc/UTC\n    volumes:\n      - /&lt;host_folder_config&gt;:/config\n      - /&lt;host_folder_data&gt;:/data\n</code></pre>"},{"location":"containers/sonarr/#tags","title":"Tags","text":"Tags Description Last Updated Age"},{"location":"containers/sonarr/#wireguard","title":"WireGuard","text":"<p>Info</p> <p>This image includes VPN support. The cli/compose examples below are environment variables and settings complementary to the app image examples, this means you'll have to add/merge the stuff below with the stuff above. In case you are still in need of a VPN, consider using my affiliate links for Proton VPN, Proton Unlimited or Private Internet Access.</p> <p> </p> genericprotonpia clicompose <pre><code>docker run --rm \\\n    --hostname container-name.internal \\ #(18)\n    -e VPN_ENABLED=\"true\" \\ #(5)\n    -e VPN_CONF=\"wg0\" \\ #(8)\n    -e VPN_PROVIDER=\"generic\" \\ #(4)\n    -e VPN_LAN_NETWORK=\"192.168.1.0/24\" \\ #(1)\n    -e VPN_LAN_LEAK_ENABLED=\"false\" \\ #(10)\n    -e VPN_EXPOSE_PORTS_ON_LAN=\"\" \\ #(2)\n    -e VPN_AUTO_PORT_FORWARD=\"false\" \\ #(6)\n    -e VPN_AUTO_PORT_FORWARD_TO_PORTS=\"\" \\ #(15)\n    -e VPN_FIREWALL_TYPE=\"auto\" \\ #(17)\n    -e VPN_HEALTHCHECK_ENABLED=\"false\" \\ #(20)\n    -e VPN_NAMESERVERS=\"\" \\ #(16)\n    -e PRIVOXY_ENABLED=\"false\" \\ #(19)\n    -e UNBOUND_ENABLED=\"false\" \\ #(21)\n    -e UNBOUND_NAMESERVERS=\"\" \\ #(22)\n    --cap-add=NET_ADMIN \\\n    --sysctl=\"net.ipv4.conf.all.src_valid_mark=1\" \\ #(12)\n    --sysctl=\"net.ipv6.conf.all.disable_ipv6=1\" \\ #(3)\n    --device /dev/net/tun:/dev/net/tun \\ # OPTIONAL(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui. On MacOS set it to <code>192.168.65.0/24</code> (Verify with your settings [Resources &gt; Network &gt; Docker subnet]).</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>. Affiliate links: Proton VPN Proton Unlimited Private Internet Access</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> (for PIA this is done automatically, see <code>VPN_PROVIDER</code> variable) located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32 in most cases\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>DANGEROUS! Don't enable unless you know what you are doing!</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>Some of the possible values are for example <code>wg</code>, <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>wg</code> will use the nameservers from the <code>wg0.conf</code> file. A value in the format <code>8.8.8.8</code> is to use a plain old nameserver. A value in the format <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>If you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice.</p> </li> <li> <p>This will start Privoxy on the default port 8118 when set to <code>true</code>. By default Privoxy is not exposed on the LAN, so if you need that, you'll have to add <code>VPN_EXPOSE_PORTS_ON_LAN=8118/tcp,8118/udp</code>.</p> </li> <li> <p>Enabling this will bring down the container if the connectivity tests fail at the end of the Wireguard init process or for an extended period during the container runtime.</p> </li> <li> <p>Enable Unbound by setting to <code>true</code> when VPN is not active.</p> </li> <li> <p>Possible values are <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>8.8.8.8</code> is to use a plain old nameserver. The value <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> </ol> <pre><code>services:\n  app:\n    hostname: container-name.internal #(18)\n    environment:\n      - VPN_ENABLED=true #(5)\n      - VPN_CONF=wg0 #(8)\n      - VPN_PROVIDER=generic #(4)\n      - VPN_LAN_NETWORK=192.168.1.0/24 #(1)\n      - VPN_LAN_LEAK_ENABLED=false #(10)\n      - VPN_EXPOSE_PORTS_ON_LAN #(2)\n      - VPN_AUTO_PORT_FORWARD=false #(6)\n      - VPN_AUTO_PORT_FORWARD_TO_PORTS= #(15)\n      - VPN_FIREWALL_TYPE=auto #(17)\n      - VPN_HEALTHCHECK_ENABLED=false #(20)\n      - VPN_NAMESERVERS= #(16)\n      - PRIVOXY_ENABLED=false #(19)\n      - UNBOUND_ENABLED=false #(21)\n      - UNBOUND_NAMESERVERS #(22)\n    cap_add:\n      - NET_ADMIN\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1 #(12)\n      - net.ipv6.conf.all.disable_ipv6=1 #(3)\n    devices:\n      - /dev/net/tun:/dev/net/tun # OPTIONAL(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui. On MacOS set it to <code>192.168.65.0/24</code> (Verify with your settings [Resources &gt; Network &gt; Docker subnet]).</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>. Affiliate links: Proton VPN Proton Unlimited Private Internet Access</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> (for PIA this is done automatically, see <code>VPN_PROVIDER</code> variable) located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32 in most cases\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>DANGEROUS! Don't enable unless you know what you are doing!</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>Some of the possible values are for example <code>wg</code>, <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>wg</code> will use the nameservers from the <code>wg0.conf</code> file. A value in the format <code>8.8.8.8</code> is to use a plain old nameserver. A value in the format <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>If you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice.</p> </li> <li> <p>This will start Privoxy on the default port 8118 when set to <code>true</code>. By default Privoxy is not exposed on the LAN, so if you need that, you'll have to add <code>VPN_EXPOSE_PORTS_ON_LAN=8118/tcp,8118/udp</code>.</p> </li> <li> <p>Enabling this will bring down the container if the connectivity tests fail at the end of the Wireguard init process or for an extended period during the container runtime.</p> </li> <li> <p>Enable Unbound by setting to <code>true</code> when VPN is not active.</p> </li> <li> <p>Possible values are <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>8.8.8.8</code> is to use a plain old nameserver. The value <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> </ol> clicompose <pre><code>docker run --rm \\\n    --hostname container-name.internal \\ #(18)\n    -e VPN_ENABLED=\"true\" \\ #(5)\n    -e VPN_CONF=\"wg0\" \\ #(8)\n    -e VPN_PROVIDER=\"proton\" \\ #(4)\n    -e VPN_LAN_NETWORK=\"192.168.1.0/24\" \\ #(1)\n    -e VPN_LAN_LEAK_ENABLED=\"false\" \\ #(10)\n    -e VPN_EXPOSE_PORTS_ON_LAN=\"\" \\ #(2)\n    -e VPN_AUTO_PORT_FORWARD=\"true\" \\ #(6)\n    -e VPN_AUTO_PORT_FORWARD_TO_PORTS=\"\" \\ #(15)\n    -e VPN_FIREWALL_TYPE=\"auto\" \\ #(17)\n    -e VPN_HEALTHCHECK_ENABLED=\"false\" \\ #(20)\n    -e VPN_NAMESERVERS=\"\" \\ #(16)\n    -e PRIVOXY_ENABLED=\"false\" \\ #(19)\n    -e UNBOUND_ENABLED=\"false\" \\ #(21)\n    -e UNBOUND_NAMESERVERS=\"\" \\ #(22)\n    --cap-add=NET_ADMIN \\\n    --sysctl=\"net.ipv4.conf.all.src_valid_mark=1\" \\ #(12)\n    --sysctl=\"net.ipv6.conf.all.disable_ipv6=1\" \\ #(3)\n    --device /dev/net/tun:/dev/net/tun \\ # OPTIONAL(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui. On MacOS set it to <code>192.168.65.0/24</code> (Verify with your settings [Resources &gt; Network &gt; Docker subnet]).</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>. Affiliate links: Proton VPN Proton Unlimited Private Internet Access</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> (for PIA this is done automatically, see <code>VPN_PROVIDER</code> variable) located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32 in most cases\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>DANGEROUS! Don't enable unless you know what you are doing!</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>Some of the possible values are for example <code>wg</code>, <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>wg</code> will use the nameservers from the <code>wg0.conf</code> file. A value in the format <code>8.8.8.8</code> is to use a plain old nameserver. A value in the format <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>If you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice.</p> </li> <li> <p>This will start Privoxy on the default port 8118 when set to <code>true</code>. By default Privoxy is not exposed on the LAN, so if you need that, you'll have to add <code>VPN_EXPOSE_PORTS_ON_LAN=8118/tcp,8118/udp</code>.</p> </li> <li> <p>Enabling this will bring down the container if the connectivity tests fail at the end of the Wireguard init process or for an extended period during the container runtime.</p> </li> <li> <p>Enable Unbound by setting to <code>true</code> when VPN is not active.</p> </li> <li> <p>Possible values are <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>8.8.8.8</code> is to use a plain old nameserver. The value <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> </ol> <pre><code>services:\n  app:\n    hostname: container-name.internal #(18)\n    environment:\n      - VPN_ENABLED=true #(5)\n      - VPN_CONF=wg0 #(8)\n      - VPN_PROVIDER=proton #(4)\n      - VPN_LAN_NETWORK=192.168.1.0/24 #(1)\n      - VPN_LAN_LEAK_ENABLED=false #(10)\n      - VPN_EXPOSE_PORTS_ON_LAN #(2)\n      - VPN_AUTO_PORT_FORWARD=true #(6)\n      - VPN_AUTO_PORT_FORWARD_TO_PORTS= #(15)\n      - VPN_FIREWALL_TYPE=auto #(17)\n      - VPN_HEALTHCHECK_ENABLED=false #(20)\n      - VPN_NAMESERVERS= #(16)\n      - PRIVOXY_ENABLED=false #(19)\n      - UNBOUND_ENABLED=false #(21)\n      - UNBOUND_NAMESERVERS #(22)\n    cap_add:\n      - NET_ADMIN\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1 #(12)\n      - net.ipv6.conf.all.disable_ipv6=1 #(3)\n    devices:\n      - /dev/net/tun:/dev/net/tun # OPTIONAL(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui. On MacOS set it to <code>192.168.65.0/24</code> (Verify with your settings [Resources &gt; Network &gt; Docker subnet]).</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>. Affiliate links: Proton VPN Proton Unlimited Private Internet Access</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> (for PIA this is done automatically, see <code>VPN_PROVIDER</code> variable) located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32 in most cases\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>DANGEROUS! Don't enable unless you know what you are doing!</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>Some of the possible values are for example <code>wg</code>, <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>wg</code> will use the nameservers from the <code>wg0.conf</code> file. A value in the format <code>8.8.8.8</code> is to use a plain old nameserver. A value in the format <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>If you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice.</p> </li> <li> <p>This will start Privoxy on the default port 8118 when set to <code>true</code>. By default Privoxy is not exposed on the LAN, so if you need that, you'll have to add <code>VPN_EXPOSE_PORTS_ON_LAN=8118/tcp,8118/udp</code>.</p> </li> <li> <p>Enabling this will bring down the container if the connectivity tests fail at the end of the Wireguard init process or for an extended period during the container runtime.</p> </li> <li> <p>Enable Unbound by setting to <code>true</code> when VPN is not active.</p> </li> <li> <p>Possible values are <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>8.8.8.8</code> is to use a plain old nameserver. The value <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> </ol> clicompose <pre><code>docker run --rm \\\n    --hostname container-name.internal \\ #(18)\n    -e VPN_ENABLED=\"true\" \\ #(5)\n    -e VPN_CONF=\"wg0\" \\ #(8)\n    -e VPN_PROVIDER=\"pia\" \\ #(4)\n    -e VPN_LAN_NETWORK=\"192.168.1.0/24\" \\ #(1)\n    -e VPN_LAN_LEAK_ENABLED=\"false\" \\ #(10)\n    -e VPN_EXPOSE_PORTS_ON_LAN=\"\" \\ #(2)\n    -e VPN_AUTO_PORT_FORWARD=\"true\" \\ #(6)\n    -e VPN_AUTO_PORT_FORWARD_TO_PORTS=\"\" \\ #(15)\n    -e VPN_FIREWALL_TYPE=\"auto\" \\ #(17)\n    -e VPN_HEALTHCHECK_ENABLED=\"false\" \\ #(20)\n    -e VPN_NAMESERVERS=\"\" \\ #(16)\n    -e VPN_PIA_USER=\"\" \\ #(11)\n    -e VPN_PIA_PASS=\"\" \\ #(11)\n    -e VPN_PIA_PREFERRED_REGION=\"\" \\ #(7)\n    -e VPN_PIA_DIP_TOKEN=\"no\" \\ #(13)\n    -e VPN_PIA_PORT_FORWARD_PERSIST=\"false\" \\ #(14)\n    -e PRIVOXY_ENABLED=\"false\" \\ #(19)\n    -e UNBOUND_ENABLED=\"false\" \\ #(21)\n    -e UNBOUND_NAMESERVERS=\"\" \\ #(22)\n    --cap-add=NET_ADMIN \\\n    --sysctl=\"net.ipv4.conf.all.src_valid_mark=1\" \\ #(12)\n    --sysctl=\"net.ipv6.conf.all.disable_ipv6=1\" \\ #(3)\n    --device /dev/net/tun:/dev/net/tun \\ # OPTIONAL(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui. On MacOS set it to <code>192.168.65.0/24</code> (Verify with your settings [Resources &gt; Network &gt; Docker subnet]).</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>. Affiliate links: Proton VPN Proton Unlimited Private Internet Access</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> (for PIA this is done automatically, see <code>VPN_PROVIDER</code> variable) located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32 in most cases\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>DANGEROUS! Don't enable unless you know what you are doing!</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>Some of the possible values are for example <code>wg</code>, <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>wg</code> will use the nameservers from the <code>wg0.conf</code> file. A value in the format <code>8.8.8.8</code> is to use a plain old nameserver. A value in the format <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>If you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice.</p> </li> <li> <p>This will start Privoxy on the default port 8118 when set to <code>true</code>. By default Privoxy is not exposed on the LAN, so if you need that, you'll have to add <code>VPN_EXPOSE_PORTS_ON_LAN=8118/tcp,8118/udp</code>.</p> </li> <li> <p>Enabling this will bring down the container if the connectivity tests fail at the end of the Wireguard init process or for an extended period during the container runtime.</p> </li> <li> <p>Enable Unbound by setting to <code>true</code> when VPN is not active.</p> </li> <li> <p>Possible values are <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>8.8.8.8</code> is to use a plain old nameserver. The value <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> </ol> <pre><code>services:\n  app:\n    hostname: container-name.internal #(18)\n    environment:\n      - VPN_ENABLED=true #(5)\n      - VPN_CONF=wg0 #(8)\n      - VPN_PROVIDER=pia #(4)\n      - VPN_LAN_NETWORK=192.168.1.0/24 #(1)\n      - VPN_LAN_LEAK_ENABLED=false #(10)\n      - VPN_EXPOSE_PORTS_ON_LAN #(2)\n      - VPN_AUTO_PORT_FORWARD=true #(6)\n      - VPN_AUTO_PORT_FORWARD_TO_PORTS= #(15)\n      - VPN_FIREWALL_TYPE=auto #(17)\n      - VPN_HEALTHCHECK_ENABLED=false #(20)\n      - VPN_NAMESERVERS= #(16)\n      - VPN_PIA_USER #(11)\n      - VPN_PIA_PASS #(11)\n      - VPN_PIA_PREFERRED_REGION #(7)\n      - VPN_PIA_DIP_TOKEN=no #(13)\n      - VPN_PIA_PORT_FORWARD_PERSIST=false #(14)\n      - PRIVOXY_ENABLED=false #(19)\n      - UNBOUND_ENABLED=false #(21)\n      - UNBOUND_NAMESERVERS #(22)\n    cap_add:\n      - NET_ADMIN\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1 #(12)\n      - net.ipv6.conf.all.disable_ipv6=1 #(3)\n    devices:\n      - /dev/net/tun:/dev/net/tun # OPTIONAL(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui. On MacOS set it to <code>192.168.65.0/24</code> (Verify with your settings [Resources &gt; Network &gt; Docker subnet]).</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>. Affiliate links: Proton VPN Proton Unlimited Private Internet Access</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> (for PIA this is done automatically, see <code>VPN_PROVIDER</code> variable) located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32 in most cases\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>DANGEROUS! Don't enable unless you know what you are doing!</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>Some of the possible values are for example <code>wg</code>, <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>wg</code> will use the nameservers from the <code>wg0.conf</code> file. A value in the format <code>8.8.8.8</code> is to use a plain old nameserver. A value in the format <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>If you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice.</p> </li> <li> <p>This will start Privoxy on the default port 8118 when set to <code>true</code>. By default Privoxy is not exposed on the LAN, so if you need that, you'll have to add <code>VPN_EXPOSE_PORTS_ON_LAN=8118/tcp,8118/udp</code>.</p> </li> <li> <p>Enabling this will bring down the container if the connectivity tests fail at the end of the Wireguard init process or for an extended period during the container runtime.</p> </li> <li> <p>Enable Unbound by setting to <code>true</code> when VPN is not active.</p> </li> <li> <p>Possible values are <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>8.8.8.8</code> is to use a plain old nameserver. The value <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> </ol>"},{"location":"containers/stash/","title":"hotio/stash","text":"<p> GitHub ghcr.io</p>"},{"location":"containers/stash/#starting-the-container","title":"Starting the container","text":"clicompose <pre><code>docker run --rm \\\n    --name stash \\\n    -p 9999:9999 \\\n    -e PUID=1000 \\\n    -e PGID=1000 \\\n    -e UMASK=002 \\\n    -e TZ=\"Etc/UTC\" \\\n    -v /&lt;host_folder_config&gt;:/config \\\n    -v /&lt;host_folder_data&gt;:/data \\\n    ghcr.io/hotio/stash\n</code></pre> <pre><code>services:\n  stash:\n    container_name: stash\n    image: ghcr.io/hotio/stash\n    ports:\n      - \"9999:9999\"\n    environment:\n      - PUID=1000\n      - PGID=1000\n      - UMASK=002\n      - TZ=Etc/UTC\n    volumes:\n      - /&lt;host_folder_config&gt;:/config\n      - /&lt;host_folder_data&gt;:/data\n</code></pre>"},{"location":"containers/stash/#tags","title":"Tags","text":"Tags Description Last Updated Age"},{"location":"containers/stash/#wireguard","title":"WireGuard","text":"<p>Info</p> <p>This image includes VPN support. The cli/compose examples below are environment variables and settings complementary to the app image examples, this means you'll have to add/merge the stuff below with the stuff above. In case you are still in need of a VPN, consider using my affiliate links for Proton VPN, Proton Unlimited or Private Internet Access.</p> <p> </p> genericprotonpia clicompose <pre><code>docker run --rm \\\n    --hostname container-name.internal \\ #(18)\n    -e VPN_ENABLED=\"true\" \\ #(5)\n    -e VPN_CONF=\"wg0\" \\ #(8)\n    -e VPN_PROVIDER=\"generic\" \\ #(4)\n    -e VPN_LAN_NETWORK=\"192.168.1.0/24\" \\ #(1)\n    -e VPN_LAN_LEAK_ENABLED=\"false\" \\ #(10)\n    -e VPN_EXPOSE_PORTS_ON_LAN=\"\" \\ #(2)\n    -e VPN_AUTO_PORT_FORWARD=\"false\" \\ #(6)\n    -e VPN_AUTO_PORT_FORWARD_TO_PORTS=\"\" \\ #(15)\n    -e VPN_FIREWALL_TYPE=\"auto\" \\ #(17)\n    -e VPN_HEALTHCHECK_ENABLED=\"false\" \\ #(20)\n    -e VPN_NAMESERVERS=\"\" \\ #(16)\n    -e PRIVOXY_ENABLED=\"false\" \\ #(19)\n    -e UNBOUND_ENABLED=\"false\" \\ #(21)\n    -e UNBOUND_NAMESERVERS=\"\" \\ #(22)\n    --cap-add=NET_ADMIN \\\n    --sysctl=\"net.ipv4.conf.all.src_valid_mark=1\" \\ #(12)\n    --sysctl=\"net.ipv6.conf.all.disable_ipv6=1\" \\ #(3)\n    --device /dev/net/tun:/dev/net/tun \\ # OPTIONAL(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui. On MacOS set it to <code>192.168.65.0/24</code> (Verify with your settings [Resources &gt; Network &gt; Docker subnet]).</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>. Affiliate links: Proton VPN Proton Unlimited Private Internet Access</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> (for PIA this is done automatically, see <code>VPN_PROVIDER</code> variable) located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32 in most cases\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>DANGEROUS! Don't enable unless you know what you are doing!</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>Some of the possible values are for example <code>wg</code>, <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>wg</code> will use the nameservers from the <code>wg0.conf</code> file. A value in the format <code>8.8.8.8</code> is to use a plain old nameserver. A value in the format <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>If you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice.</p> </li> <li> <p>This will start Privoxy on the default port 8118 when set to <code>true</code>. By default Privoxy is not exposed on the LAN, so if you need that, you'll have to add <code>VPN_EXPOSE_PORTS_ON_LAN=8118/tcp,8118/udp</code>.</p> </li> <li> <p>Enabling this will bring down the container if the connectivity tests fail at the end of the Wireguard init process or for an extended period during the container runtime.</p> </li> <li> <p>Enable Unbound by setting to <code>true</code> when VPN is not active.</p> </li> <li> <p>Possible values are <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>8.8.8.8</code> is to use a plain old nameserver. The value <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> </ol> <pre><code>services:\n  app:\n    hostname: container-name.internal #(18)\n    environment:\n      - VPN_ENABLED=true #(5)\n      - VPN_CONF=wg0 #(8)\n      - VPN_PROVIDER=generic #(4)\n      - VPN_LAN_NETWORK=192.168.1.0/24 #(1)\n      - VPN_LAN_LEAK_ENABLED=false #(10)\n      - VPN_EXPOSE_PORTS_ON_LAN #(2)\n      - VPN_AUTO_PORT_FORWARD=false #(6)\n      - VPN_AUTO_PORT_FORWARD_TO_PORTS= #(15)\n      - VPN_FIREWALL_TYPE=auto #(17)\n      - VPN_HEALTHCHECK_ENABLED=false #(20)\n      - VPN_NAMESERVERS= #(16)\n      - PRIVOXY_ENABLED=false #(19)\n      - UNBOUND_ENABLED=false #(21)\n      - UNBOUND_NAMESERVERS #(22)\n    cap_add:\n      - NET_ADMIN\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1 #(12)\n      - net.ipv6.conf.all.disable_ipv6=1 #(3)\n    devices:\n      - /dev/net/tun:/dev/net/tun # OPTIONAL(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui. On MacOS set it to <code>192.168.65.0/24</code> (Verify with your settings [Resources &gt; Network &gt; Docker subnet]).</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>. Affiliate links: Proton VPN Proton Unlimited Private Internet Access</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> (for PIA this is done automatically, see <code>VPN_PROVIDER</code> variable) located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32 in most cases\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>DANGEROUS! Don't enable unless you know what you are doing!</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>Some of the possible values are for example <code>wg</code>, <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>wg</code> will use the nameservers from the <code>wg0.conf</code> file. A value in the format <code>8.8.8.8</code> is to use a plain old nameserver. A value in the format <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>If you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice.</p> </li> <li> <p>This will start Privoxy on the default port 8118 when set to <code>true</code>. By default Privoxy is not exposed on the LAN, so if you need that, you'll have to add <code>VPN_EXPOSE_PORTS_ON_LAN=8118/tcp,8118/udp</code>.</p> </li> <li> <p>Enabling this will bring down the container if the connectivity tests fail at the end of the Wireguard init process or for an extended period during the container runtime.</p> </li> <li> <p>Enable Unbound by setting to <code>true</code> when VPN is not active.</p> </li> <li> <p>Possible values are <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>8.8.8.8</code> is to use a plain old nameserver. The value <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> </ol> clicompose <pre><code>docker run --rm \\\n    --hostname container-name.internal \\ #(18)\n    -e VPN_ENABLED=\"true\" \\ #(5)\n    -e VPN_CONF=\"wg0\" \\ #(8)\n    -e VPN_PROVIDER=\"proton\" \\ #(4)\n    -e VPN_LAN_NETWORK=\"192.168.1.0/24\" \\ #(1)\n    -e VPN_LAN_LEAK_ENABLED=\"false\" \\ #(10)\n    -e VPN_EXPOSE_PORTS_ON_LAN=\"\" \\ #(2)\n    -e VPN_AUTO_PORT_FORWARD=\"true\" \\ #(6)\n    -e VPN_AUTO_PORT_FORWARD_TO_PORTS=\"\" \\ #(15)\n    -e VPN_FIREWALL_TYPE=\"auto\" \\ #(17)\n    -e VPN_HEALTHCHECK_ENABLED=\"false\" \\ #(20)\n    -e VPN_NAMESERVERS=\"\" \\ #(16)\n    -e PRIVOXY_ENABLED=\"false\" \\ #(19)\n    -e UNBOUND_ENABLED=\"false\" \\ #(21)\n    -e UNBOUND_NAMESERVERS=\"\" \\ #(22)\n    --cap-add=NET_ADMIN \\\n    --sysctl=\"net.ipv4.conf.all.src_valid_mark=1\" \\ #(12)\n    --sysctl=\"net.ipv6.conf.all.disable_ipv6=1\" \\ #(3)\n    --device /dev/net/tun:/dev/net/tun \\ # OPTIONAL(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui. On MacOS set it to <code>192.168.65.0/24</code> (Verify with your settings [Resources &gt; Network &gt; Docker subnet]).</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>. Affiliate links: Proton VPN Proton Unlimited Private Internet Access</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> (for PIA this is done automatically, see <code>VPN_PROVIDER</code> variable) located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32 in most cases\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>DANGEROUS! Don't enable unless you know what you are doing!</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>Some of the possible values are for example <code>wg</code>, <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>wg</code> will use the nameservers from the <code>wg0.conf</code> file. A value in the format <code>8.8.8.8</code> is to use a plain old nameserver. A value in the format <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>If you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice.</p> </li> <li> <p>This will start Privoxy on the default port 8118 when set to <code>true</code>. By default Privoxy is not exposed on the LAN, so if you need that, you'll have to add <code>VPN_EXPOSE_PORTS_ON_LAN=8118/tcp,8118/udp</code>.</p> </li> <li> <p>Enabling this will bring down the container if the connectivity tests fail at the end of the Wireguard init process or for an extended period during the container runtime.</p> </li> <li> <p>Enable Unbound by setting to <code>true</code> when VPN is not active.</p> </li> <li> <p>Possible values are <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>8.8.8.8</code> is to use a plain old nameserver. The value <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> </ol> <pre><code>services:\n  app:\n    hostname: container-name.internal #(18)\n    environment:\n      - VPN_ENABLED=true #(5)\n      - VPN_CONF=wg0 #(8)\n      - VPN_PROVIDER=proton #(4)\n      - VPN_LAN_NETWORK=192.168.1.0/24 #(1)\n      - VPN_LAN_LEAK_ENABLED=false #(10)\n      - VPN_EXPOSE_PORTS_ON_LAN #(2)\n      - VPN_AUTO_PORT_FORWARD=true #(6)\n      - VPN_AUTO_PORT_FORWARD_TO_PORTS= #(15)\n      - VPN_FIREWALL_TYPE=auto #(17)\n      - VPN_HEALTHCHECK_ENABLED=false #(20)\n      - VPN_NAMESERVERS= #(16)\n      - PRIVOXY_ENABLED=false #(19)\n      - UNBOUND_ENABLED=false #(21)\n      - UNBOUND_NAMESERVERS #(22)\n    cap_add:\n      - NET_ADMIN\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1 #(12)\n      - net.ipv6.conf.all.disable_ipv6=1 #(3)\n    devices:\n      - /dev/net/tun:/dev/net/tun # OPTIONAL(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui. On MacOS set it to <code>192.168.65.0/24</code> (Verify with your settings [Resources &gt; Network &gt; Docker subnet]).</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>. Affiliate links: Proton VPN Proton Unlimited Private Internet Access</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> (for PIA this is done automatically, see <code>VPN_PROVIDER</code> variable) located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32 in most cases\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>DANGEROUS! Don't enable unless you know what you are doing!</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>Some of the possible values are for example <code>wg</code>, <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>wg</code> will use the nameservers from the <code>wg0.conf</code> file. A value in the format <code>8.8.8.8</code> is to use a plain old nameserver. A value in the format <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>If you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice.</p> </li> <li> <p>This will start Privoxy on the default port 8118 when set to <code>true</code>. By default Privoxy is not exposed on the LAN, so if you need that, you'll have to add <code>VPN_EXPOSE_PORTS_ON_LAN=8118/tcp,8118/udp</code>.</p> </li> <li> <p>Enabling this will bring down the container if the connectivity tests fail at the end of the Wireguard init process or for an extended period during the container runtime.</p> </li> <li> <p>Enable Unbound by setting to <code>true</code> when VPN is not active.</p> </li> <li> <p>Possible values are <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>8.8.8.8</code> is to use a plain old nameserver. The value <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> </ol> clicompose <pre><code>docker run --rm \\\n    --hostname container-name.internal \\ #(18)\n    -e VPN_ENABLED=\"true\" \\ #(5)\n    -e VPN_CONF=\"wg0\" \\ #(8)\n    -e VPN_PROVIDER=\"pia\" \\ #(4)\n    -e VPN_LAN_NETWORK=\"192.168.1.0/24\" \\ #(1)\n    -e VPN_LAN_LEAK_ENABLED=\"false\" \\ #(10)\n    -e VPN_EXPOSE_PORTS_ON_LAN=\"\" \\ #(2)\n    -e VPN_AUTO_PORT_FORWARD=\"true\" \\ #(6)\n    -e VPN_AUTO_PORT_FORWARD_TO_PORTS=\"\" \\ #(15)\n    -e VPN_FIREWALL_TYPE=\"auto\" \\ #(17)\n    -e VPN_HEALTHCHECK_ENABLED=\"false\" \\ #(20)\n    -e VPN_NAMESERVERS=\"\" \\ #(16)\n    -e VPN_PIA_USER=\"\" \\ #(11)\n    -e VPN_PIA_PASS=\"\" \\ #(11)\n    -e VPN_PIA_PREFERRED_REGION=\"\" \\ #(7)\n    -e VPN_PIA_DIP_TOKEN=\"no\" \\ #(13)\n    -e VPN_PIA_PORT_FORWARD_PERSIST=\"false\" \\ #(14)\n    -e PRIVOXY_ENABLED=\"false\" \\ #(19)\n    -e UNBOUND_ENABLED=\"false\" \\ #(21)\n    -e UNBOUND_NAMESERVERS=\"\" \\ #(22)\n    --cap-add=NET_ADMIN \\\n    --sysctl=\"net.ipv4.conf.all.src_valid_mark=1\" \\ #(12)\n    --sysctl=\"net.ipv6.conf.all.disable_ipv6=1\" \\ #(3)\n    --device /dev/net/tun:/dev/net/tun \\ # OPTIONAL(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui. On MacOS set it to <code>192.168.65.0/24</code> (Verify with your settings [Resources &gt; Network &gt; Docker subnet]).</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>. Affiliate links: Proton VPN Proton Unlimited Private Internet Access</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> (for PIA this is done automatically, see <code>VPN_PROVIDER</code> variable) located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32 in most cases\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>DANGEROUS! Don't enable unless you know what you are doing!</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>Some of the possible values are for example <code>wg</code>, <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>wg</code> will use the nameservers from the <code>wg0.conf</code> file. A value in the format <code>8.8.8.8</code> is to use a plain old nameserver. A value in the format <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>If you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice.</p> </li> <li> <p>This will start Privoxy on the default port 8118 when set to <code>true</code>. By default Privoxy is not exposed on the LAN, so if you need that, you'll have to add <code>VPN_EXPOSE_PORTS_ON_LAN=8118/tcp,8118/udp</code>.</p> </li> <li> <p>Enabling this will bring down the container if the connectivity tests fail at the end of the Wireguard init process or for an extended period during the container runtime.</p> </li> <li> <p>Enable Unbound by setting to <code>true</code> when VPN is not active.</p> </li> <li> <p>Possible values are <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>8.8.8.8</code> is to use a plain old nameserver. The value <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> </ol> <pre><code>services:\n  app:\n    hostname: container-name.internal #(18)\n    environment:\n      - VPN_ENABLED=true #(5)\n      - VPN_CONF=wg0 #(8)\n      - VPN_PROVIDER=pia #(4)\n      - VPN_LAN_NETWORK=192.168.1.0/24 #(1)\n      - VPN_LAN_LEAK_ENABLED=false #(10)\n      - VPN_EXPOSE_PORTS_ON_LAN #(2)\n      - VPN_AUTO_PORT_FORWARD=true #(6)\n      - VPN_AUTO_PORT_FORWARD_TO_PORTS= #(15)\n      - VPN_FIREWALL_TYPE=auto #(17)\n      - VPN_HEALTHCHECK_ENABLED=false #(20)\n      - VPN_NAMESERVERS= #(16)\n      - VPN_PIA_USER #(11)\n      - VPN_PIA_PASS #(11)\n      - VPN_PIA_PREFERRED_REGION #(7)\n      - VPN_PIA_DIP_TOKEN=no #(13)\n      - VPN_PIA_PORT_FORWARD_PERSIST=false #(14)\n      - PRIVOXY_ENABLED=false #(19)\n      - UNBOUND_ENABLED=false #(21)\n      - UNBOUND_NAMESERVERS #(22)\n    cap_add:\n      - NET_ADMIN\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1 #(12)\n      - net.ipv6.conf.all.disable_ipv6=1 #(3)\n    devices:\n      - /dev/net/tun:/dev/net/tun # OPTIONAL(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui. On MacOS set it to <code>192.168.65.0/24</code> (Verify with your settings [Resources &gt; Network &gt; Docker subnet]).</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>. Affiliate links: Proton VPN Proton Unlimited Private Internet Access</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> (for PIA this is done automatically, see <code>VPN_PROVIDER</code> variable) located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32 in most cases\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>DANGEROUS! Don't enable unless you know what you are doing!</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>Some of the possible values are for example <code>wg</code>, <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>wg</code> will use the nameservers from the <code>wg0.conf</code> file. A value in the format <code>8.8.8.8</code> is to use a plain old nameserver. A value in the format <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>If you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice.</p> </li> <li> <p>This will start Privoxy on the default port 8118 when set to <code>true</code>. By default Privoxy is not exposed on the LAN, so if you need that, you'll have to add <code>VPN_EXPOSE_PORTS_ON_LAN=8118/tcp,8118/udp</code>.</p> </li> <li> <p>Enabling this will bring down the container if the connectivity tests fail at the end of the Wireguard init process or for an extended period during the container runtime.</p> </li> <li> <p>Enable Unbound by setting to <code>true</code> when VPN is not active.</p> </li> <li> <p>Possible values are <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>8.8.8.8</code> is to use a plain old nameserver. The value <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> </ol>"},{"location":"containers/tautulli/","title":"hotio/tautulli","text":"<p> GitHub ghcr.io</p>"},{"location":"containers/tautulli/#starting-the-container","title":"Starting the container","text":"clicompose <pre><code>docker run --rm \\\n    --name tautulli \\\n    -p 8181:8181 \\\n    -e PUID=1000 \\\n    -e PGID=1000 \\\n    -e UMASK=002 \\\n    -e TZ=\"Etc/UTC\" \\\n    -e WEBUI_PORTS=\"8181/tcp,8181/udp\" \\\n    -v /&lt;host_folder_config&gt;:/config \\\n    ghcr.io/hotio/tautulli\n</code></pre> <pre><code>services:\n  tautulli:\n    container_name: tautulli\n    image: ghcr.io/hotio/tautulli\n    ports:\n      - \"8181:8181\"\n    environment:\n      - PUID=1000\n      - PGID=1000\n      - UMASK=002\n      - TZ=Etc/UTC\n      - WEBUI_PORTS=8181/tcp,8181/udp\n    volumes:\n      - /&lt;host_folder_config&gt;:/config\n</code></pre>"},{"location":"containers/tautulli/#tags","title":"Tags","text":"Tags Description Last Updated Age"},{"location":"containers/tautulli/#wireguard","title":"WireGuard","text":"<p>Info</p> <p>This image includes VPN support. The cli/compose examples below are environment variables and settings complementary to the app image examples, this means you'll have to add/merge the stuff below with the stuff above. In case you are still in need of a VPN, consider using my affiliate links for Proton VPN, Proton Unlimited or Private Internet Access.</p> <p> </p> genericprotonpia clicompose <pre><code>docker run --rm \\\n    --hostname container-name.internal \\ #(18)\n    -e VPN_ENABLED=\"true\" \\ #(5)\n    -e VPN_CONF=\"wg0\" \\ #(8)\n    -e VPN_PROVIDER=\"generic\" \\ #(4)\n    -e VPN_LAN_NETWORK=\"192.168.1.0/24\" \\ #(1)\n    -e VPN_LAN_LEAK_ENABLED=\"false\" \\ #(10)\n    -e VPN_EXPOSE_PORTS_ON_LAN=\"\" \\ #(2)\n    -e VPN_AUTO_PORT_FORWARD=\"false\" \\ #(6)\n    -e VPN_AUTO_PORT_FORWARD_TO_PORTS=\"\" \\ #(15)\n    -e VPN_FIREWALL_TYPE=\"auto\" \\ #(17)\n    -e VPN_HEALTHCHECK_ENABLED=\"false\" \\ #(20)\n    -e VPN_NAMESERVERS=\"\" \\ #(16)\n    -e PRIVOXY_ENABLED=\"false\" \\ #(19)\n    -e UNBOUND_ENABLED=\"false\" \\ #(21)\n    -e UNBOUND_NAMESERVERS=\"\" \\ #(22)\n    --cap-add=NET_ADMIN \\\n    --sysctl=\"net.ipv4.conf.all.src_valid_mark=1\" \\ #(12)\n    --sysctl=\"net.ipv6.conf.all.disable_ipv6=1\" \\ #(3)\n    --device /dev/net/tun:/dev/net/tun \\ # OPTIONAL(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui. On MacOS set it to <code>192.168.65.0/24</code> (Verify with your settings [Resources &gt; Network &gt; Docker subnet]).</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>. Affiliate links: Proton VPN Proton Unlimited Private Internet Access</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> (for PIA this is done automatically, see <code>VPN_PROVIDER</code> variable) located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32 in most cases\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>DANGEROUS! Don't enable unless you know what you are doing!</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>Some of the possible values are for example <code>wg</code>, <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>wg</code> will use the nameservers from the <code>wg0.conf</code> file. A value in the format <code>8.8.8.8</code> is to use a plain old nameserver. A value in the format <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>If you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice.</p> </li> <li> <p>This will start Privoxy on the default port 8118 when set to <code>true</code>. By default Privoxy is not exposed on the LAN, so if you need that, you'll have to add <code>VPN_EXPOSE_PORTS_ON_LAN=8118/tcp,8118/udp</code>.</p> </li> <li> <p>Enabling this will bring down the container if the connectivity tests fail at the end of the Wireguard init process or for an extended period during the container runtime.</p> </li> <li> <p>Enable Unbound by setting to <code>true</code> when VPN is not active.</p> </li> <li> <p>Possible values are <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>8.8.8.8</code> is to use a plain old nameserver. The value <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> </ol> <pre><code>services:\n  app:\n    hostname: container-name.internal #(18)\n    environment:\n      - VPN_ENABLED=true #(5)\n      - VPN_CONF=wg0 #(8)\n      - VPN_PROVIDER=generic #(4)\n      - VPN_LAN_NETWORK=192.168.1.0/24 #(1)\n      - VPN_LAN_LEAK_ENABLED=false #(10)\n      - VPN_EXPOSE_PORTS_ON_LAN #(2)\n      - VPN_AUTO_PORT_FORWARD=false #(6)\n      - VPN_AUTO_PORT_FORWARD_TO_PORTS= #(15)\n      - VPN_FIREWALL_TYPE=auto #(17)\n      - VPN_HEALTHCHECK_ENABLED=false #(20)\n      - VPN_NAMESERVERS= #(16)\n      - PRIVOXY_ENABLED=false #(19)\n      - UNBOUND_ENABLED=false #(21)\n      - UNBOUND_NAMESERVERS #(22)\n    cap_add:\n      - NET_ADMIN\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1 #(12)\n      - net.ipv6.conf.all.disable_ipv6=1 #(3)\n    devices:\n      - /dev/net/tun:/dev/net/tun # OPTIONAL(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui. On MacOS set it to <code>192.168.65.0/24</code> (Verify with your settings [Resources &gt; Network &gt; Docker subnet]).</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>. Affiliate links: Proton VPN Proton Unlimited Private Internet Access</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> (for PIA this is done automatically, see <code>VPN_PROVIDER</code> variable) located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32 in most cases\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>DANGEROUS! Don't enable unless you know what you are doing!</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>Some of the possible values are for example <code>wg</code>, <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>wg</code> will use the nameservers from the <code>wg0.conf</code> file. A value in the format <code>8.8.8.8</code> is to use a plain old nameserver. A value in the format <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>If you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice.</p> </li> <li> <p>This will start Privoxy on the default port 8118 when set to <code>true</code>. By default Privoxy is not exposed on the LAN, so if you need that, you'll have to add <code>VPN_EXPOSE_PORTS_ON_LAN=8118/tcp,8118/udp</code>.</p> </li> <li> <p>Enabling this will bring down the container if the connectivity tests fail at the end of the Wireguard init process or for an extended period during the container runtime.</p> </li> <li> <p>Enable Unbound by setting to <code>true</code> when VPN is not active.</p> </li> <li> <p>Possible values are <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>8.8.8.8</code> is to use a plain old nameserver. The value <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> </ol> clicompose <pre><code>docker run --rm \\\n    --hostname container-name.internal \\ #(18)\n    -e VPN_ENABLED=\"true\" \\ #(5)\n    -e VPN_CONF=\"wg0\" \\ #(8)\n    -e VPN_PROVIDER=\"proton\" \\ #(4)\n    -e VPN_LAN_NETWORK=\"192.168.1.0/24\" \\ #(1)\n    -e VPN_LAN_LEAK_ENABLED=\"false\" \\ #(10)\n    -e VPN_EXPOSE_PORTS_ON_LAN=\"\" \\ #(2)\n    -e VPN_AUTO_PORT_FORWARD=\"true\" \\ #(6)\n    -e VPN_AUTO_PORT_FORWARD_TO_PORTS=\"\" \\ #(15)\n    -e VPN_FIREWALL_TYPE=\"auto\" \\ #(17)\n    -e VPN_HEALTHCHECK_ENABLED=\"false\" \\ #(20)\n    -e VPN_NAMESERVERS=\"\" \\ #(16)\n    -e PRIVOXY_ENABLED=\"false\" \\ #(19)\n    -e UNBOUND_ENABLED=\"false\" \\ #(21)\n    -e UNBOUND_NAMESERVERS=\"\" \\ #(22)\n    --cap-add=NET_ADMIN \\\n    --sysctl=\"net.ipv4.conf.all.src_valid_mark=1\" \\ #(12)\n    --sysctl=\"net.ipv6.conf.all.disable_ipv6=1\" \\ #(3)\n    --device /dev/net/tun:/dev/net/tun \\ # OPTIONAL(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui. On MacOS set it to <code>192.168.65.0/24</code> (Verify with your settings [Resources &gt; Network &gt; Docker subnet]).</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>. Affiliate links: Proton VPN Proton Unlimited Private Internet Access</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> (for PIA this is done automatically, see <code>VPN_PROVIDER</code> variable) located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32 in most cases\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>DANGEROUS! Don't enable unless you know what you are doing!</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>Some of the possible values are for example <code>wg</code>, <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>wg</code> will use the nameservers from the <code>wg0.conf</code> file. A value in the format <code>8.8.8.8</code> is to use a plain old nameserver. A value in the format <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>If you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice.</p> </li> <li> <p>This will start Privoxy on the default port 8118 when set to <code>true</code>. By default Privoxy is not exposed on the LAN, so if you need that, you'll have to add <code>VPN_EXPOSE_PORTS_ON_LAN=8118/tcp,8118/udp</code>.</p> </li> <li> <p>Enabling this will bring down the container if the connectivity tests fail at the end of the Wireguard init process or for an extended period during the container runtime.</p> </li> <li> <p>Enable Unbound by setting to <code>true</code> when VPN is not active.</p> </li> <li> <p>Possible values are <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>8.8.8.8</code> is to use a plain old nameserver. The value <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> </ol> <pre><code>services:\n  app:\n    hostname: container-name.internal #(18)\n    environment:\n      - VPN_ENABLED=true #(5)\n      - VPN_CONF=wg0 #(8)\n      - VPN_PROVIDER=proton #(4)\n      - VPN_LAN_NETWORK=192.168.1.0/24 #(1)\n      - VPN_LAN_LEAK_ENABLED=false #(10)\n      - VPN_EXPOSE_PORTS_ON_LAN #(2)\n      - VPN_AUTO_PORT_FORWARD=true #(6)\n      - VPN_AUTO_PORT_FORWARD_TO_PORTS= #(15)\n      - VPN_FIREWALL_TYPE=auto #(17)\n      - VPN_HEALTHCHECK_ENABLED=false #(20)\n      - VPN_NAMESERVERS= #(16)\n      - PRIVOXY_ENABLED=false #(19)\n      - UNBOUND_ENABLED=false #(21)\n      - UNBOUND_NAMESERVERS #(22)\n    cap_add:\n      - NET_ADMIN\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1 #(12)\n      - net.ipv6.conf.all.disable_ipv6=1 #(3)\n    devices:\n      - /dev/net/tun:/dev/net/tun # OPTIONAL(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui. On MacOS set it to <code>192.168.65.0/24</code> (Verify with your settings [Resources &gt; Network &gt; Docker subnet]).</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>. Affiliate links: Proton VPN Proton Unlimited Private Internet Access</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> (for PIA this is done automatically, see <code>VPN_PROVIDER</code> variable) located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32 in most cases\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>DANGEROUS! Don't enable unless you know what you are doing!</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>Some of the possible values are for example <code>wg</code>, <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>wg</code> will use the nameservers from the <code>wg0.conf</code> file. A value in the format <code>8.8.8.8</code> is to use a plain old nameserver. A value in the format <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>If you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice.</p> </li> <li> <p>This will start Privoxy on the default port 8118 when set to <code>true</code>. By default Privoxy is not exposed on the LAN, so if you need that, you'll have to add <code>VPN_EXPOSE_PORTS_ON_LAN=8118/tcp,8118/udp</code>.</p> </li> <li> <p>Enabling this will bring down the container if the connectivity tests fail at the end of the Wireguard init process or for an extended period during the container runtime.</p> </li> <li> <p>Enable Unbound by setting to <code>true</code> when VPN is not active.</p> </li> <li> <p>Possible values are <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>8.8.8.8</code> is to use a plain old nameserver. The value <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> </ol> clicompose <pre><code>docker run --rm \\\n    --hostname container-name.internal \\ #(18)\n    -e VPN_ENABLED=\"true\" \\ #(5)\n    -e VPN_CONF=\"wg0\" \\ #(8)\n    -e VPN_PROVIDER=\"pia\" \\ #(4)\n    -e VPN_LAN_NETWORK=\"192.168.1.0/24\" \\ #(1)\n    -e VPN_LAN_LEAK_ENABLED=\"false\" \\ #(10)\n    -e VPN_EXPOSE_PORTS_ON_LAN=\"\" \\ #(2)\n    -e VPN_AUTO_PORT_FORWARD=\"true\" \\ #(6)\n    -e VPN_AUTO_PORT_FORWARD_TO_PORTS=\"\" \\ #(15)\n    -e VPN_FIREWALL_TYPE=\"auto\" \\ #(17)\n    -e VPN_HEALTHCHECK_ENABLED=\"false\" \\ #(20)\n    -e VPN_NAMESERVERS=\"\" \\ #(16)\n    -e VPN_PIA_USER=\"\" \\ #(11)\n    -e VPN_PIA_PASS=\"\" \\ #(11)\n    -e VPN_PIA_PREFERRED_REGION=\"\" \\ #(7)\n    -e VPN_PIA_DIP_TOKEN=\"no\" \\ #(13)\n    -e VPN_PIA_PORT_FORWARD_PERSIST=\"false\" \\ #(14)\n    -e PRIVOXY_ENABLED=\"false\" \\ #(19)\n    -e UNBOUND_ENABLED=\"false\" \\ #(21)\n    -e UNBOUND_NAMESERVERS=\"\" \\ #(22)\n    --cap-add=NET_ADMIN \\\n    --sysctl=\"net.ipv4.conf.all.src_valid_mark=1\" \\ #(12)\n    --sysctl=\"net.ipv6.conf.all.disable_ipv6=1\" \\ #(3)\n    --device /dev/net/tun:/dev/net/tun \\ # OPTIONAL(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui. On MacOS set it to <code>192.168.65.0/24</code> (Verify with your settings [Resources &gt; Network &gt; Docker subnet]).</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>. Affiliate links: Proton VPN Proton Unlimited Private Internet Access</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> (for PIA this is done automatically, see <code>VPN_PROVIDER</code> variable) located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32 in most cases\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>DANGEROUS! Don't enable unless you know what you are doing!</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>Some of the possible values are for example <code>wg</code>, <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>wg</code> will use the nameservers from the <code>wg0.conf</code> file. A value in the format <code>8.8.8.8</code> is to use a plain old nameserver. A value in the format <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>If you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice.</p> </li> <li> <p>This will start Privoxy on the default port 8118 when set to <code>true</code>. By default Privoxy is not exposed on the LAN, so if you need that, you'll have to add <code>VPN_EXPOSE_PORTS_ON_LAN=8118/tcp,8118/udp</code>.</p> </li> <li> <p>Enabling this will bring down the container if the connectivity tests fail at the end of the Wireguard init process or for an extended period during the container runtime.</p> </li> <li> <p>Enable Unbound by setting to <code>true</code> when VPN is not active.</p> </li> <li> <p>Possible values are <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>8.8.8.8</code> is to use a plain old nameserver. The value <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> </ol> <pre><code>services:\n  app:\n    hostname: container-name.internal #(18)\n    environment:\n      - VPN_ENABLED=true #(5)\n      - VPN_CONF=wg0 #(8)\n      - VPN_PROVIDER=pia #(4)\n      - VPN_LAN_NETWORK=192.168.1.0/24 #(1)\n      - VPN_LAN_LEAK_ENABLED=false #(10)\n      - VPN_EXPOSE_PORTS_ON_LAN #(2)\n      - VPN_AUTO_PORT_FORWARD=true #(6)\n      - VPN_AUTO_PORT_FORWARD_TO_PORTS= #(15)\n      - VPN_FIREWALL_TYPE=auto #(17)\n      - VPN_HEALTHCHECK_ENABLED=false #(20)\n      - VPN_NAMESERVERS= #(16)\n      - VPN_PIA_USER #(11)\n      - VPN_PIA_PASS #(11)\n      - VPN_PIA_PREFERRED_REGION #(7)\n      - VPN_PIA_DIP_TOKEN=no #(13)\n      - VPN_PIA_PORT_FORWARD_PERSIST=false #(14)\n      - PRIVOXY_ENABLED=false #(19)\n      - UNBOUND_ENABLED=false #(21)\n      - UNBOUND_NAMESERVERS #(22)\n    cap_add:\n      - NET_ADMIN\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1 #(12)\n      - net.ipv6.conf.all.disable_ipv6=1 #(3)\n    devices:\n      - /dev/net/tun:/dev/net/tun # OPTIONAL(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui. On MacOS set it to <code>192.168.65.0/24</code> (Verify with your settings [Resources &gt; Network &gt; Docker subnet]).</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>. Affiliate links: Proton VPN Proton Unlimited Private Internet Access</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> (for PIA this is done automatically, see <code>VPN_PROVIDER</code> variable) located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32 in most cases\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>DANGEROUS! Don't enable unless you know what you are doing!</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>Some of the possible values are for example <code>wg</code>, <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>wg</code> will use the nameservers from the <code>wg0.conf</code> file. A value in the format <code>8.8.8.8</code> is to use a plain old nameserver. A value in the format <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>If you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice.</p> </li> <li> <p>This will start Privoxy on the default port 8118 when set to <code>true</code>. By default Privoxy is not exposed on the LAN, so if you need that, you'll have to add <code>VPN_EXPOSE_PORTS_ON_LAN=8118/tcp,8118/udp</code>.</p> </li> <li> <p>Enabling this will bring down the container if the connectivity tests fail at the end of the Wireguard init process or for an extended period during the container runtime.</p> </li> <li> <p>Enable Unbound by setting to <code>true</code> when VPN is not active.</p> </li> <li> <p>Possible values are <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>8.8.8.8</code> is to use a plain old nameserver. The value <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> </ol>"},{"location":"containers/unpackerr/","title":"hotio/unpackerr","text":"<p> GitHub ghcr.io</p>"},{"location":"containers/unpackerr/#starting-the-container","title":"Starting the container","text":"clicompose <pre><code>docker run --rm \\\n    --name unpackerr \\\n    -e PUID=1000 \\\n    -e PGID=1000 \\\n    -e UMASK=002 \\\n    -e TZ=\"Etc/UTC\" \\\n    -v /&lt;host_folder_config&gt;:/config \\\n    -v /&lt;host_folder_data&gt;:/data \\\n    ghcr.io/hotio/unpackerr\n</code></pre> <pre><code>services:\n  unpackerr:\n    container_name: unpackerr\n    image: ghcr.io/hotio/unpackerr\n    environment:\n      - PUID=1000\n      - PGID=1000\n      - UMASK=002\n      - TZ=Etc/UTC\n    volumes:\n      - /&lt;host_folder_config&gt;:/config\n      - /&lt;host_folder_data&gt;:/data\n</code></pre>"},{"location":"containers/unpackerr/#tags","title":"Tags","text":"Tags Description Last Updated Age"},{"location":"containers/unpackerr/#configuration","title":"Configuration","text":"<p>You can use docker environment variables or a configuration file that should be stored in <code>/config/unpackerr.conf</code>. Take a look at the upstream project page for info on how to configure Unpackerr.</p>"},{"location":"containers/unpackerr/#wireguard","title":"WireGuard","text":"<p>Info</p> <p>This image includes VPN support. The cli/compose examples below are environment variables and settings complementary to the app image examples, this means you'll have to add/merge the stuff below with the stuff above. In case you are still in need of a VPN, consider using my affiliate links for Proton VPN, Proton Unlimited or Private Internet Access.</p> <p> </p> genericprotonpia clicompose <pre><code>docker run --rm \\\n    --hostname container-name.internal \\ #(18)\n    -e VPN_ENABLED=\"true\" \\ #(5)\n    -e VPN_CONF=\"wg0\" \\ #(8)\n    -e VPN_PROVIDER=\"generic\" \\ #(4)\n    -e VPN_LAN_NETWORK=\"192.168.1.0/24\" \\ #(1)\n    -e VPN_LAN_LEAK_ENABLED=\"false\" \\ #(10)\n    -e VPN_EXPOSE_PORTS_ON_LAN=\"\" \\ #(2)\n    -e VPN_AUTO_PORT_FORWARD=\"false\" \\ #(6)\n    -e VPN_AUTO_PORT_FORWARD_TO_PORTS=\"\" \\ #(15)\n    -e VPN_FIREWALL_TYPE=\"auto\" \\ #(17)\n    -e VPN_HEALTHCHECK_ENABLED=\"false\" \\ #(20)\n    -e VPN_NAMESERVERS=\"\" \\ #(16)\n    -e PRIVOXY_ENABLED=\"false\" \\ #(19)\n    -e UNBOUND_ENABLED=\"false\" \\ #(21)\n    -e UNBOUND_NAMESERVERS=\"\" \\ #(22)\n    --cap-add=NET_ADMIN \\\n    --sysctl=\"net.ipv4.conf.all.src_valid_mark=1\" \\ #(12)\n    --sysctl=\"net.ipv6.conf.all.disable_ipv6=1\" \\ #(3)\n    --device /dev/net/tun:/dev/net/tun \\ # OPTIONAL(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui. On MacOS set it to <code>192.168.65.0/24</code> (Verify with your settings [Resources &gt; Network &gt; Docker subnet]).</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>. Affiliate links: Proton VPN Proton Unlimited Private Internet Access</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> (for PIA this is done automatically, see <code>VPN_PROVIDER</code> variable) located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32 in most cases\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>DANGEROUS! Don't enable unless you know what you are doing!</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>Some of the possible values are for example <code>wg</code>, <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>wg</code> will use the nameservers from the <code>wg0.conf</code> file. A value in the format <code>8.8.8.8</code> is to use a plain old nameserver. A value in the format <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>If you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice.</p> </li> <li> <p>This will start Privoxy on the default port 8118 when set to <code>true</code>. By default Privoxy is not exposed on the LAN, so if you need that, you'll have to add <code>VPN_EXPOSE_PORTS_ON_LAN=8118/tcp,8118/udp</code>.</p> </li> <li> <p>Enabling this will bring down the container if the connectivity tests fail at the end of the Wireguard init process or for an extended period during the container runtime.</p> </li> <li> <p>Enable Unbound by setting to <code>true</code> when VPN is not active.</p> </li> <li> <p>Possible values are <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>8.8.8.8</code> is to use a plain old nameserver. The value <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> </ol> <pre><code>services:\n  app:\n    hostname: container-name.internal #(18)\n    environment:\n      - VPN_ENABLED=true #(5)\n      - VPN_CONF=wg0 #(8)\n      - VPN_PROVIDER=generic #(4)\n      - VPN_LAN_NETWORK=192.168.1.0/24 #(1)\n      - VPN_LAN_LEAK_ENABLED=false #(10)\n      - VPN_EXPOSE_PORTS_ON_LAN #(2)\n      - VPN_AUTO_PORT_FORWARD=false #(6)\n      - VPN_AUTO_PORT_FORWARD_TO_PORTS= #(15)\n      - VPN_FIREWALL_TYPE=auto #(17)\n      - VPN_HEALTHCHECK_ENABLED=false #(20)\n      - VPN_NAMESERVERS= #(16)\n      - PRIVOXY_ENABLED=false #(19)\n      - UNBOUND_ENABLED=false #(21)\n      - UNBOUND_NAMESERVERS #(22)\n    cap_add:\n      - NET_ADMIN\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1 #(12)\n      - net.ipv6.conf.all.disable_ipv6=1 #(3)\n    devices:\n      - /dev/net/tun:/dev/net/tun # OPTIONAL(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui. On MacOS set it to <code>192.168.65.0/24</code> (Verify with your settings [Resources &gt; Network &gt; Docker subnet]).</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>. Affiliate links: Proton VPN Proton Unlimited Private Internet Access</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> (for PIA this is done automatically, see <code>VPN_PROVIDER</code> variable) located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32 in most cases\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>DANGEROUS! Don't enable unless you know what you are doing!</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>Some of the possible values are for example <code>wg</code>, <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>wg</code> will use the nameservers from the <code>wg0.conf</code> file. A value in the format <code>8.8.8.8</code> is to use a plain old nameserver. A value in the format <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>If you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice.</p> </li> <li> <p>This will start Privoxy on the default port 8118 when set to <code>true</code>. By default Privoxy is not exposed on the LAN, so if you need that, you'll have to add <code>VPN_EXPOSE_PORTS_ON_LAN=8118/tcp,8118/udp</code>.</p> </li> <li> <p>Enabling this will bring down the container if the connectivity tests fail at the end of the Wireguard init process or for an extended period during the container runtime.</p> </li> <li> <p>Enable Unbound by setting to <code>true</code> when VPN is not active.</p> </li> <li> <p>Possible values are <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>8.8.8.8</code> is to use a plain old nameserver. The value <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> </ol> clicompose <pre><code>docker run --rm \\\n    --hostname container-name.internal \\ #(18)\n    -e VPN_ENABLED=\"true\" \\ #(5)\n    -e VPN_CONF=\"wg0\" \\ #(8)\n    -e VPN_PROVIDER=\"proton\" \\ #(4)\n    -e VPN_LAN_NETWORK=\"192.168.1.0/24\" \\ #(1)\n    -e VPN_LAN_LEAK_ENABLED=\"false\" \\ #(10)\n    -e VPN_EXPOSE_PORTS_ON_LAN=\"\" \\ #(2)\n    -e VPN_AUTO_PORT_FORWARD=\"true\" \\ #(6)\n    -e VPN_AUTO_PORT_FORWARD_TO_PORTS=\"\" \\ #(15)\n    -e VPN_FIREWALL_TYPE=\"auto\" \\ #(17)\n    -e VPN_HEALTHCHECK_ENABLED=\"false\" \\ #(20)\n    -e VPN_NAMESERVERS=\"\" \\ #(16)\n    -e PRIVOXY_ENABLED=\"false\" \\ #(19)\n    -e UNBOUND_ENABLED=\"false\" \\ #(21)\n    -e UNBOUND_NAMESERVERS=\"\" \\ #(22)\n    --cap-add=NET_ADMIN \\\n    --sysctl=\"net.ipv4.conf.all.src_valid_mark=1\" \\ #(12)\n    --sysctl=\"net.ipv6.conf.all.disable_ipv6=1\" \\ #(3)\n    --device /dev/net/tun:/dev/net/tun \\ # OPTIONAL(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui. On MacOS set it to <code>192.168.65.0/24</code> (Verify with your settings [Resources &gt; Network &gt; Docker subnet]).</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>. Affiliate links: Proton VPN Proton Unlimited Private Internet Access</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> (for PIA this is done automatically, see <code>VPN_PROVIDER</code> variable) located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32 in most cases\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>DANGEROUS! Don't enable unless you know what you are doing!</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>Some of the possible values are for example <code>wg</code>, <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>wg</code> will use the nameservers from the <code>wg0.conf</code> file. A value in the format <code>8.8.8.8</code> is to use a plain old nameserver. A value in the format <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>If you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice.</p> </li> <li> <p>This will start Privoxy on the default port 8118 when set to <code>true</code>. By default Privoxy is not exposed on the LAN, so if you need that, you'll have to add <code>VPN_EXPOSE_PORTS_ON_LAN=8118/tcp,8118/udp</code>.</p> </li> <li> <p>Enabling this will bring down the container if the connectivity tests fail at the end of the Wireguard init process or for an extended period during the container runtime.</p> </li> <li> <p>Enable Unbound by setting to <code>true</code> when VPN is not active.</p> </li> <li> <p>Possible values are <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>8.8.8.8</code> is to use a plain old nameserver. The value <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> </ol> <pre><code>services:\n  app:\n    hostname: container-name.internal #(18)\n    environment:\n      - VPN_ENABLED=true #(5)\n      - VPN_CONF=wg0 #(8)\n      - VPN_PROVIDER=proton #(4)\n      - VPN_LAN_NETWORK=192.168.1.0/24 #(1)\n      - VPN_LAN_LEAK_ENABLED=false #(10)\n      - VPN_EXPOSE_PORTS_ON_LAN #(2)\n      - VPN_AUTO_PORT_FORWARD=true #(6)\n      - VPN_AUTO_PORT_FORWARD_TO_PORTS= #(15)\n      - VPN_FIREWALL_TYPE=auto #(17)\n      - VPN_HEALTHCHECK_ENABLED=false #(20)\n      - VPN_NAMESERVERS= #(16)\n      - PRIVOXY_ENABLED=false #(19)\n      - UNBOUND_ENABLED=false #(21)\n      - UNBOUND_NAMESERVERS #(22)\n    cap_add:\n      - NET_ADMIN\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1 #(12)\n      - net.ipv6.conf.all.disable_ipv6=1 #(3)\n    devices:\n      - /dev/net/tun:/dev/net/tun # OPTIONAL(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui. On MacOS set it to <code>192.168.65.0/24</code> (Verify with your settings [Resources &gt; Network &gt; Docker subnet]).</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>. Affiliate links: Proton VPN Proton Unlimited Private Internet Access</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> (for PIA this is done automatically, see <code>VPN_PROVIDER</code> variable) located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32 in most cases\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>DANGEROUS! Don't enable unless you know what you are doing!</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>Some of the possible values are for example <code>wg</code>, <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>wg</code> will use the nameservers from the <code>wg0.conf</code> file. A value in the format <code>8.8.8.8</code> is to use a plain old nameserver. A value in the format <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>If you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice.</p> </li> <li> <p>This will start Privoxy on the default port 8118 when set to <code>true</code>. By default Privoxy is not exposed on the LAN, so if you need that, you'll have to add <code>VPN_EXPOSE_PORTS_ON_LAN=8118/tcp,8118/udp</code>.</p> </li> <li> <p>Enabling this will bring down the container if the connectivity tests fail at the end of the Wireguard init process or for an extended period during the container runtime.</p> </li> <li> <p>Enable Unbound by setting to <code>true</code> when VPN is not active.</p> </li> <li> <p>Possible values are <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>8.8.8.8</code> is to use a plain old nameserver. The value <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> </ol> clicompose <pre><code>docker run --rm \\\n    --hostname container-name.internal \\ #(18)\n    -e VPN_ENABLED=\"true\" \\ #(5)\n    -e VPN_CONF=\"wg0\" \\ #(8)\n    -e VPN_PROVIDER=\"pia\" \\ #(4)\n    -e VPN_LAN_NETWORK=\"192.168.1.0/24\" \\ #(1)\n    -e VPN_LAN_LEAK_ENABLED=\"false\" \\ #(10)\n    -e VPN_EXPOSE_PORTS_ON_LAN=\"\" \\ #(2)\n    -e VPN_AUTO_PORT_FORWARD=\"true\" \\ #(6)\n    -e VPN_AUTO_PORT_FORWARD_TO_PORTS=\"\" \\ #(15)\n    -e VPN_FIREWALL_TYPE=\"auto\" \\ #(17)\n    -e VPN_HEALTHCHECK_ENABLED=\"false\" \\ #(20)\n    -e VPN_NAMESERVERS=\"\" \\ #(16)\n    -e VPN_PIA_USER=\"\" \\ #(11)\n    -e VPN_PIA_PASS=\"\" \\ #(11)\n    -e VPN_PIA_PREFERRED_REGION=\"\" \\ #(7)\n    -e VPN_PIA_DIP_TOKEN=\"no\" \\ #(13)\n    -e VPN_PIA_PORT_FORWARD_PERSIST=\"false\" \\ #(14)\n    -e PRIVOXY_ENABLED=\"false\" \\ #(19)\n    -e UNBOUND_ENABLED=\"false\" \\ #(21)\n    -e UNBOUND_NAMESERVERS=\"\" \\ #(22)\n    --cap-add=NET_ADMIN \\\n    --sysctl=\"net.ipv4.conf.all.src_valid_mark=1\" \\ #(12)\n    --sysctl=\"net.ipv6.conf.all.disable_ipv6=1\" \\ #(3)\n    --device /dev/net/tun:/dev/net/tun \\ # OPTIONAL(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui. On MacOS set it to <code>192.168.65.0/24</code> (Verify with your settings [Resources &gt; Network &gt; Docker subnet]).</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>. Affiliate links: Proton VPN Proton Unlimited Private Internet Access</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> (for PIA this is done automatically, see <code>VPN_PROVIDER</code> variable) located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32 in most cases\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>DANGEROUS! Don't enable unless you know what you are doing!</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>Some of the possible values are for example <code>wg</code>, <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>wg</code> will use the nameservers from the <code>wg0.conf</code> file. A value in the format <code>8.8.8.8</code> is to use a plain old nameserver. A value in the format <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>If you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice.</p> </li> <li> <p>This will start Privoxy on the default port 8118 when set to <code>true</code>. By default Privoxy is not exposed on the LAN, so if you need that, you'll have to add <code>VPN_EXPOSE_PORTS_ON_LAN=8118/tcp,8118/udp</code>.</p> </li> <li> <p>Enabling this will bring down the container if the connectivity tests fail at the end of the Wireguard init process or for an extended period during the container runtime.</p> </li> <li> <p>Enable Unbound by setting to <code>true</code> when VPN is not active.</p> </li> <li> <p>Possible values are <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>8.8.8.8</code> is to use a plain old nameserver. The value <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> </ol> <pre><code>services:\n  app:\n    hostname: container-name.internal #(18)\n    environment:\n      - VPN_ENABLED=true #(5)\n      - VPN_CONF=wg0 #(8)\n      - VPN_PROVIDER=pia #(4)\n      - VPN_LAN_NETWORK=192.168.1.0/24 #(1)\n      - VPN_LAN_LEAK_ENABLED=false #(10)\n      - VPN_EXPOSE_PORTS_ON_LAN #(2)\n      - VPN_AUTO_PORT_FORWARD=true #(6)\n      - VPN_AUTO_PORT_FORWARD_TO_PORTS= #(15)\n      - VPN_FIREWALL_TYPE=auto #(17)\n      - VPN_HEALTHCHECK_ENABLED=false #(20)\n      - VPN_NAMESERVERS= #(16)\n      - VPN_PIA_USER #(11)\n      - VPN_PIA_PASS #(11)\n      - VPN_PIA_PREFERRED_REGION #(7)\n      - VPN_PIA_DIP_TOKEN=no #(13)\n      - VPN_PIA_PORT_FORWARD_PERSIST=false #(14)\n      - PRIVOXY_ENABLED=false #(19)\n      - UNBOUND_ENABLED=false #(21)\n      - UNBOUND_NAMESERVERS #(22)\n    cap_add:\n      - NET_ADMIN\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1 #(12)\n      - net.ipv6.conf.all.disable_ipv6=1 #(3)\n    devices:\n      - /dev/net/tun:/dev/net/tun # OPTIONAL(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui. On MacOS set it to <code>192.168.65.0/24</code> (Verify with your settings [Resources &gt; Network &gt; Docker subnet]).</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>. Affiliate links: Proton VPN Proton Unlimited Private Internet Access</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> (for PIA this is done automatically, see <code>VPN_PROVIDER</code> variable) located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32 in most cases\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>DANGEROUS! Don't enable unless you know what you are doing!</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>Some of the possible values are for example <code>wg</code>, <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>wg</code> will use the nameservers from the <code>wg0.conf</code> file. A value in the format <code>8.8.8.8</code> is to use a plain old nameserver. A value in the format <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>If you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice.</p> </li> <li> <p>This will start Privoxy on the default port 8118 when set to <code>true</code>. By default Privoxy is not exposed on the LAN, so if you need that, you'll have to add <code>VPN_EXPOSE_PORTS_ON_LAN=8118/tcp,8118/udp</code>.</p> </li> <li> <p>Enabling this will bring down the container if the connectivity tests fail at the end of the Wireguard init process or for an extended period during the container runtime.</p> </li> <li> <p>Enable Unbound by setting to <code>true</code> when VPN is not active.</p> </li> <li> <p>Possible values are <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>8.8.8.8</code> is to use a plain old nameserver. The value <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> </ol>"},{"location":"containers/whisparr/","title":"hotio/whisparr","text":"<p> GitHub ghcr.io</p>"},{"location":"containers/whisparr/#starting-the-container","title":"Starting the container","text":"clicompose <pre><code>docker run --rm \\\n    --name whisparr \\\n    -p 6969:6969 \\\n    -e PUID=1000 \\\n    -e PGID=1000 \\\n    -e UMASK=002 \\\n    -e TZ=\"Etc/UTC\" \\\n    -v /&lt;host_folder_config&gt;:/config \\\n    -v /&lt;host_folder_data&gt;:/data \\\n    ghcr.io/hotio/whisparr\n</code></pre> <pre><code>services:\n  whisparr:\n    container_name: whisparr\n    image: ghcr.io/hotio/whisparr\n    ports:\n      - \"6969:6969\"\n    environment:\n      - PUID=1000\n      - PGID=1000\n      - UMASK=002\n      - TZ=Etc/UTC\n    volumes:\n      - /&lt;host_folder_config&gt;:/config\n      - /&lt;host_folder_data&gt;:/data\n</code></pre>"},{"location":"containers/whisparr/#tags","title":"Tags","text":"Tags Description Last Updated Age"},{"location":"containers/whisparr/#wireguard","title":"WireGuard","text":"<p>Info</p> <p>This image includes VPN support. The cli/compose examples below are environment variables and settings complementary to the app image examples, this means you'll have to add/merge the stuff below with the stuff above. In case you are still in need of a VPN, consider using my affiliate links for Proton VPN, Proton Unlimited or Private Internet Access.</p> <p> </p> genericprotonpia clicompose <pre><code>docker run --rm \\\n    --hostname container-name.internal \\ #(18)\n    -e VPN_ENABLED=\"true\" \\ #(5)\n    -e VPN_CONF=\"wg0\" \\ #(8)\n    -e VPN_PROVIDER=\"generic\" \\ #(4)\n    -e VPN_LAN_NETWORK=\"192.168.1.0/24\" \\ #(1)\n    -e VPN_LAN_LEAK_ENABLED=\"false\" \\ #(10)\n    -e VPN_EXPOSE_PORTS_ON_LAN=\"\" \\ #(2)\n    -e VPN_AUTO_PORT_FORWARD=\"false\" \\ #(6)\n    -e VPN_AUTO_PORT_FORWARD_TO_PORTS=\"\" \\ #(15)\n    -e VPN_FIREWALL_TYPE=\"auto\" \\ #(17)\n    -e VPN_HEALTHCHECK_ENABLED=\"false\" \\ #(20)\n    -e VPN_NAMESERVERS=\"\" \\ #(16)\n    -e PRIVOXY_ENABLED=\"false\" \\ #(19)\n    -e UNBOUND_ENABLED=\"false\" \\ #(21)\n    -e UNBOUND_NAMESERVERS=\"\" \\ #(22)\n    --cap-add=NET_ADMIN \\\n    --sysctl=\"net.ipv4.conf.all.src_valid_mark=1\" \\ #(12)\n    --sysctl=\"net.ipv6.conf.all.disable_ipv6=1\" \\ #(3)\n    --device /dev/net/tun:/dev/net/tun \\ # OPTIONAL(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui. On MacOS set it to <code>192.168.65.0/24</code> (Verify with your settings [Resources &gt; Network &gt; Docker subnet]).</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>. Affiliate links: Proton VPN Proton Unlimited Private Internet Access</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> (for PIA this is done automatically, see <code>VPN_PROVIDER</code> variable) located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32 in most cases\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>DANGEROUS! Don't enable unless you know what you are doing!</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>Some of the possible values are for example <code>wg</code>, <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>wg</code> will use the nameservers from the <code>wg0.conf</code> file. A value in the format <code>8.8.8.8</code> is to use a plain old nameserver. A value in the format <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>If you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice.</p> </li> <li> <p>This will start Privoxy on the default port 8118 when set to <code>true</code>. By default Privoxy is not exposed on the LAN, so if you need that, you'll have to add <code>VPN_EXPOSE_PORTS_ON_LAN=8118/tcp,8118/udp</code>.</p> </li> <li> <p>Enabling this will bring down the container if the connectivity tests fail at the end of the Wireguard init process or for an extended period during the container runtime.</p> </li> <li> <p>Enable Unbound by setting to <code>true</code> when VPN is not active.</p> </li> <li> <p>Possible values are <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>8.8.8.8</code> is to use a plain old nameserver. The value <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> </ol> <pre><code>services:\n  app:\n    hostname: container-name.internal #(18)\n    environment:\n      - VPN_ENABLED=true #(5)\n      - VPN_CONF=wg0 #(8)\n      - VPN_PROVIDER=generic #(4)\n      - VPN_LAN_NETWORK=192.168.1.0/24 #(1)\n      - VPN_LAN_LEAK_ENABLED=false #(10)\n      - VPN_EXPOSE_PORTS_ON_LAN #(2)\n      - VPN_AUTO_PORT_FORWARD=false #(6)\n      - VPN_AUTO_PORT_FORWARD_TO_PORTS= #(15)\n      - VPN_FIREWALL_TYPE=auto #(17)\n      - VPN_HEALTHCHECK_ENABLED=false #(20)\n      - VPN_NAMESERVERS= #(16)\n      - PRIVOXY_ENABLED=false #(19)\n      - UNBOUND_ENABLED=false #(21)\n      - UNBOUND_NAMESERVERS #(22)\n    cap_add:\n      - NET_ADMIN\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1 #(12)\n      - net.ipv6.conf.all.disable_ipv6=1 #(3)\n    devices:\n      - /dev/net/tun:/dev/net/tun # OPTIONAL(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui. On MacOS set it to <code>192.168.65.0/24</code> (Verify with your settings [Resources &gt; Network &gt; Docker subnet]).</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>. Affiliate links: Proton VPN Proton Unlimited Private Internet Access</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> (for PIA this is done automatically, see <code>VPN_PROVIDER</code> variable) located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32 in most cases\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>DANGEROUS! Don't enable unless you know what you are doing!</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>Some of the possible values are for example <code>wg</code>, <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>wg</code> will use the nameservers from the <code>wg0.conf</code> file. A value in the format <code>8.8.8.8</code> is to use a plain old nameserver. A value in the format <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>If you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice.</p> </li> <li> <p>This will start Privoxy on the default port 8118 when set to <code>true</code>. By default Privoxy is not exposed on the LAN, so if you need that, you'll have to add <code>VPN_EXPOSE_PORTS_ON_LAN=8118/tcp,8118/udp</code>.</p> </li> <li> <p>Enabling this will bring down the container if the connectivity tests fail at the end of the Wireguard init process or for an extended period during the container runtime.</p> </li> <li> <p>Enable Unbound by setting to <code>true</code> when VPN is not active.</p> </li> <li> <p>Possible values are <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>8.8.8.8</code> is to use a plain old nameserver. The value <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> </ol> clicompose <pre><code>docker run --rm \\\n    --hostname container-name.internal \\ #(18)\n    -e VPN_ENABLED=\"true\" \\ #(5)\n    -e VPN_CONF=\"wg0\" \\ #(8)\n    -e VPN_PROVIDER=\"proton\" \\ #(4)\n    -e VPN_LAN_NETWORK=\"192.168.1.0/24\" \\ #(1)\n    -e VPN_LAN_LEAK_ENABLED=\"false\" \\ #(10)\n    -e VPN_EXPOSE_PORTS_ON_LAN=\"\" \\ #(2)\n    -e VPN_AUTO_PORT_FORWARD=\"true\" \\ #(6)\n    -e VPN_AUTO_PORT_FORWARD_TO_PORTS=\"\" \\ #(15)\n    -e VPN_FIREWALL_TYPE=\"auto\" \\ #(17)\n    -e VPN_HEALTHCHECK_ENABLED=\"false\" \\ #(20)\n    -e VPN_NAMESERVERS=\"\" \\ #(16)\n    -e PRIVOXY_ENABLED=\"false\" \\ #(19)\n    -e UNBOUND_ENABLED=\"false\" \\ #(21)\n    -e UNBOUND_NAMESERVERS=\"\" \\ #(22)\n    --cap-add=NET_ADMIN \\\n    --sysctl=\"net.ipv4.conf.all.src_valid_mark=1\" \\ #(12)\n    --sysctl=\"net.ipv6.conf.all.disable_ipv6=1\" \\ #(3)\n    --device /dev/net/tun:/dev/net/tun \\ # OPTIONAL(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui. On MacOS set it to <code>192.168.65.0/24</code> (Verify with your settings [Resources &gt; Network &gt; Docker subnet]).</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>. Affiliate links: Proton VPN Proton Unlimited Private Internet Access</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> (for PIA this is done automatically, see <code>VPN_PROVIDER</code> variable) located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32 in most cases\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>DANGEROUS! Don't enable unless you know what you are doing!</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>Some of the possible values are for example <code>wg</code>, <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>wg</code> will use the nameservers from the <code>wg0.conf</code> file. A value in the format <code>8.8.8.8</code> is to use a plain old nameserver. A value in the format <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>If you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice.</p> </li> <li> <p>This will start Privoxy on the default port 8118 when set to <code>true</code>. By default Privoxy is not exposed on the LAN, so if you need that, you'll have to add <code>VPN_EXPOSE_PORTS_ON_LAN=8118/tcp,8118/udp</code>.</p> </li> <li> <p>Enabling this will bring down the container if the connectivity tests fail at the end of the Wireguard init process or for an extended period during the container runtime.</p> </li> <li> <p>Enable Unbound by setting to <code>true</code> when VPN is not active.</p> </li> <li> <p>Possible values are <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>8.8.8.8</code> is to use a plain old nameserver. The value <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> </ol> <pre><code>services:\n  app:\n    hostname: container-name.internal #(18)\n    environment:\n      - VPN_ENABLED=true #(5)\n      - VPN_CONF=wg0 #(8)\n      - VPN_PROVIDER=proton #(4)\n      - VPN_LAN_NETWORK=192.168.1.0/24 #(1)\n      - VPN_LAN_LEAK_ENABLED=false #(10)\n      - VPN_EXPOSE_PORTS_ON_LAN #(2)\n      - VPN_AUTO_PORT_FORWARD=true #(6)\n      - VPN_AUTO_PORT_FORWARD_TO_PORTS= #(15)\n      - VPN_FIREWALL_TYPE=auto #(17)\n      - VPN_HEALTHCHECK_ENABLED=false #(20)\n      - VPN_NAMESERVERS= #(16)\n      - PRIVOXY_ENABLED=false #(19)\n      - UNBOUND_ENABLED=false #(21)\n      - UNBOUND_NAMESERVERS #(22)\n    cap_add:\n      - NET_ADMIN\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1 #(12)\n      - net.ipv6.conf.all.disable_ipv6=1 #(3)\n    devices:\n      - /dev/net/tun:/dev/net/tun # OPTIONAL(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui. On MacOS set it to <code>192.168.65.0/24</code> (Verify with your settings [Resources &gt; Network &gt; Docker subnet]).</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>. Affiliate links: Proton VPN Proton Unlimited Private Internet Access</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> (for PIA this is done automatically, see <code>VPN_PROVIDER</code> variable) located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32 in most cases\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>DANGEROUS! Don't enable unless you know what you are doing!</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>Some of the possible values are for example <code>wg</code>, <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>wg</code> will use the nameservers from the <code>wg0.conf</code> file. A value in the format <code>8.8.8.8</code> is to use a plain old nameserver. A value in the format <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>If you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice.</p> </li> <li> <p>This will start Privoxy on the default port 8118 when set to <code>true</code>. By default Privoxy is not exposed on the LAN, so if you need that, you'll have to add <code>VPN_EXPOSE_PORTS_ON_LAN=8118/tcp,8118/udp</code>.</p> </li> <li> <p>Enabling this will bring down the container if the connectivity tests fail at the end of the Wireguard init process or for an extended period during the container runtime.</p> </li> <li> <p>Enable Unbound by setting to <code>true</code> when VPN is not active.</p> </li> <li> <p>Possible values are <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>8.8.8.8</code> is to use a plain old nameserver. The value <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> </ol> clicompose <pre><code>docker run --rm \\\n    --hostname container-name.internal \\ #(18)\n    -e VPN_ENABLED=\"true\" \\ #(5)\n    -e VPN_CONF=\"wg0\" \\ #(8)\n    -e VPN_PROVIDER=\"pia\" \\ #(4)\n    -e VPN_LAN_NETWORK=\"192.168.1.0/24\" \\ #(1)\n    -e VPN_LAN_LEAK_ENABLED=\"false\" \\ #(10)\n    -e VPN_EXPOSE_PORTS_ON_LAN=\"\" \\ #(2)\n    -e VPN_AUTO_PORT_FORWARD=\"true\" \\ #(6)\n    -e VPN_AUTO_PORT_FORWARD_TO_PORTS=\"\" \\ #(15)\n    -e VPN_FIREWALL_TYPE=\"auto\" \\ #(17)\n    -e VPN_HEALTHCHECK_ENABLED=\"false\" \\ #(20)\n    -e VPN_NAMESERVERS=\"\" \\ #(16)\n    -e VPN_PIA_USER=\"\" \\ #(11)\n    -e VPN_PIA_PASS=\"\" \\ #(11)\n    -e VPN_PIA_PREFERRED_REGION=\"\" \\ #(7)\n    -e VPN_PIA_DIP_TOKEN=\"no\" \\ #(13)\n    -e VPN_PIA_PORT_FORWARD_PERSIST=\"false\" \\ #(14)\n    -e PRIVOXY_ENABLED=\"false\" \\ #(19)\n    -e UNBOUND_ENABLED=\"false\" \\ #(21)\n    -e UNBOUND_NAMESERVERS=\"\" \\ #(22)\n    --cap-add=NET_ADMIN \\\n    --sysctl=\"net.ipv4.conf.all.src_valid_mark=1\" \\ #(12)\n    --sysctl=\"net.ipv6.conf.all.disable_ipv6=1\" \\ #(3)\n    --device /dev/net/tun:/dev/net/tun \\ # OPTIONAL(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui. On MacOS set it to <code>192.168.65.0/24</code> (Verify with your settings [Resources &gt; Network &gt; Docker subnet]).</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>. Affiliate links: Proton VPN Proton Unlimited Private Internet Access</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> (for PIA this is done automatically, see <code>VPN_PROVIDER</code> variable) located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32 in most cases\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>DANGEROUS! Don't enable unless you know what you are doing!</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>Some of the possible values are for example <code>wg</code>, <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>wg</code> will use the nameservers from the <code>wg0.conf</code> file. A value in the format <code>8.8.8.8</code> is to use a plain old nameserver. A value in the format <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>If you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice.</p> </li> <li> <p>This will start Privoxy on the default port 8118 when set to <code>true</code>. By default Privoxy is not exposed on the LAN, so if you need that, you'll have to add <code>VPN_EXPOSE_PORTS_ON_LAN=8118/tcp,8118/udp</code>.</p> </li> <li> <p>Enabling this will bring down the container if the connectivity tests fail at the end of the Wireguard init process or for an extended period during the container runtime.</p> </li> <li> <p>Enable Unbound by setting to <code>true</code> when VPN is not active.</p> </li> <li> <p>Possible values are <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>8.8.8.8</code> is to use a plain old nameserver. The value <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> </ol> <pre><code>services:\n  app:\n    hostname: container-name.internal #(18)\n    environment:\n      - VPN_ENABLED=true #(5)\n      - VPN_CONF=wg0 #(8)\n      - VPN_PROVIDER=pia #(4)\n      - VPN_LAN_NETWORK=192.168.1.0/24 #(1)\n      - VPN_LAN_LEAK_ENABLED=false #(10)\n      - VPN_EXPOSE_PORTS_ON_LAN #(2)\n      - VPN_AUTO_PORT_FORWARD=true #(6)\n      - VPN_AUTO_PORT_FORWARD_TO_PORTS= #(15)\n      - VPN_FIREWALL_TYPE=auto #(17)\n      - VPN_HEALTHCHECK_ENABLED=false #(20)\n      - VPN_NAMESERVERS= #(16)\n      - VPN_PIA_USER #(11)\n      - VPN_PIA_PASS #(11)\n      - VPN_PIA_PREFERRED_REGION #(7)\n      - VPN_PIA_DIP_TOKEN=no #(13)\n      - VPN_PIA_PORT_FORWARD_PERSIST=false #(14)\n      - PRIVOXY_ENABLED=false #(19)\n      - UNBOUND_ENABLED=false #(21)\n      - UNBOUND_NAMESERVERS #(22)\n    cap_add:\n      - NET_ADMIN\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1 #(12)\n      - net.ipv6.conf.all.disable_ipv6=1 #(3)\n    devices:\n      - /dev/net/tun:/dev/net/tun # OPTIONAL(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui. On MacOS set it to <code>192.168.65.0/24</code> (Verify with your settings [Resources &gt; Network &gt; Docker subnet]).</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>. Affiliate links: Proton VPN Proton Unlimited Private Internet Access</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> (for PIA this is done automatically, see <code>VPN_PROVIDER</code> variable) located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32 in most cases\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>DANGEROUS! Don't enable unless you know what you are doing!</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>Some of the possible values are for example <code>wg</code>, <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>wg</code> will use the nameservers from the <code>wg0.conf</code> file. A value in the format <code>8.8.8.8</code> is to use a plain old nameserver. A value in the format <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>If you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice.</p> </li> <li> <p>This will start Privoxy on the default port 8118 when set to <code>true</code>. By default Privoxy is not exposed on the LAN, so if you need that, you'll have to add <code>VPN_EXPOSE_PORTS_ON_LAN=8118/tcp,8118/udp</code>.</p> </li> <li> <p>Enabling this will bring down the container if the connectivity tests fail at the end of the Wireguard init process or for an extended period during the container runtime.</p> </li> <li> <p>Enable Unbound by setting to <code>true</code> when VPN is not active.</p> </li> <li> <p>Possible values are <code>8.8.8.8</code> or <code>1.1.1.1@853#cloudflare-dns.com</code> seperated by a <code>,</code>. The value <code>8.8.8.8</code> is to use a plain old nameserver. The value <code>1.1.1.1@853#cloudflare-dns.com</code> will add a <code>DNS over TLS</code> nameserver, this will override all other regular nameservers. Leaving the variable empty will allow Unbound to work in recursive mode.</p> </li> </ol>"},{"location":"scripts/arr-discord-notifier/","title":"Arr Discord Notifier","text":"<p>Announcement</p> <p>Both Sonarr and Radarr now come with built-in Discord notifications based on this script, so it's no longer bundled with those images. The script still works though if you prefer to use it.</p> <p> GitHub </p> <p>Arr Discord Notifier sends pretty notifications to a discord webhook. The Radarr and Sonarr v3 (only v3 is supported) docker images come bundled with this script, but it can also be used on its own.</p>"},{"location":"scripts/arr-discord-notifier/#configuration","title":"Configuration","text":"<p>Add a <code>Custom Script</code> to the <code>Connect</code> settings in Sonarr/Radarr as seen below.  </p> <p></p> <p>Then add the environment variable <code>DISCORD_WEBHOOK</code> with your webhook url provided by Discord to the container. After that hit the <code>Test</code> button and you should see a notification appear in your discord channel.  </p> <p>If you also configure the environment variable <code>TMDB_API_KEY</code>, when possible it will use an episode still as a backdrop image and add a <code>Cast</code> field.</p> <p>If you want to hide some fields, you can use <code>DROP_FIELDS=\"backdrop overview release airdate\"</code> as a variable, all field names in lowercase, <code>backdrop</code> and <code>poster</code> are valid values too.</p> <p>Sending to multiple webhooks can be done with additional variables like <code>DISCORD_WEBHOOK_0</code> and <code>DROP_FIELDS_0</code>.</p> <p>By default the hostname is used as the Author of the notification, you can modify this by changing the hostname or the variable <code>AUTHOR_NAME</code>.</p>"},{"location":"scripts/arr-discord-notifier/#sample-images","title":"Sample images","text":""},{"location":"scripts/pullio/","title":"Pullio","text":"<p> GitHub </p> <p>Updating your docker containers the easy way.</p> <p>Pullio is a bash script that you execute with cron, a systemd timer or any other way that you prefer. It then does a <code>docker compose pull</code> for all the containers configured to have notifications or updates enabled. It then checks if there's an update available and takes action according to your configuration. As you might have already guessed it, this script relies on <code>docker compose</code> to do the heavy lifting and thus is only compatible with <code>docker compose</code> managed containers.</p> <p>Features:</p> <ul> <li>Discord notifications (see below for preview)</li> <li>No notifications if you leave the webhook out, it'll run as an updater and script executer</li> <li>Detailed info about what has changed for images that follow the Opencontainers Annotation Keys</li> <li>Execute script before sending notification</li> <li>Execute script before updating container, after container is stopped</li> <li>Private registries</li> <li>With <code>--tag</code> you can use seperate configs for hourly \"Update available\" notifications and on a daily schedule actually apply the updates</li> </ul>"},{"location":"scripts/pullio/#installation","title":"Installation","text":"<pre><code>sudo curl -fsSL \"https://raw.githubusercontent.com/hotio/pullio/master/pullio.sh\" -o /usr/local/bin/pullio\nsudo chmod +x /usr/local/bin/pullio\n</code></pre> <p>Now execute it however and whenever you want.</p>"},{"location":"scripts/pullio/#configuration","title":"Configuration","text":"<p>You configure the script its behaviour by adding one or more of the following labels to your <code>compose.yaml</code> for every container you want. Adding no discord webhook will disable the notifications.</p> <pre><code>...\nlabels:\n  - \"org.hotio.pullio.notify=true\"\n  - \"org.hotio.pullio.update=true\"\n  - \"org.hotio.pullio.discord.webhook=https://discord.com/api/webhooks/...\"\n  - \"org.hotio.pullio.generic.webhook=https://some.domain.com/api/webhooks/...\"\n  - \"org.hotio.pullio.author.avatar=https://domain.com/logo.png\"\n  - \"org.hotio.pullio.script.notify=bash /notify-script.sh\"\n  - \"org.hotio.pullio.script.update=bash /update-script.sh\"\n  - \"org.hotio.pullio.registry.authfile=/authfile.txt\"\n</code></pre> <p>Using <code>--tag mytag</code>, would let you do the following.</p> <pre><code>...\nlabels:\n  - \"org.hotio.pullio.mytag.notify=true\"\n  - \"org.hotio.pullio.mytag.discord.webhook=https://discord.com/api/webhooks/...\"\n</code></pre> <p>If you need to provide credentials for a Private Registry, this file's content needs to be as shown below.</p> <pre><code>{\n  \"registry\": \"ghcr.io\",\n  \"username\": \"your_username\",\n  \"password\": \"your_password\"\n}\n</code></pre> <p>Info</p> <p>Don't forget to do <code>cd /path/of/compose/file</code> and <code>docker compose up -d</code> after adding the labels. The use of <code>-f</code> is not supported.</p>"},{"location":"scripts/pullio/#troubleshooting","title":"Troubleshooting","text":"<p>It can be frustrating to test the script if no docker image updates are available, for that you can do <code>./pullio.sh --debug</code> and the script will behave as if an update is available.</p>"},{"location":"scripts/pullio/#notification-preview","title":"Notification preview","text":""},{"location":"scripts/sysinfo/","title":"SysInfo","text":"<p> GitHub </p> <p>Get a quick system overview from the terminal, an ideal replacement for web based dashboards.</p> <p>Features:</p> <ul> <li><code>system info</code>, basic info about your system like uptime and load, on <code>apt-get</code> based systems it'll also show amount of available updates</li> <li><code>ip addresses</code>, all the global ip addresses easily viewable</li> <li><code>thermals</code>, get a few temperatures from the kernel provided thermal zones</li> <li><code>ups info</code>, the important stuff you need to know about your NUT supported UPS</li> <li><code>docker</code>, see how your docker containers are doing</li> <li><code>virtual machines</code>, keep an eye on which vm is running</li> <li><code>systemd services</code>, services added in the config will show up</li> <li><code>smb shares</code>, what folder is exported and who has access, you can see it here</li> <li><code>network traffic</code>, if vnstat is available, you can see it here</li> <li><code>memory usage</code>, see your usage before your system experiences a OOM failure</li> <li><code>disk space usage</code>, the same as with memory, but for disk space</li> <li><code>physical drives</code>, spot drive health before it's too late</li> </ul>"},{"location":"scripts/sysinfo/#installation","title":"Installation","text":"<pre><code>sudo curl -fsSL \"https://raw.githubusercontent.com/hotio/sysinfo.sh/master/sysinfo.sh\" -o /usr/local/bin/sysinfo\nsudo chmod +x /usr/local/bin/sysinfo\n</code></pre>"},{"location":"scripts/sysinfo/#config","title":"Config","text":"<p>Check the script's content for the config section and available settings. Any of those settings can also be placed in a file <code>/etc/default/hotio-sysinfo</code> to allow for script updates without losing the config.</p>"},{"location":"scripts/sysinfo/#execution","title":"Execution","text":"<p>Now execute <code>sysinfo --help</code> to see all available options, which you can combine to show what you want or just <code>sysinfo</code> to show everything. Some options require <code>sudo</code> or <code>root</code>.</p>"},{"location":"scripts/sysinfo/#preview","title":"Preview","text":""}]}